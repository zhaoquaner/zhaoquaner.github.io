<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhaoquaner.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="赵圈儿的博客">
<meta property="og:url" content="https://zhaoquaner.github.io/page/7/index.html">
<meta property="og:site_name" content="赵圈儿的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZhaoXin">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhaoquaner.github.io/page/7/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/7/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>赵圈儿的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">赵圈儿的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">23</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">169</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhaoXin"
      src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
  <p class="site-author-name" itemprop="name">ZhaoXin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">169</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoquaner" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoquaner" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zx1522202417@163.com" title="E-Mail → mailto:zx1522202417@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E9%98%9F%E5%88%97/10-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E9%98%9F%E5%88%97/10-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/" class="post-title-link" itemprop="url">10-用队列实现栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:10:39 / 修改时间：15:48:51" itemprop="dateCreated datePublished" datetime="2022-05-11T15:10:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/queue/" itemprop="url" rel="index"><span itemprop="name">队列</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210422200135721.png" alt="image-20210422200135721" style="zoom:50%;" /></p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>两个队列，相互交替作为数据栈。每次移除栈顶元素或返回栈顶元素时，就将当前队列数据从队列头部依次弹出，并插入到另一个队列尾部，剩下最后一个元素，如果是移除栈顶元素，则直接返回该元素；如果是返回栈顶元素，则先插入到另一个队列尾部，再返回。</p>
<h3 id="算法思想-1">算法思想</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue2;</span><br><span class="line"></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; * stack;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; * queue;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        stack = &amp;queue1;</span><br><span class="line">        queue = &amp;queue2;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack-&gt;<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = stack-&gt;<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; *temp = stack;</span><br><span class="line">        stack = queue;</span><br><span class="line">        queue = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            stack-&gt;<span class="built_in">push</span>(queue-&gt;<span class="built_in">front</span>());</span><br><span class="line">            queue-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> top = queue-&gt;<span class="built_in">front</span>();</span><br><span class="line">        queue-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = stack-&gt;<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        std::queue&lt;<span class="type">int</span>&gt; *temp = stack;</span><br><span class="line">        stack = queue;</span><br><span class="line">        queue = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            stack-&gt;<span class="built_in">push</span>(queue-&gt;<span class="built_in">front</span>());</span><br><span class="line">            queue-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> top = queue-&gt;<span class="built_in">front</span>();</span><br><span class="line">        stack-&gt;<span class="built_in">push</span>(top);</span><br><span class="line">        queue-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack-&gt;<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<ul>
<li><code>push</code>：直接插入到队列尾部，<span
class="math inline">\(O(1)\)</span>。</li>
<li><code>pop</code>：需要把数据挪到另一个队列中，为<span
class="math inline">\(O(n)\)</span>。</li>
<li><code>top</code>：和<code>pop</code>一样，同样要移动数据，也为<span
class="math inline">\(O(n)\)</span>。</li>
<li><code>empty</code>：<span class="math inline">\(O(1)\)</span>。</li>
</ul>
<h2 id="官方做法">官方做法</h2>
<h3 id="算法思想-2">算法思想</h3>
<p>栈顶元素应在队列头部。</p>
<p>两个队列，一个是主队列，另一个是辅助队列。当入栈时，执行以下操作：</p>
<ul>
<li>将待入栈元素插入到辅助队列中</li>
<li>将主队列元素依次移除并插入到辅助队列中</li>
<li>再将辅助队列元素依次移除并插入到主队列中</li>
</ul>
<p>入栈操作完成。</p>
<p>这样就能始终保持队列头部和栈顶元素一致。</p>
<p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月22日20时41分47秒.gif" alt="21年04月22日20时41分47秒" style="zoom:50%;" /></p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; main_queue;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; queue;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!main_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            queue.<span class="built_in">push</span>(main_queue.<span class="built_in">front</span>());</span><br><span class="line">            main_queue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(main_queue, queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> top = main_queue.<span class="built_in">front</span>();</span><br><span class="line">        main_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> main_queue.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> main_queue.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-1">性能分析</h3>
<p><code>push</code>：需要将主队列数据依次插入辅助队列，再重新插入主队列。为<span
class="math inline">\(O(n)\)</span>。</p>
<p>其他操作都为<span class="math inline">\(O(1)\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/9-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/9-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/" class="post-title-link" itemprop="url">9-重复元素II</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:09:39 / 修改时间：16:01:09" itemprop="dateCreated datePublished" datetime="2022-05-11T15:09:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/array/" itemprop="url" rel="index"><span itemprop="name">数组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210421204213945.png" alt="image-20210421204213945" style="zoom:50%;" /></p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>使用map集合，数组的值作为key，数组索引作为value。</p>
<p>遍历数组，在map中查找是否有key相等的元素，如果没有，则将当前数组值和索引插入map集合；</p>
<p>如果有，则用当前索引 -
map集合相等的索引，如果小于等于k，则直接返回true；</p>
<p>如果大于，则将map集合值相等的对应索引改为当前索引。</p>
<p>注：因为如果当前索引 -
map集合中索引已经大于k，那么数组后面的元素一定更大于K，所以应将map集合索引改为当前索引。</p>
<p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月21日21时05分22秒.gif" alt="21年04月21日21时05分22秒" style="zoom:67%;" /></p>
<p>注：动画有个错误，第一个索引差 应该是 3 - 0 &gt; k = 2。</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers.<span class="built_in">count</span>(nums[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                numbers.<span class="built_in">insert</span>(&#123;nums[i], i&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(i - numbers.<span class="built_in">at</span>(nums[i]) &lt;= k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                    numbers.<span class="built_in">at</span>(nums[i]) = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<p>时间复杂度：遍历数组，<span class="math inline">\(O(n)\)</span>。</p>
<p>空间复杂度：<span class="math inline">\(O(n)\)</span>。</p>
<h2 id="官方做法">官方做法</h2>
<h3 id="哈希表">哈希表</h3>
<h4 id="算法思想-1">算法思想</h4>
<p>使用哈希表来存储数组值，遍历数组，查找哈希表是否存在相等的元素，如果没有，则存入当前元素，并判断哈希表长度是否大于k，如果大于，则删除最旧的元素(即最先加入来的元素)；</p>
<p>如果存在相等元素，返回true。</p>
<h4 id="算法实现-1">算法实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        set&lt;<span class="type">int</span>&gt; number;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(number.<span class="built_in">count</span>(nums[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            number.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(number.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                number.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析-1">性能分析</h4>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span>。</p>
<p>空间复杂度：<span class="math inline">\(O(n)\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/8-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/8-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/" class="post-title-link" itemprop="url">8-重复元素</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:08:39 / 修改时间：16:00:53" itemprop="dateCreated datePublished" datetime="2022-05-11T15:08:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/array/" itemprop="url" rel="index"><span itemprop="name">数组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210421201032222.png" alt="image-20210421201032222" style="zoom:50%;" /></p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>使用哈希表，遍历数组，先查看哈希表是否有相同元素，如果有，则停止遍历，返回true；直到遍历结束，返回false。</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers.<span class="built_in">count</span>(nums[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                numbers.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<p>时间复杂度：遍历数组，<span class="math inline">\(O(n)\)</span>。</p>
<p>空间复杂度：使用了哈希表，<span
class="math inline">\(O(n)\)</span>。</p>
<h2 id="官方做法">官方做法</h2>
<h3 id="算法思想-1">算法思想</h3>
<p>把数组排序，然后依次比较相邻元素。</p>
<h3 id="算法实现-1">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">containsDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-1">性能分析</h3>
<p>时间复杂度：就是排序时间复杂度：<span
class="math inline">\(O(n*logn)\)</span>。</p>
<p>空间复杂度：自己实现排序算法，空间复杂度为<span
class="math inline">\(O(1)\)</span>，使用默认排序算法，为<span
class="math inline">\(O(n)\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/7-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/7-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">7-反转链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:07:39 / 修改时间：15:49:41" itemprop="dateCreated datePublished" datetime="2022-05-11T15:07:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/linkedlist/" itemprop="url" rel="index"><span itemprop="name">链表</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210420195746281.png" alt="image-20210420195746281" style="zoom:67%;" /></p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>使用三个指针<code>cur</code>、<code>pre</code>和<code>next</code>，遍历链表。<code>cur</code>代表当前指向的结点，<code>pre</code>代表当前<code>cur</code>的前一个结点，<code>next</code>代表<code>cur</code>的后一个结点。</p>
<p>初始时，<code>cur</code>指向<code>head-&gt;next</code>即链表第二个结点，<code>pre</code>指向<code>head</code>，即头结点。<code>next</code>为空指针。</p>
<p>然后依次执行以下步骤：</p>
<ul>
<li><p><code>next</code>结点指向<code>cur</code>的下一个节点</p></li>
<li><p><code>cur</code>结点的<code>next</code>指向<code>pre</code>结点</p></li>
<li><p><code>pre</code>结点指向<code>cur</code>结点</p></li>
<li><p><code>cur</code>指向<code>next</code>节点</p></li>
</ul>
<p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月20日20时23分50秒.gif" alt="21年04月20日20时23分50秒" style="zoom:50%;" /></p>
<p>这样就将<code>pre</code>和<code>cur</code>指向的结点进行了反转，并指向了下一个要反转的结点。</p>
<p>直到<code>cur</code>指向了空，此时循环结束，链表反转完成。</p>
<p><strong>注：</strong></p>
<ul>
<li><p><strong>要注意，当反转链表第一个结点和第二个结点时，第一个结点的next应置为空</strong></p></li>
<li><p><strong>初始时，<code>cur</code>指向了链表第二个结点，说明这种方法只适用于链表结点数大于等于2的情况，所以需要先加一个判断，保证链表结点数大于等于2。</strong></p></li>
</ul>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line"></span><br><span class="line">        ListNode * pre = head;</span><br><span class="line">        ListNode * cur = head-&gt;next;</span><br><span class="line">        ListNode * next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre == head) &#123;</span><br><span class="line">                pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有一种更简单的写法，省去了判断链表结点数是否大于等于2和<code>pre ==
head</code>的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode * pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        ListNode * next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre == head) &#123;</span><br><span class="line">                pre-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<p>时间复杂度为<span class="math inline">\(O(n)\)</span>。</p>
<p>空间复杂度：用了三个指针，<span
class="math inline">\(O(1)\)</span>。</p>
<h2 id="官方做法">官方做法</h2>
<h3 id="递归">递归</h3>
<h4 id="算法思想-1">算法思想</h4>
<p>从链表头结点递归到最后一个结点，然后进行回溯，当<code>head</code>指向一个结点时，要让它的下一个结点指向它，则需要执行<code>head-&gt;next-&gt;next
= head</code>， 并让<code>head</code>结点的<code>next</code>指向空。</p>
<p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月20日21时03分26秒.gif" alt="21年04月20日21时03分26秒" style="zoom:50%;" /></p>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;<span class="keyword">return</span> head;&#125;</span><br><span class="line"></span><br><span class="line">        ListNode * newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析-1">性能分析</h4>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span>。</p>
<p>空间复杂度：每次递归都需要将当前变量压栈，为<span
class="math inline">\(O(n)\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/6-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/6-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/" class="post-title-link" itemprop="url">6-移除链表元素</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:06:39 / 修改时间：15:49:23" itemprop="dateCreated datePublished" datetime="2022-05-11T15:06:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/linkedlist/" itemprop="url" rel="index"><span itemprop="name">链表</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210417202241271.png" alt="image-20210417202241271" style="zoom:67%;" /></p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>这题很简单，考的就是链表的基本操作。</p>
<p>设置两个指针：<code>current</code>和<code>pre</code>，分别代表当前节点和当前节点的前一个节点。初始时，<code>current
= head</code>, <code>pre = nullptr</code>。</p>
<p>当<code>current</code>节点和val相等时，则<code>pre</code>节点指向<code>current-&gt;next</code>，即为删除了<code>current</code>。然后<code>current</code>指向<code>pre-&gt;next</code>，继续遍历。</p>
<p>但是需要考虑一种特殊情况，即头结点等于val，此时，令<code>head =
head-&gt;next</code>，<code>current = head</code>。继续循环。</p>
<p>遍历结束，返回<code>head</code>。</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = <span class="literal">nullptr</span>, *current = head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;val == val) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pre == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    head = head-&gt;next;</span><br><span class="line">                    current = head;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pre-&gt;next = current-&gt;next;</span><br><span class="line">                    current = pre-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<p>时间复杂度：遍历链表，为<span
class="math inline">\(O(n)\)</span>。</p>
<p>空间复杂度：使用两个指针，为<span
class="math inline">\(O(1)\)</span>。</p>
<h2 id="官方做法">官方做法</h2>
<h3 id="哨兵结点">哨兵结点</h3>
<h3 id="算法思想-1">算法思想</h3>
<p>这道题目，唯一可能稍微难一点的就是边界问题。</p>
<p>如果链表中间节点和给定val相等，问题很简单，令
该节点前一个节点的<code>next</code>等于该节点的<code>next</code>即可。</p>
<p>唯一麻烦的就是，如果开头一个或多个结点和val相等，则会稍复杂些。</p>
<p>可以使用哨兵节点来解决。</p>
<p>即：
创建一个哨兵节点<code>sentinel</code>作为头结点，并令<code>sentinel-&gt;next
=
head</code>。然后即可简化我自己的做法。不需要考虑头结点相等的特殊情况。</p>
<p>只要注意：返回值是<code>sentinel-&gt;next</code>。</p>
<h3 id="算法实现-1">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ListNode *sentinel = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        sentinel-&gt;next = head;</span><br><span class="line"></span><br><span class="line">        ListNode *pre = sentinel, *current = sentinel-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;val == val) &#123;</span><br><span class="line">                    pre-&gt;next = current-&gt;next;</span><br><span class="line">                    current = pre-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sentinel-&gt;next;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-1">性能分析</h3>
<p>时间复杂度：<span class="math inline">\(O(n)\)</span>。</p>
<p>空间复杂度：<span class="math inline">\(O(1)\)</span>。</p>
<p>不解释。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/5-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/5-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/" class="post-title-link" itemprop="url">5-多数元素</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:05:39 / 修改时间：16:00:34" itemprop="dateCreated datePublished" datetime="2022-05-11T15:05:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/array/" itemprop="url" rel="index"><span itemprop="name">数组</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210416205312401.png" alt="image-20210416205312401" style="zoom:67%;" /></p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>使用map集合，key是数组元素，value是出现的次数。遍历整个数组，对于数组每个元素，查询map集合，如果存在，则将value
+ 1，如果不存在，则添加进map集合，并设value是1。</p>
<p>然后
遍历map集合，将value的值和数组一半元素一次比较，如果符合条件，则结束循环并输出。</p>
<h3 id="代码实现">代码实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator temp;</span><br><span class="line">            <span class="keyword">if</span>((temp = count.<span class="built_in">find</span>(nums[i])) != count.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                temp-&gt;second++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count.<span class="built_in">insert</span>(&#123;nums[i], <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果数组元素个数为偶数，则直接除2，奇数则+1除2</span></span><br><span class="line">        <span class="type">int</span> half = nums.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">0</span> ? (<span class="type">int</span>)nums.<span class="built_in">size</span>() / <span class="number">2</span> : (<span class="type">int</span>)(nums.<span class="built_in">size</span>() + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator i = count.<span class="built_in">begin</span>(); i != count.<span class="built_in">end</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i-&gt;second &gt;= half) &#123;</span><br><span class="line">                result = i-&gt;first;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<p>时间复杂度：遍历整个数组，所以是<span
class="math inline">\(O(n)\)</span>，n是数组元素个数。</p>
<p>空间复杂度：需要有一个map集合来存储元素，所以是<span
class="math inline">\(O(n)\)</span>。</p>
<h2 id="官方做法">官方做法</h2>
<h3 id="哈希表">哈希表</h3>
<h3 id="算法思想-1">算法思想</h3>
<p>和我思路差不多，都使用哈希表来维护一个元素和出现次数关系的集合。在此基础上，这种做法在遍历数组时维护了一个最大值，所以在遍历完后，不需要遍历哈希表来查找多数元素。</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-1">性能分析</h3>
<p>同上。</p>
<p>时间复杂度<span class="math inline">\(O(n)\)</span>，空间复杂度<span
class="math inline">\(O(n)\)</span>。</p>
<h3 id="排序法">排序法</h3>
<h3 id="算法思想-2">算法思想</h3>
<p>首先将给定数组进行排序(从小到大，从大到小都可以)。则数组⌊<span
class="math inline">\(\frac{n}{2}\)</span>⌋位置一定是多数元素。</p>
<ul>
<li>对于数组元素个数为偶数n，则多数元素至少出现n /
2，那么不论该多数元素是最大值还是最小值，排序后，<span
class="math inline">\(\frac{n}{2}\)</span>位置一定是该元素；则如果该多数元素介于最大值和最小值，则也一定会在n/2位置。</li>
</ul>
<p>奇数同理。</p>
<h3 id="算法实现-1">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-2">性能分析</h3>
<p>时间复杂度：使用排序的默认实现，为<span
class="math inline">\(O(n*log{n})\)</span>。</p>
<p>空间复杂度：自己写排序算法，之需要使用<span
class="math inline">\(O(1)\)</span>空间，使用自带的排序算法，值传递，所以需要使用<span
class="math inline">\(O(logn)\)</span>的栈空间。</p>
<h4 id="boyer-moore投票算法">Boyer-Moore投票算法</h4>
<h3 id="算法思想-3">算法思想</h3>
<p>设置一个候选人<code>cand_num</code>，和该候选人出现的次数变量<code>count</code>。</p>
<p>候选人初始化为<code>nums[0]</code>，<code>count</code>初始化为<code>1</code>。</p>
<p>然后遍历该数组，遇到和<code>cand_num</code>相同的数，则<code>count</code>加1，否则<code>count</code>
- 1。</p>
<p>然后判断<code>count</code>是否为0，如果为0，则更换候选人为当前数；否则继续循环。</p>
<p>循环结束，当前<code>cand_num</code>即是多数元素。</p>
<p>解释：</p>
<p>因为多数元素的个数 大于 <span
class="math inline">\(\frac{n}{2}\)</span>，若7个元素，则多数元素个数大于3，若8个元素，则多数元素个数大于4。</p>
<p>因此多数元素个数 - 其他所有元素个数 一定 大于等于 1。</p>
<p>相当于每一个多数元素和数组其他元素相抵消，最后至少还剩一个多数元素。</p>
<h3 id="算法实现-2">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cand_num = nums[<span class="number">0</span>], count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == cand_num) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count == <span class="number">0</span>) &#123;</span><br><span class="line">                cand_num = nums[i];</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cand_num;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-3">性能分析</h3>
<p>时间复杂度：遍历整个数组，为<span
class="math inline">\(O(n)\)</span>。</p>
<p>空间复杂度：只使用了两个变量，为<span
class="math inline">\(O(1)\)</span>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">4-相交链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:03:39 / 修改时间：15:49:07" itemprop="dateCreated datePublished" datetime="2022-05-11T15:03:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/linkedlist/" itemprop="url" rel="index"><span itemprop="name">链表</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411160829906.png" alt="image-20210411160829906" style="zoom:67%;" /></p>
<p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411160848638.png" alt="image-20210411160848638" style="zoom:50%;" /></p>
<h2 id="自己的解法">自己的解法</h2>
<h3 id="算法思想">算法思想</h3>
<p>使用哈希表，首先遍历链表B，将每个链表地址存入set集合。然后遍历链表A，对于链表A的每个节点，在set集合中查找有没有地址相同的元素，如果有，则该节点就是第一个交点。</p>
<p>如果遍历到A链表末尾依然没有，那么这两个链表不相交。</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;ListNode *&gt; address;</span><br><span class="line">        ListNode * b = headB;</span><br><span class="line">        <span class="keyword">while</span> (b != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            address.<span class="built_in">insert</span>(b);</span><br><span class="line">            b = b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *a = headA;</span><br><span class="line">        <span class="keyword">while</span> (a != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(address.<span class="built_in">count</span>(a)) &#123;</span><br><span class="line">                <span class="keyword">return</span> a;</span><br><span class="line">            &#125;</span><br><span class="line">            a = a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="更好的解法">更好的解法</h2>
<h3 id="算法思想-1">算法思想</h3>
<p>双指针法。这种解法非常巧妙。</p>
<p>我们设链表A的节点数为a，链表B的节点数为b，它们的公共节点数为c。第一个公共节点(就是交点)为node。</p>
<p>定义两个指针pA和pB分别指向链表A和链表B，同时向后遍历，当pA遍历到A链表末尾，就重定向到链表B头结点；</p>
<p>同样的，当pB遍历到B链表结尾，就重定向到链表A头结点。</p>
<p>当指针pA遍历B链表走到node节点时，遍历的节点数是：<code>a + (b - c +
1)</code>，即走了<code>a + b - c</code>步。</p>
<p>当指针pB遍历A链表走到node节点时，遍历的节点数是：<code>b + (a - c +
1)</code>，即走了<code>b + a - c</code>步。</p>
<p>注：这里的加1，就是加上第一个公共节点。</p>
<p>因此指针pA和pB会同时到达公共节点。</p>
<ul>
<li>当c = 0时，即A、B链表没有交点，那么pA和pB最终会指向null。</li>
<li>当c &gt; 0时，pA和pB会同时指向交点。</li>
</ul>
<p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411163017410.png" alt="image-20210411163017410" style="zoom:67%;" /></p>
<p>这种方法就是用了<code>A + B = B +
A</code>的思想。虽然各自路程不同，但加起来的路程是相等的。速度一样，最终一定会同时到达。</p>
<h3 id="算法实现-1">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA;</span><br><span class="line">        ListNode *pB = headB;</span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA!= <span class="literal">nullptr</span> ? pA-&gt;next : headB;</span><br><span class="line">            pB = pB!= <span class="literal">nullptr</span> ? pB-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<ul>
<li>时间复杂度：最差情况是链表没有交点，此时时间复杂度为<span
class="math inline">\(O(a + b)\)</span></li>
<li>空间复杂度：只用了两个指针，<span
class="math inline">\(O(1)\)</span>。</li>
</ul>
<p>贴一个leetcode解法的评论(哈哈哈哈哈哈哈)：</p>
<blockquote>
<div
class="line-block">这个算法也太浪漫了吧，错的人迟早会走散，而对的人迟早会相逢。</div>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E6%A0%88/3-%E6%9C%80%E5%B0%8F%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E6%A0%88/3-%E6%9C%80%E5%B0%8F%E6%A0%88/" class="post-title-link" itemprop="url">3-最小栈</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:02:39 / 修改时间：16:03:08" itemprop="dateCreated datePublished" datetime="2022-05-11T15:02:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/stack/" itemprop="url" rel="index"><span itemprop="name">栈</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411135957987.png" alt="image-20210411135957987" style="zoom:67%;" /></p>
<p>提示：<code>pop</code>、<code>getMin</code>和<code>top</code>操作总是在非空栈进行操作。</p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>使用链表来存储元素。</p>
<p>因为要求在常数时间内检索到最小元素的栈，所以肯定不能当调用<code>getMin()</code>时在栈中遍历元素。</p>
<p>应当是在<code>push</code>和<code>pop</code>操作中就需要找到最小值，当调用<code>getMin()</code>时直接返回。</p>
<p>因此我的思路是设置一个min指针，一直指向最小值。</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">Node</span> *next;</span><br><span class="line">    &#125; node;</span><br><span class="line"></span><br><span class="line">    node *head = <span class="literal">nullptr</span>;</span><br><span class="line">    node *min = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        node * temp = <span class="keyword">new</span> <span class="built_in">node</span>();</span><br><span class="line">        temp-&gt;val = val;</span><br><span class="line">        temp-&gt;next = head;</span><br><span class="line">        head = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            min = temp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            min = min-&gt;val &lt; val ? min : temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果最小值就是栈顶元素,则需要重新找最小值</span></span><br><span class="line">        <span class="keyword">if</span>(min == head) &#123;</span><br><span class="line">            <span class="comment">//如果栈中只有一个元素或两个元素</span></span><br><span class="line">            <span class="keyword">if</span>(head-&gt;next == <span class="literal">nullptr</span> || head-&gt;next-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                min = head-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则遍历链表，查找最小值</span></span><br><span class="line">            min = head-&gt;next;</span><br><span class="line">            node *temp = min-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(min-&gt;val &gt; temp-&gt;val) &#123;</span><br><span class="line">                        min = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    temp = temp-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除栈顶元素</span></span><br><span class="line">        node * top = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min-&gt;val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<ul>
<li>时间复杂度：<code>push</code>、<code>top</code>和<code>getMin</code>都是<span
class="math inline">\(O(1)\)</span>，<code>pop</code>操作最坏时间复杂度是<span
class="math inline">\(O(n)\)</span>。</li>
<li>空间复杂度：<span class="math inline">\(O(1)\)</span>。</li>
</ul>
<h2 id="官方提供的做法">官方提供的做法</h2>
<h3 id="算法思想-1">算法思想</h3>
<p>使用辅助栈，每一个栈顶元素对应一个最小值。即在一个栈存放数据，另一个栈存放和数据栈对应位置的元素对应的最小值。</p>
<p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411151513976.png" alt="image-20210411151513976" style="zoom:50%;" /></p>
<p>当向数据栈中添加元素时，比较当前辅助栈栈顶元素和插入元素大小，取较小的添加到辅助栈。</p>
<p>从数据栈中删除栈顶元素时，同时删除辅助栈栈顶元素。</p>
<h3 id="算法实现-1">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; data_stack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; min_stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_stack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        data_stack.<span class="built_in">push</span>(val);</span><br><span class="line">        min_stack.<span class="built_in">push</span>(<span class="built_in">min</span>(val, min_stack.<span class="built_in">top</span>()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data_stack.<span class="built_in">pop</span>();</span><br><span class="line">        min_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-1">性能分析</h3>
<ul>
<li>时间复杂度：添加、删除、返回栈顶元素和返回最小值都是<span
class="math inline">\(O(1)\)</span></li>
<li>空间复杂度：<span class="math inline">\(O(N)\)</span></li>
</ul>
<h3 id="其他做法">其他做法</h3>
<p>可以使用C++的pair关键词，把要存储的元素和对应的最小值放在一个元组中。这样就只需要使用一个栈。</p>
<p>也可以不使用提供的stack默认实现，自定义链表实现，在定义节点时，添加min字段，即每一个节点都对应一个数据和最小值。</p>
<p>思路都大同小异，只不过具体实现不同。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/2-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/2-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">2-环形链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:01:39 / 修改时间：15:45:36" itemprop="dateCreated datePublished" datetime="2022-05-11T15:01:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/linkedlist/" itemprop="url" rel="index"><span itemprop="name">链表</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411123641329.png" alt="image-20210411123641329" style="zoom:67%;" /></p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>使用C++的vector数据结构存储已访问过的结点，从链表头节点开始，首先在vector中查找是否已存在该结点，存在表示已经访问过该结点，代表链表有环；不存在则把该结点放入vector中，head指向下一个结点。</p>
<p>只有两种情况：</p>
<ul>
<li>不是环形链表，则链表最后一个结点的next指向NULL</li>
<li>是环形链表，则一定会出现vector存在当前节点的情况</li>
</ul>
<p>以此来设置循环结束的时机。</p>
<p>即当前结点存在于vector中或当前结点为NULL。</p>
<h3 id="算法实现">算法实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;ListNode *&gt; addresses;</span><br><span class="line">        ListNode *current = head;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(current != <span class="literal">nullptr</span> &amp;&amp; !flag) &#123;</span><br><span class="line">            vector&lt;ListNode *&gt;::iterator result;</span><br><span class="line">            result = <span class="built_in">find</span>(addresses.<span class="built_in">begin</span>(), addresses.<span class="built_in">end</span>(), current);</span><br><span class="line">            <span class="keyword">if</span>(result != addresses.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                	breaks;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addresses.<span class="built_in">push_back</span>(current);</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<p>需要遍历整个链表，所以时间复杂度为<span
class="math inline">\(O({n})\)</span>，空间复杂度也为<span
class="math inline">\(O(n)\)</span>。</p>
<h2 id="更好的做法">更好的做法</h2>
<h3 id="哈希表">哈希表</h3>
<h4 id="算法思想-1">算法思想</h4>
<p>和我自己的做法意思不大差，但是官方提供的代码使用的数据结构更好，代码更简洁。</p>
<p>即：</p>
<p>遍历所有节点，每次遍历到一个节点，判断该结点是否被访问过。</p>
<p>使用哈希表来存储所有已经访问过的节点。</p>
<p>使用set集合。</p>
<p>即Java中set类，或C++中unordered_set类。</p>
<h4 id="算法实现-1">算法实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        unordered_set&lt;ListNode *&gt; seen;</span><br><span class="line">        </span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(seen.<span class="built_in">count</span>(head)) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                seen.<span class="built_in">insert</span>(head);</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析-1">性能分析</h4>
<p>同样，时间复杂度为<span
class="math inline">\(O({n})\)</span>，空间复杂度也为<span
class="math inline">\(O(n)\)</span>。</p>
<h3 id="快慢指针">快慢指针</h3>
<h4 id="算法思想-2">算法思想</h4>
<p>该方法需要对Floyd判圈算法(又称龟兔赛跑算法)有所了解。</p>
<p><strong>假想 乌龟 和 兔子
在链表上移动，兔子跑得快，乌龟跑得慢。那么当乌龟和兔子在链表上同一个节点开始移动时，如果链表没有环，那么兔子将一直在乌龟前方，直到乌龟到达最后一个节点；如果链表有环，那么兔子会先于乌龟进入环，并一直在环内移动。等到乌龟进入环后，由于兔子的速度快，他一定(注意，是一定会相遇)会在某个时刻和乌龟相遇。</strong></p>
<p>可以根据上述思路来解决该题。定义两个指针，一快一慢。慢指针每次只移动一步，快指针每次移动两步。初始状态，慢指针在位置<code>head</code>，快指针在位置<code>head-&gt;next</code>，这样当快指针在某一时刻追上慢指针，就说明链表为环形指针；<strong>当快指针为null或快指针的<code>next</code>为null</strong>，就说明链表不为环形链表。</p>
<p>注：</p>
<ul>
<li>为什么要判断快指针和快指针的next：因为快指针每次走两步，所以如果链表节点个数为奇数个，那么快指针走n次，会正好走到最后一个节点的后面，即null；当链表节点个数为偶数个，那么走n次，快指针正好指向最后一个节点。因此两个情况有任意一种情况出现，即出现null，则代表不是环形链表。</li>
<li>为什么初始状态慢指针在<code>head</code>位置，快指针在<code>head-&gt;next</code>位置：这是因为使用<code>while</code>循环，判断循环结束条件为<code>slow
!=
fast</code>，即快指针和慢指针不相等，若快慢指针初始都在<code>head</code>位置，那就不会进入循环。当然也可以使用do
while循环。那样，快慢指针都可以放在<code>head</code>位置。</li>
<li>其实快指针也可以一次走多步，3步，4步。都行，
但是这样会增加算法复杂度。</li>
</ul>
<h4 id="算法实现-2">算法实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode * slow = head;</span><br><span class="line">        ListNode * fast = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="性能分析-2">性能分析</h4>
<ul>
<li><p>时间复杂度：<span
class="math inline">\(O(n)\)</span>，其中n是链表节点数。</p></li>
<li><p>空间复杂度：<span
class="math inline">\(O(1)\)</span>，只使用了两个指针额外空间。</p></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/1-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/1-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/" class="post-title-link" itemprop="url">1-无重复字符的最长子串</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 15:00:39 / 修改时间：15:48:15" itemprop="dateCreated datePublished" datetime="2022-05-11T15:00:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/hashset/" itemprop="url" rel="index"><span itemprop="name">哈希表</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210328100444352.png" alt="image-20210328100444352" style="zoom:67%;" /></p>
<h2 id="自己的做法">自己的做法</h2>
<h3 id="算法思想">算法思想</h3>
<p>没有什么好的想法。最简单最容易实现的就是暴力求解。</p>
<p>分别从每个字符开始，依次查看该字符之后的字符是否和之前的重复，如果不重复，那么就存入到字符数组中，和之后的字符去比较；如果重复，那就计算出该子串长度，和最长子串长度
变量比较，取较大的一个。直到最后一个字符，</p>
<h3 id="具体做法">具体做法</h3>
<p>使用双指针，p1和p2。最开始同时同时指向字符串，缓存字符数组temp，和数组长度temp_length；先去查看数组中是否有和*p2相等的，如果有，那就算出此段长度，否则将*p2指向的字符存入缓存数组，
p2向前移动。</p>
<h3 id="c语言实现">C语言实现</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">NULL</span> || *s == <span class="string">&#x27;\0&#x27;</span>) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p1 = s;</span><br><span class="line">    <span class="type">char</span> *p2 = s;</span><br><span class="line">    <span class="type">int</span> length = (<span class="type">int</span>) <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="comment">//最大子串长度初始设为0</span></span><br><span class="line">    <span class="type">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 缓存数组，存入子串字符</span></span><br><span class="line">    <span class="type">char</span> temp[length];</span><br><span class="line">    <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="type">int</span> temp_length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当p1指向&#x27;\0&#x27;就结束循环</span></span><br><span class="line">    <span class="keyword">while</span> (*p1 != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 标志变量，temp数组是否存在p2指向的字符</span></span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; temp_length; j++) &#123;</span><br><span class="line">            <span class="comment">//遍历整个temp数组，如果有和*p2相等的，那么设flag为1</span></span><br><span class="line">            <span class="keyword">if</span>(*p2 == temp[j]) &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果flag = 1，或者*p2指向了字符串结尾，就将缓存数组长度和最大子串长度比较</span></span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span> || *p2 == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            maxLength = maxLength &lt; temp_length ? temp_length : maxLength;</span><br><span class="line">            p1++;</span><br><span class="line">            p2 = p1;</span><br><span class="line">            <span class="comment">//将数组长度置为0，即清空数组</span></span><br><span class="line">            temp_length = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果flag = 0，那么就将p2指向的字符串存入缓存，p2指向下一个字符</span></span><br><span class="line">            temp[temp_length++] = *p2;</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析">性能分析</h3>
<p>时间复杂度是<span
class="math inline">\(O(n^2)\)</span>，空间复杂度是<span
class="math inline">\(O({n})\)</span>。</p>
<h2 id="更好的解法">更好的解法</h2>
<p>涉及到子串问题的，滑动窗口使用的比较多。</p>
<h3 id="算法思想-1">算法思想</h3>
<p>当递增地枚举子串起始位置，那么子串结束位置也是递增的。</p>
<p>如果第k个字符是起始位置，第k + h 个字符是结束位置，那么当选择第k +
1个字符作为起始位置时，显然从k + 1到k + h的字符是不重复的，然后可以从 k
+ h开始继续向右比较，直到出现了重复字符。</p>
<h3 id="具体做法-1">具体做法</h3>
<ul>
<li>使用双指针，并使用一个集合来存入当前滑动窗口内的字符。</li>
<li>在循环体内，先判断集合中是否存在右指针的下一个位置(即*(p + 1)
)指向的字符，如果存在；那就结束循环，并计算此时子串长度；如果不存在，则右指针向右滑动一个位置，继续该操作</li>
<li>在上一步结束循环后，左指针应向右移动一个位置，同时从集合中删除左指针先前指向的字符，继续循环</li>
<li>直到遍历完整个字符串，循环结束</li>
</ul>
<h3 id="c实现">C++实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; chars;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> right = <span class="number">-1</span>, max_length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>) &#123;</span><br><span class="line">                chars.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; size - <span class="number">1</span> &amp;&amp; !chars.<span class="built_in">count</span>(s[right + <span class="number">1</span>])) &#123;</span><br><span class="line">                chars.<span class="built_in">insert</span>(s[right + <span class="number">1</span>]);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">            max_length = <span class="built_in">max</span>(max_length, right - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="性能分析-1">性能分析</h3>
<ul>
<li>时间复杂度：<span
class="math inline">\(O(N)\)</span>，N为字符串长度。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhaoXin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
