<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhaoquaner.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="赵圈儿的博客">
<meta property="og:url" content="https://zhaoquaner.github.io/page/16/index.html">
<meta property="og:site_name" content="赵圈儿的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZhaoXin">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhaoquaner.github.io/page/16/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/16/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>赵圈儿的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">赵圈儿的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">23</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">169</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="ZhaoXin"
      src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
  <p class="site-author-name" itemprop="name">ZhaoXin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">169</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhaoquaner" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhaoquaner" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zx1522202417@163.com" title="E-Mail → mailto:zx1522202417@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/" class="post-title-link" itemprop="url">泛型构造器、泛型方法重载</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:18:39 / 修改时间：16:53:16" itemprop="dateCreated datePublished" datetime="2022-05-11T09:18:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="泛型构造器">泛型构造器</h2>
<p>Java允许在构造器签名中声明泛型形参，这样就产生了所谓的泛型构造器。</p>
<p>一旦定义了泛型构造器，接下来在调用构造器时，就不仅可以让Java根据参数类型来推断泛型形参类型，也可以显式地为构造器中的泛型形参指定实际类型。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; Foo(T t)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericConstructor</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 泛型构造器中的T类型为String。</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		<span class="comment">// 泛型构造器中的T类型为Integer。</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="number">200</span>);</span><br><span class="line">		<span class="comment">// 显式指定泛型构造器中的T类型为String，</span></span><br><span class="line">		<span class="comment">// 传给Foo构造器的实参也是String对象，完全正确。</span></span><br><span class="line">		<span class="keyword">new</span> &lt;String&gt; Foo(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line">		<span class="comment">// 显式指定泛型构造器中的T类型为String，</span></span><br><span class="line">		<span class="comment">// 但传给Foo构造器的实参是Double对象，下面代码出错</span></span><br><span class="line">        <span class="comment">//new &lt;String&gt; Foo(12.3);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面说过的菱形语法，它允许调用构造器时在构造器后使用尖括号来代表泛型信息，但是如果程序显式指定了泛型构造器声明的泛型形参的实际类型，则不可以使用菱形语法。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; MyClass(T t)</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;t参数的值为：&quot;</span> + t);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericDiamondTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// MyClass类声明中的E形参是String类型。</span></span><br><span class="line">		<span class="comment">// 泛型构造器中声明的T形参是Integer类型</span></span><br><span class="line">		MyClass&lt;String&gt; mc1 = <span class="keyword">new</span> <span class="title class_">MyClass</span>&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">// 显式指定泛型构造器中声明的T形参是Integer类型，</span></span><br><span class="line">		MyClass&lt;String&gt; mc2 = <span class="keyword">new</span> &lt;Integer&gt; MyClass&lt;String&gt;(<span class="number">5</span>);</span><br><span class="line">		<span class="comment">// MyClass类声明中的E形参是String类型。</span></span><br><span class="line">		<span class="comment">// 如果显式指定泛型构造器中声明的T形参是Integer类型</span></span><br><span class="line">		<span class="comment">// 此时就不能使用&quot;菱形&quot;语法，下面代码是错的。</span></span><br><span class="line"><span class="comment">//		MyClass&lt;String&gt; mc3 = new &lt;Integer&gt; MyClass&lt;&gt;(5);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法与方法重载">泛型方法与方法重载</h2>
<p>因为泛型既允许设定通配符上限，也允许设定通配符下限，所以允许在一个类包含以下两个方法定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUtils</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(Collection&lt;T&gt; dest, Collection&lt;? extends T&gt; src)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">copy</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; dest, Collection&lt;T&gt; src)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法参数列表存在一定区别，但区别不明显，两个方法的两个参数都是Collection对象，前一个集合元素类型是后一个集合元素类型的父类。在这里定义这两个方法不会有任何错误，但是如果调用这个方法就会出现错误。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Number&gt; ln = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">MyUtils.copy(ln, li);</span><br></pre></td></tr></table></figure>
<p>两个方法都匹配，编译器无法确定到底调用哪个copy方法，所以会出现编译错误。</p>
<p>Java 8 改进了泛型方法的类型推断能力，主要有两个方面</p>
<ul>
<li>可以通过调用方法的上下文来推断泛型的目标类型</li>
<li>可在方法调用链中，将推断得到的泛型传递到最后一个方法</li>
</ul>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyUtil</span>&lt;E&gt;</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;Z&gt; MyUtil&lt;Z&gt; <span class="title function_">nil</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;Z&gt; MyUtil&lt;Z&gt; <span class="title function_">cons</span><span class="params">(Z head, MyUtil&lt;Z&gt; tail)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	E <span class="title function_">head</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InferenceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 可以通过方法赋值的目标参数来推断类型参数为String</span></span><br><span class="line">		MyUtil&lt;String&gt; ls = MyUtil.nil();</span><br><span class="line">		<span class="comment">// 无需使用下面语句在调用nil()方法时指定类型参数的类型</span></span><br><span class="line">		MyUtil&lt;String&gt; mu = MyUtil.&lt;String&gt;nil();</span><br><span class="line">		<span class="comment">// 可调用cons方法所需的参数类型来推断类型参数为Integer</span></span><br><span class="line">		MyUtil.cons(<span class="number">42</span>, MyUtil.nil());</span><br><span class="line">		<span class="comment">// 无需使用下面语句在调用nil()方法时指定类型参数的类型</span></span><br><span class="line">		MyUtil.cons(<span class="number">42</span>, MyUtil.&lt;Integer&gt;nil());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 希望系统能推断出调用nil()方法类型参数为String类型，</span></span><br><span class="line">		<span class="comment">// 但实际上Java 8依然推断不出来，所以下面代码报错</span></span><br><span class="line"><span class="comment">//		String s = MyUtil.nil().head();</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> MyUtil.&lt;String&gt;nil().head();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面前两行代码作用完全一样，系统会推断出泛型参数为String，后两行代码作用也完全一样，系统会推断出Z的实参为Integer。</p>
<p>但是这种推断并不是万能的，例如下面代码就是错误的</p>
<p><code>String s =
MyUtil.nil().head();</code>，希望系统可以推断出来，但是推断不出来，代码报错，需要改为<code>String
s  = Mytil.&lt;String&gt;nil().head();</code>。</p>
<h3 id="擦除和转换">擦除和转换</h3>
<p>在严格泛型代码中，带泛型声明的类应该总带着类型参数，但是为了和老的Java代码保持一致，也允许在使用带泛型声明的类时不指定实际类型，此时被称为原始类型，默认是声明该泛型形参时指定的第一个上限类型。</p>
<p>当把一个指定了泛型实参的对象赋给一个没有指定泛型实参的对象时，所有在尖括号之间的类型信息被扔掉，比如一个List<String>类型被转换为List，该List对集合元素的类型检查变成了泛型参数的上限即Object，这叫做擦除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	T size;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Apple</span><span class="params">(T size)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSize</span><span class="params">(T size)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.size = size;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getSize</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.size;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErasureTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		Apple&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">Apple</span>&lt;&gt;(<span class="number">6</span>);    <span class="comment">// ①</span></span><br><span class="line">		<span class="comment">// a的getSize方法返回Integer对象</span></span><br><span class="line">		<span class="type">Integer</span> <span class="variable">as</span> <span class="operator">=</span> a.getSize();</span><br><span class="line">		<span class="comment">// 把a对象赋给Apple变量，丢失尖括号里的类型信息</span></span><br><span class="line">		<span class="type">Apple</span> <span class="variable">b</span> <span class="operator">=</span> a;      <span class="comment">// ②</span></span><br><span class="line">		<span class="comment">// b只知道size的类型是Number</span></span><br><span class="line">		<span class="type">Number</span> <span class="variable">size1</span> <span class="operator">=</span> b.getSize();</span><br><span class="line">		<span class="comment">// 下面代码引起编译错误</span></span><br><span class="line"><span class="comment">//		Integer size2 = b.getSize();  // ③</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码定义一个带泛型形参的类Apple，上限是Number，当把a对象赋给不带泛型信息的b变量，编译器就会丢失a对象的泛型信息，因为Apple泛型形参的上限是Number，所以编译器知道b的getSize方法返回Number类型，但具体是Number的哪个子类，编译器不清楚。</p>
<p>从逻辑上看，List<String>是List的子类，如果直接把List对象赋给List<String>对象，应该会编译错误，但实际上不会，编译器仅会提示"未经检查的转换"。</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErasureTest2</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		li.add(<span class="number">6</span>);</span><br><span class="line">		li.add(<span class="number">9</span>);</span><br><span class="line">		<span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> li;</span><br><span class="line">		<span class="comment">// 下面代码引起“未经检查的转换”的警告，编译、运行时完全正常</span></span><br><span class="line">		List&lt;String&gt; ls = list;     <span class="comment">// ①</span></span><br><span class="line">		<span class="comment">// 但只要访问ls里的元素，如下面代码将引起运行时异常。</span></span><br><span class="line">		System.out.println(ls.get(<span class="number">0</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java允许把list赋给ls，但是list变量此时引用的是List<Integer>集合，所以当试图把集合元素当成String类型取出来的时候，会引发ClassCastException异常。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB/" class="post-title-link" itemprop="url">泛型接口、泛型类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:17:39 / 修改时间：16:53:18" itemprop="dateCreated datePublished" datetime="2022-05-11T09:17:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java增加泛型支持是为了让集合记住其元素的数据类型。在没有泛型之前，如果把一个对象放进集合，集合会忘记对象的数据类型，而统一当成Object类型处理，当程序从集合中取出来就需要进行强制类型转换。</p>
<p>增加了泛型后的集合，可以记住其元素的类型，并且可以在编译的时候检查集合中元素的类型。</p>
<h2 id="泛型入门">泛型入门</h2>
<p>如果定义一个只想保存String类型的List集合，使用泛型后，如果向集合添加Integer对象，则编译时会出现错误。</p>
<p>Java引入了参数化类型的概念，允许程序在创建集合时指定集合元素的类型，Java的参数化类型被称为泛型。</p>
<p>例如:<code>List&lt;String&gt; str = new
ArrayList&lt;String&gt;();</code>，就创建了一个只可以保存字符串类型的List集合。</p>
<p>我们还可以去掉后面ArrayList构造器中的指定类型，即<code>List&lt;String&gt;
str = new
ArrayList&lt;&gt;();</code>和上述例子是一样的，因为Java会推断后面尖括号里是什么类型。这种语法被称为菱形语法。</p>
<p>需要说明的是，如果使用var定义变量，那么就不能使用菱形语法。</p>
<h2 id="定义泛型接口类">定义泛型接口、类</h2>
<p>泛型，就是允许在定义类、接口和方法时使用类型形参，这个类型形参(或者叫做泛型)将在声明变量，创建对象、调用方法时动态指定(即传入实际类型参数，称为类型实参）。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="comment">//E可做为类型使用</span></span><br><span class="line">    <span class="comment">//下面方法可以使用E作为参数类型</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E x)</span>;</span><br><span class="line">    Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">    E <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义该接口时使用了两个泛型形参</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="comment">//在该接口中K,V完全可以作为类型使用</span></span><br><span class="line">    Set&lt;K&gt; <span class="title function_">keySet</span><span class="params">()</span>;</span><br><span class="line">    V <span class="title function_">put</span><span class="params">(K key, V value)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义了三个带泛型的接口，这就是泛型实质：允许在定义接口、类时声明泛型形参，泛型形参在整个接口、整个类体中可以被当成类型使用，几乎所有可使用普通类型的地方都可以使用泛型。</p>
<p><strong>注意：包含泛型声明的类型可以在定义变量、创建对象时传入类型实参，从而可以动态产生无数个逻辑子类，但这种子类在物理上并不存在。</strong></p>
<p>可以为任何类、接口定义泛型声明，并不是只有集合类才可以使用泛型，虽然集合类是泛型的重要使用场所。</p>
<p><strong>注意：当创建带泛型的自定义类时，为该类定义构造器时，构造器名还是原来类名，不要增加泛型声明，例如定义了一个Apple<T>类，构造器名仍为Apple，但是调用该构造器时要使用Apple<T>的形式。</strong></p>
<p>##　从泛型类派生子类</p>
<p>当创建带泛型声明接口、父类之后，可以为接口创建实现类，或子类继承父类，此时，接口和父类不应该包含泛型形参，而应该是为形参赋一个类型实参，或者直接写接口、父类的名字，没有后面的尖括号。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> T info;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(T info)</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.info = info;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(T info)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.info = info;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.info;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;String&gt; &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(String info)</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">super</span>(info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String info)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.setInfo(info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.getInfo();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">C</span><span class="params">(Object info)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>(info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(Object info)</span> &#123;</span><br><span class="line">                <span class="built_in">super</span>.setInfo(info);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">super</span>.getInfo();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建B、C两个类的写法都是正确的，创建B类时为泛型形参赋了String的类型实参，则子类重写父类方法所有T的地方都替换成String，创建C类时，没有传类型实参，这称为原始类型(raw
type)，Java编译器可能会发出警告，并且会被T形参全部当成Object处理。</p>
<p>而<code>class D extends A&lt;T&gt; &#123;&#125;</code>这样的写法是错误的。</p>
<p><strong>注意：并不存在泛型类，例如系统并不会为ArrayList<String>生成新的class文件，也不会把它当成新类处理，对于Java来说，他们都被当成同一个类处理，在内存中，占用一块内存空间。因此在静态方法、静态初始化块中或者静态变量的声明和初始化中不允许使用泛型形参。</strong></p>
<p>同时instanceof运算符后不允许使用泛型类。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/RandomAccessFile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/RandomAccessFile/" class="post-title-link" itemprop="url">RandomAccessFile</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:15:39 / 修改时间：16:54:13" itemprop="dateCreated datePublished" datetime="2022-05-11T09:15:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>RandomAccessFile是Java输入/输出体系功能最丰富的文件内容访问类，它既可以读取文件内容，也可以写入文件内容，与普通输入/输出类不同的是，它支持“任意访问”，即程序可以从文件的任何位置开始写入或者读取。</p>
<p>RandomAccessFile允许自由定位记录指针，如果程序需要向已经存在的文件追加内容，则需要使用RandomAccessFile类。</p>
<p>当新创建一个RandomAccessFile对象时，文件记录指针位于开头（也就是0处），RandomAccessFile包含了两个方法来操作文件记录指针：</p>
<p><strong>long getFilePointer()</strong></p>
<p>功能：得到文件记录指针目前的位置</p>
<p>参数：无</p>
<p>返回值：返回记录指针位置</p>
<hr />
<p><strong>void seek(long pos)</strong></p>
<p>功能：将文件指针定位到pos位置</p>
<p>参数：</p>
<ul>
<li>pos:想要定位的文件位置</li>
</ul>
<p>返回值：无</p>
<hr />
<p>RandomAccessFile既可以读取文件内容也可以写入文件，所有它也包含了InputStream的三个read()方法，和OutputStream的三个write()方法，用法和原来一样。</p>
<p>除此之外，RandomAccessFile还包含一系列readXxx()方法和writeXxx()方法来完成输入输出。</p>
<p>RandomAccessFile本身有两个构造器</p>
<p><strong>RandomAccessFile( File file, String
mode)</strong>和<strong>RandomAccessFile( String name, String
mode)</strong></p>
<p>前一个使用String参数来指定文件名，后一个使用File来指定文件本身。</p>
<p>还有一个mode参数，指定文件以什么形式打开，有四个值：</p>
<ul>
<li>"r" :以只读方式打开文件，如果执行写入，会出现异常</li>
<li>"rw"：以读写方式打开文件，如果文件不存在，则会创建该文件</li>
<li>"rws"：以读写方式打开文件，相对于"rw"模式，还要求对文件内容或元数据的每个更新都同步写入到底层存储设备。</li>
<li>"rwd"：以读写方式打开文件，相对于"rw"模式，还要求对文件内容的每个更新都同步写入到底层存储设备。</li>
</ul>
<p>例子：使用RandomAccessFile来访问指定的中间部分数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">hello</span>  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String  args[])</span>  <span class="keyword">throws</span> IOException</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;poem.txt&quot;</span>, <span class="string">&quot;r&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                        System.out.println(raf.getFilePointer());</span><br><span class="line"></span><br><span class="line">                        raf.seek(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="type">byte</span>[] bbuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="type">int</span> <span class="variable">hasread</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>((hasread = raf.read(bbuf)) &gt; <span class="number">0</span> )</span><br><span class="line">                        &#123;</span><br><span class="line">                                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(bbuf, <span class="number">0</span>, hasread));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：向指定文件后追加内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">hello</span>  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String  args[])</span>  <span class="keyword">throws</span> IOException</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;poem.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                        raf.seek(raf.length());</span><br><span class="line"></span><br><span class="line">                        raf.write(<span class="string">&quot;我爱唐诗！\r\n&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IOException e)</span><br><span class="line">                &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>RandomAccessFile依然不能向文件指定位置插入内容，如果直接将文件指针移动到中间某位置然后输出，新输出的内容会覆盖文件指针后面的内容，如果要插入，应该先把插入点后面的内容读入缓冲区，然后插入数据，最后把缓冲区内容追加到文件后面。</p>
<p>例子：实现了向指定文件、指定位置插入内容的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">hello</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String filename, <span class="type">long</span> pos, String insertContent)</span><span class="keyword">throws</span> IOException</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">tmp</span> <span class="operator">=</span> File.createTempFile(<span class="string">&quot;tmp&quot;</span>, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                tmp.deleteOnExit();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span>(<span class="type">RandomAccessFile</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;poem.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">                    <span class="type">FileInputStream</span> <span class="variable">tmpIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(tmp);</span><br><span class="line">                    <span class="type">FileOutputStream</span> <span class="variable">tmpOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(tmp))</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                        raf.seek(pos);</span><br><span class="line"></span><br><span class="line">                        <span class="type">byte</span>[] bbuf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="type">int</span> <span class="variable">hasread</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>((hasread = raf.read(bbuf)) &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                tmpOut.write(bbuf, <span class="number">0</span>, hasread);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        raf.seek(pos);</span><br><span class="line"></span><br><span class="line">                        raf.write(insertContent.getBytes());</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span>((hasread = tmpIn.read(bbuf)) &gt; <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                                raf.write(bbuf, <span class="number">0</span>, hasread);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String  args[])</span>  <span class="keyword">throws</span> IOException</span><br><span class="line">        &#123;</span><br><span class="line">                insert(<span class="string">&quot;poem.txt&quot;</span>, <span class="number">8</span>, <span class="string">&quot;插入的内容\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/NIO.2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/NIO.2/" class="post-title-link" itemprop="url">NIO.2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:14:39 / 修改时间：16:54:11" itemprop="dateCreated datePublished" datetime="2022-05-11T09:14:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java 7对原有NIO进行重大改进，主要包含两方面内容</p>
<ul>
<li>提供了全面的文件IO和文件系统访问支持</li>
<li>基于异步Channel的第二个改进</li>
</ul>
<h2 id="pathpaths和files核心api">Path、Paths和Files核心API</h2>
<p>NIO.2引入了一个Path接口，Path接口代表一个平台无关的平台路径，除此，NIO.2还提供了Files、Paths两个工具类，其中Files包含大量静态方法来操作文件，Paths提供了两个方法返回Path。</p>
<p>Path接口的常用方法</p>
<p><strong>Path getFileName()</strong></p>
<p>功能：返回此路径表示的文件或者目录名称作为Path对象返回，文件名是离根目录最远的元素</p>
<p>参数：无</p>
<p>返回值：Path对象</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/a/b/c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/a/b/c/1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">pathName1</span> <span class="operator">=</span> path.getFileName();</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">pathName2</span> <span class="operator">=</span> path1.getFileName();</span><br><span class="line"></span><br><span class="line">System.out.println(pathName1 + <span class="string">&quot;    &quot;</span> + pathName2);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure>
<img
src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421110250155.png"
alt="image-20200421110250155" />
<figcaption aria-hidden="true">image-20200421110250155</figcaption>
</figure>
<hr />
<p><strong>Path getName(int index)</strong></p>
<p>功能：以Path对象的形式返回此路径的名称元素</p>
<p>参数：</p>
<ul>
<li>index：以离根目录最近的元素名称为第一个，索引为0，以此类推</li>
</ul>
<p>返回值：以Path对象返回的对应元素名称</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/a/b/c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/a/b/c/1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(path.getName(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(path1.getName(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure>
<img
src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421110557201.png"
alt="image-20200421110557201" />
<figcaption aria-hidden="true">image-20200421110557201</figcaption>
</figure>
<hr />
<p><strong>int getNameCount()</strong></p>
<p>功能：返回路径中的名称元素数</p>
<p>参数：无</p>
<p>返回值：名称元素数，除去根目录</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(&quot;D:/a/b/c&quot;);</span><br><span class="line"></span><br><span class="line">Path path1 = Paths.get(&quot;D:/a/b/c/1.txt&quot;);</span><br><span class="line"></span><br><span class="line">System.out.println(path.getNameCount());</span><br><span class="line"></span><br><span class="line">System.out.println(path1.getNameCount());</span><br></pre></td></tr></table></figure>
<p>输出</p>
<p><img src="C:\Users\Bu'l'l'shi't\AppData\Roaming\Typora\typora-user-images\image-20200421110747591.png" alt="image-20200421110747591" style="zoom:150%;" /></p>
<hr />
<p><strong>Path getParent()</strong></p>
<p>功能：获得次路径的父路径</p>
<p>参数：无</p>
<p>返回值：以Path对象形式返回父路径，如果没有父路径，返回null</p>
<p><strong>注意：</strong>如果是以绝对路径创建Path对象，返回的也是绝对路径，相对路径一样。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/a/b/c&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/a/b/c/1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(path.getParent());</span><br><span class="line"></span><br><span class="line">System.out.println(path1.getParent());</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure>
<img
src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421111101001.png"
alt="image-20200421111101001" />
<figcaption aria-hidden="true">image-20200421111101001</figcaption>
</figure>
<hr />
<p><strong>Path getRoot()</strong></p>
<p>功能：获得此路径的根路径</p>
<p>参数：无</p>
<p>返回值：此路径的根路径作为Path对象返回，若没有则返回null</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/a/b/c&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:/a/b/c/1.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">path2</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(path.getRoot());</span><br><span class="line">System.out.println(path1.getRoot());</span><br><span class="line">System.out.println(path2.getRoot());</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure>
<img
src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421111320483.png"
alt="image-20200421111320483" />
<figcaption aria-hidden="true">image-20200421111320483</figcaption>
</figure>
<hr />
<p><strong>boolean isAbsolute()</strong></p>
<p>功能：判断次路径是否为绝对路径</p>
<p>参数：无</p>
<p>返回值：若是绝对路径返回true，否则false</p>
<hr />
<p><strong>Path toAbsolutePath()</strong></p>
<p>功能：获得此路径的绝对路径的Path对象</p>
<p>参数：无</p>
<p>返回值：绝对路径的Path对象</p>
<p><strong>注意：</strong>如果此路径已经是绝对路径，则此方法就返回此路径</p>
<hr />
<p>Files工具类同样提供了一系列操作文件的方法，包括创建目录，文件，删除目录文件，复制文件，输入输出文件等等</p>
<p>鉴于方法太多，就不写这了，</p>
<p>链接———&gt;<a
target="_blank" rel="noopener" href="https://www.apiref.com/java11-zh/java.base/java/nio/file/Files.html#copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...)">Files工具类</a></p>
<h2
id="使用filevisitor遍历文件和目录">使用FileVisitor遍历文件和目录</h2>
<p>Files工具类提供了两个方法来遍历文件和子目录</p>
<p><strong>Path walkFileTree(Path start, FileVisitor&lt;? super Path&gt;
visitor)</strong></p>
<p>功能：遍历start路径下的所有文件和子目录</p>
<p>参数：</p>
<ul>
<li>start：需要遍历的根目录</li>
<li>visitor：文件访问器</li>
</ul>
<p>返回值：返回起始文件，即start路径对应Path对象</p>
<hr />
<p><strong>Path walkFileTree(Path start, Set<FileVisitOption> options,
int maxDepth, FileVisitor&lt;? super Path&gt; visitor)</strong></p>
<p>功能：遍历start路径下所有文件和子目录</p>
<p>参数：</p>
<ul>
<li>start：需要遍历的起始目录</li>
<li>options：遍历选项</li>
<li>maxDepth：遍历深度</li>
<li>visitor：文件访问器</li>
</ul>
<p>返回值：返回起始文件，即start路径对应Path对象</p>
<hr />
<p>其中两个方法中都有FileVisitor&lt;? super
Path&gt;，文件访问器，在遍历文件和子目录时都会触发FileVisitor中相应的方法</p>
<p>FileVisitor定义了四个方法</p>
<ul>
<li>FileVisitResult postVisitDirectory(T dir, IOException
exc)：访问子目录<strong>之后</strong>触发该方法</li>
<li>FileVisitResult preVisitDirectory(T dir, BasicFileAttributes
attrs)：访问子目录<strong>之前</strong>触发该方法</li>
<li>FileVisitResult visitFile(T file, BasicFileAttributes
attrs)：访问file文件时触发该方法</li>
<li>FileVisitResult preVisitDirectory(T file, IOException
exc)：访问file文件失败后触发该方法</li>
</ul>
<p>上面四个方法都返回一个FileVisitResult对象，它是一个枚举类，代表了访问之后的后续行为</p>
<ul>
<li>CONTINUE：继续访问</li>
<li>SKIP_SIBLINGS：继续访问，但不访问该文件或目录的兄弟文件或者目录</li>
<li>SKIP_SUBTREE：继续访问，但不访问该文件或目录的子目录树</li>
<li>TERMINATE：终止访问</li>
</ul>
<p>其中第二个方法中，有一个Set<FileVisitOption>
options参数，用来定义文件树遍历选项，它是一个枚举类，只有一个常量：FOLLOW_LINKS，跟随符号链接。</p>
<p>符号链接：在windows上就是快捷方式，包含一条以绝对路径或相对路径的形式指向其他文件或者目录，对符号链接文件进行读写会表现为直接对目标文件进行操作，但是如果删除一个符号链接，它指向的目标文件不受影响。</p>
<p>还有一个参数maxDepth，就是遍历的深度</p>
<p>这两个方法以深度优先遍历文件，故设置了遍历深度，程序遍历到指定深度就会回退</p>
<p>实际编程中不需要为FileVisitor的四个方法都提供实现，可以通过继承SimpleFileVisitor(FileVisitor的实现类)来实现自己的文件访问器，这样就可以根据需要、选择性重写指定方法。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历D盘a目录下的所有文件和子目录</span></span><br><span class="line">            <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Path.of(<span class="string">&quot;D:/a&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">Path</span> <span class="variable">path1</span> <span class="operator">=</span> Files.walkFileTree(path,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//访问子目录之前触发该方法</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;正在访问&quot;</span> + dir + <span class="string">&quot;路径&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//访问文件之前触发该方法</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">                            System.out.println(<span class="string">&quot;正在访问&quot;</span>  + file + <span class="string">&quot;文件&quot;</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure>
<img
src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421121054150.png"
alt="image-20200421121054150" />
<figcaption aria-hidden="true">image-20200421121054150</figcaption>
</figure>
<h2 id="使用watchservice监控文件变化">使用WatchService监控文件变化</h2>
<p>以前Java版本中，如果程序需要监听文件变化，可以考虑启动一条后台线程，这条线程每隔一段时间去”遍历“一次指定目录的文件，如果发现遍历结果与上次结果不同，就会认为文件发生变化，但这种方式很烦碎，性能也不好。</p>
<p>NIO.2提供了一个方法来监听文件系统的变化</p>
<p>register(WatchService watcher, WatchEvent&lt;?&gt; ...
events):用watcher监听该path代表的目录下的文件变化，</p>
<p>events指定要监听哪些类型的事件。</p>
<p>在这个方法中，WatchService代表一个文件系统监听服务，它负责监听path代表的目录下的文件变化，一旦使用register方法完成注册后，就可以调用WatchService的三个方法来获取被监听的目录的文件变化事件</p>
<ul>
<li>WatchKey
poll()：获取WatchKey，如果没有WatchKey发生就立即返回null</li>
<li>WatchKey poll(long timeout, TimeUnit
unit)：尝试等待timeout时间就获取下一个WatchKey</li>
<li>WatchKey
take()：获取下一个WatchKey，如果没有WatchKey发生就一直等待</li>
</ul>
<p>如果程序需要一直监控。则应该选择使用take()方法</p>
<p>例子：示范使用WatchService监控D盘a目录下文件的变化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WatchServiceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 获取文件系统的WatchService对象</span></span><br><span class="line">		<span class="type">WatchService</span> <span class="variable">watchService</span> <span class="operator">=</span> FileSystems.getDefault()</span><br><span class="line">			.newWatchService();</span><br><span class="line">		<span class="comment">// 为C:盘根路径注册监听</span></span><br><span class="line">		Paths.get(<span class="string">&quot;C:/&quot;</span>).register(watchService,</span><br><span class="line">			StandardWatchEventKinds.ENTRY_CREATE,</span><br><span class="line">			StandardWatchEventKinds.ENTRY_MODIFY,</span><br><span class="line">			StandardWatchEventKinds.ENTRY_DELETE);</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 获取下一个文件改动事件</span></span><br><span class="line">			<span class="type">WatchKey</span> <span class="variable">key</span> <span class="operator">=</span> watchService.take();    <span class="comment">// ①</span></span><br><span class="line">			<span class="keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents())</span><br><span class="line">			&#123;</span><br><span class="line">				System.out.println(event.context() +<span class="string">&quot; 文件发生了 &quot;</span></span><br><span class="line">					+ event.kind()+ <span class="string">&quot;事件！&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 重设WatchKey</span></span><br><span class="line">			<span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> key.reset();</span><br><span class="line">			<span class="comment">// 如果重设失败，退出监听</span></span><br><span class="line">			<span class="keyword">if</span> (!valid)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure>
<img
src="D:\各种文档\个人文档\学习总结\Java\输入输出\image\image-20200421133721588.png"
alt="image-20200421133721588" />
<figcaption aria-hidden="true">image-20200421133721588</figcaption>
</figure>
<h2 id="访问文件属性">访问文件属性</h2>
<p>Java
7的NIO.2提供了大量工具类来简单读取修改文件属性，这些工具类分为两大类</p>
<ul>
<li>XxxAttributeView：代表某种文件属性的视图</li>
<li>XxxAttributes:代表某种文件属性的"集合"</li>
</ul>
<p>程序一般通过XxxAttributeView对象来获取XxxAttributes</p>
<p>在这些工具类中，FileAttributeView其他XxxAttributeView的父接口，有以下几个XxxAttributeView</p>
<ul>
<li>AclFileAttributeView：通过AclFileAttributeView，开发者可以为特定文件设置ACL(Access
Control
List)及文件所有者属性，它的getAcl()方法返回List<AclEntry>对象，该返回值代表了该文件的权限集，通过setAcl(List)方法可以修改该文件的ACL.</li>
<li>BasicFileAttributeView：它可以获取或修改文件的基本属性，包括文件最后修改时间，最后访问时间，创建时间，大小等等，他的readArrtibutes()方法返回一个BasicFileAttributes对象，对文件夹基本属性的修改是通过BasicFileAttributes对象完成的</li>
<li>DosFileAttributeView：它主要获取或修改文件的DOS相关属性，比如文件是否可读，是否隐藏，是否为系统文件，是否为存档文件等，他的readAttributes()方法获取一个DosFileAttributes对象，对这些属性的修改其实是由DosFileAttributes对象来完成的</li>
<li>FileOwnerAttributeView：它主要用于获取或修改文件的所有者，他的getOwner()方法返回一个UsePrincipal对象来代表文件所有者，也可以调用setOwner(UsePrincipal
owner)方法来改变文件所有者</li>
<li>PosixFileAttributeView：它主要用于获取或修改POSIX(Porable Operating
System InterFace of
INIX)属性，它的readArrtibutes()方法返回一个PosixFileAttributes对象，该对象可用于获取或修改文件的所有者，组所有者，访问权限信息，这个View只在UNIX,Linux系统上有用</li>
<li>UserDefinedFileAttributeView：它可以让开发者为文件设置一些自定义属性</li>
</ul>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.BasicFileAttributes;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.attribute.FileOwnerAttributeView;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">Path</span> <span class="variable">testpath</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;D:\\a\\b\\c\\1.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">BasicFileAttributeView</span> <span class="variable">basicView</span> <span class="operator">=</span> Files.getFileAttributeView(testpath, BasicFileAttributeView.class);</span><br><span class="line"></span><br><span class="line">            <span class="type">BasicFileAttributes</span> <span class="variable">basicAttributes</span> <span class="operator">=</span> basicView.readAttributes();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;创建时间为&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(basicAttributes.creationTime().toMillis()));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;最后访问时间为&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(basicAttributes.lastAccessTime().toMillis()));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;最后修改时间为&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>(basicAttributes.lastModifiedTime().toMillis()));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;文件大小为&quot;</span> + basicAttributes.size() + <span class="string">&quot;个字节&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">FileOwnerAttributeView</span> <span class="variable">ownerView</span> <span class="operator">=</span> Files.getFileAttributeView(testpath, FileOwnerAttributeView.class);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;该文件所属用户&quot;</span> + ownerView.getOwner());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure>
<img
src="D:\各种文档\个人文档\学习总结\Java\输入输出\image\image-20200421140431872.png"
alt="image-20200421140431872" />
<figcaption aria-hidden="true">image-20200421140431872</figcaption>
</figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/NIO/" class="post-title-link" itemprop="url">NIO</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:13:39 / 修改时间：16:54:08" itemprop="dateCreated datePublished" datetime="2022-05-11T09:13:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>当时用BufferReader读取输入流数据时，如果没有读到有效数据，那么程序会在此处阻塞该线程的执行(使用InputStream的read方法读取输入流数据时，如果数据源没有数据，也会阻塞)，也就是说前面说的输入流输出流都是阻塞式的输入输出，不仅如此，传统的输入流输出流都是通过字节的移动来处理的，既然不直接处理字节流，底层也还是使用字节处理，也就是说，面向流的输入/输出系统一次只能处理一个字符，因此通常效率不高。</p>
<p>从jdk1.4，Java提供了一系列改进的输入输出新功能，这些功能被统称为新IO，新增了许多用于处理输入输出的类，这些类都放在java.nio包及其子包下。</p>
<h2 id="java新io概述">Java新IO概述</h2>
<p>新IO和传统IO目的相同，用于输入/输出，但是新IO使用了不同的方式来处理输入输出。新IO采用内存映射文件的方式来处理输入输出，新IO将文件或者文件部分映射到内存中，这样就可以像访问内存一样来访问文件(这种方式模拟了操作系统的虚拟内存概念)，通过这种方式，进行输入输出要快得多。</p>
<p>Java中与新IO相关的包如下。</p>
<ul>
<li>java.nio：主要包含各种与Buffer相关的类</li>
<li>java.nio.channels：主要包含与Channels和Selector相关的类</li>
<li>java.nio.charset：主要包含与字符集相关的类</li>
<li>java.nio.channels.spi：主要包含与Channels相关的服务提供者编程接口</li>
<li>java.nio.charset.spi：包含与字符集相关的服务提供者编程接口</li>
</ul>
<p>Channel(通道)和Buffer(缓冲)是新IO的两个核心对象，Channel是对传统输入输出系统的模拟，在新IO系统中所有数据都需要通过通道传输；Channel与传统的InputStream和OutputStream最大的区别在于它提供了一个map()方法，通过这个方法可以将”一块数据“映射到内存中。</p>
<p>如果说传统输入输出是面向流的处理，那么新IO就是面向块的处理。</p>
<p>Buffer可以被理解成容器，它本质是数组，发送到Channel中的所有对象都必须放在Buffer中，而从Channel读取的数据也必须先放到Buffer。</p>
<p>除了Channel和Buffer之外，新IO还提供了用于将Unicode字符串应设成字节序列以及逆映射的操作的Charset类,也提供了用于支持非阻塞式输入输出的Selector类。</p>
<p>##　使用Buffer</p>
<p>从内部结构看，Buffer就像一个数组，可以保存多个类型相同的数据，Buffer是一个抽象类，最常用的子类是ByteBuffer，他可以在底层字节数组进行get/set操作，除了ByteBuffer外，对应其他基本数据类型(boolean除外)都有对应Buffer类:CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer和DoubleBuffer。</p>
<p>上面这些Buffer类，除了ByteBuffer类外，他们都采用相同或者相似的方法管理数据，这些Buffer类都没有提供构造器，通过如下一个方法来得到XxxBuffer对象</p>
<p>`<strong>static XxxBuffer allocate(int
capacity)</strong>来创建一个容量为capacity的XxxBuffer对象。</p>
<p>实际使用较多的是ByteBuffer和CharBuffer类，其他Buffer子类较少用到，其中ByteBuffer类还有一个子类：MappedByteBuffer，它用于表示Channel将磁盘文件部分或者全部内容映射到内存中得到的结果，通常MappedByteBuffer对象由Channel得map方法返回。</p>
<p>在Buffer中有三个重要概念：</p>
<ul>
<li>容量(capacity)：缓冲区的容量，表示该Buffer的最大数据容量，不可以为负值，创建后不能更改</li>
<li>界限(limit)：第一不应该被读出或者写入的缓冲区位置索引，即位于limit后的数据既不可以被读，也不可被写</li>
<li>位置(position)：用于指明下一个可以被读出或者写入的缓冲区位置索引(类似于IO流的记录指针)，当时用Buffer从Channel读取数据时，position的值恰好等于已经读到了多少数据。初始化后，position的值为0。</li>
</ul>
<p>除此之外，Buffer还支持一个可选的标记mark，Buffer允许直接将position定位到该mark处。</p>
<p>这些值的关系为</p>
<p><strong>0≤mark≤position≤limit≤capacity</strong></p>
<figure>
<img
src="D:\各种文档\个人文档\学习总结\Java\输入输出\image\image-20200420150359162.png"
alt="image-20200420150359162" />
<figcaption aria-hidden="true">image-20200420150359162</figcaption>
</figure>
<p>如图可看出这些值的关系。</p>
<p>Buffer的主要作用就是装入数据，然后输出数据，开始时，<strong>position为0，limit为capacity</strong>，程序通过put方法像Buffer中放入数据，</p>
<p>Buffer中一些常用的方法：</p>
<p><strong>XxxBuffer flip()</strong></p>
<p>功能：将limit设置为position所在位置，然后设position为0</p>
<p>参数：无</p>
<p>返回值：调用该方法的Buffer对象</p>
<p><strong>注：</strong></p>
<p>该方法使得Buffer的读写指针移到开始位置，即调用flip方法后，Buffer为输出数据做好准备</p>
<hr />
<p><strong>XxxBuffer clear()</strong></p>
<p>功能：将limit设为capacity，然后设position为0</p>
<p>参数：无</p>
<p>返回值：调用该方法的Buffer对象</p>
<p><strong>注：</strong></p>
<ul>
<li>该方法使得Buffer的读写指针移到开始位置，即调用clear方法后，Buffer为读取数据做好准备</li>
<li><strong>该方法不会清除Buffer中的内容，只会改变limit和position的值</strong></li>
</ul>
<hr />
<p><strong>int capacity()</strong></p>
<p>功能：获得Buffer的capacity大小</p>
<p>参数：无</p>
<p>返回值：Buffer的capacity</p>
<hr />
<p><strong>boolean hasRemaining()</strong></p>
<p>功能：判断当前位置(position)和界限(limit)之间是否还有元素可供处理</p>
<p>参数：无</p>
<p>返回值：</p>
<p>有元素需要处理，返回true，无返回false</p>
<hr />
<p><strong>int limit()</strong></p>
<p>功能：返回Buffer界限的位置</p>
<p>参数：无</p>
<p>返回值：Buffer的limit</p>
<hr />
<p><strong>Buffer limit(int newPs)</strong></p>
<p>功能：重新设置limit的位置</p>
<p>参数：</p>
<ul>
<li>newPs:新limit的位置</li>
</ul>
<p>返回值：此Buffer对象</p>
<hr />
<p><strong>Buffer mark()</strong></p>
<p>功能：在当前Buffer的position设置一个mark</p>
<p>参数：无</p>
<p>返回值：当前Buffer对象</p>
<p><strong>注意</strong></p>
<ul>
<li>mark只能在0到position之间</li>
<li>设置了mark，只是在position位置做一个标记，需要调用reset方法将position转到mark位置</li>
</ul>
<hr />
<p><strong>int position()</strong></p>
<p>功能：获得Buffer的position值</p>
<p>参数：无</p>
<p>返回值：Buffer的position</p>
<hr />
<p><strong>Buffer position(int newPs)</strong></p>
<p>功能:设置Buffer的position</p>
<p>参数：</p>
<ul>
<li>newPs：需要设置的newPs位置</li>
</ul>
<p>返回值：返回修改了position的Buffer对象</p>
<hr />
<p><strong>int remaining()</strong></p>
<p>功能：返回当前位置和界限之间的元素个数。</p>
<p>参数：无</p>
<p>返回值：返回元素个数</p>
<hr />
<p><strong>Buffer reset()</strong></p>
<p>功能：将position转到mark所在位置</p>
<p>参数：无</p>
<p>返回值：此Buffer对象</p>
<hr />
<p><strong>Buffer rewind()</strong></p>
<p>功能：将位置设为0，取消设置的mark</p>
<p>参数：无</p>
<p>返回值：此Buffer对象</p>
<hr />
<p>除了这些方法外，Buffer的所有子类还提供了两个重要方法，put()和get()，用于向Buffer中放入数据和从Buffer中取出数据，当时用这两个方式时，Buffer即支持对单个数据的访问，也支持对批量数据的访问(以数组作为参数)。</p>
<p>使用put()和get()来访问Buffer中的数据时，分为相对和绝对两种</p>
<ul>
<li>相对：从position开始读取或写入数据，然后位置position按元素个数增加</li>
<li>直接根据索引向Buffer中读取或写入数据，position不受影响，值不改变</li>
</ul>
<p>tong</p>
<p>下面是Buffer的常规操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">CharBuffer</span> <span class="variable">buff</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;capacity : &quot;</span> + buff.capacity());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;limit : &quot;</span> + buff.limit());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;position : &quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">                buff.put(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                buff.put(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                buff.put(<span class="string">&#x27;c&#x27;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;加入三个元素后的position：&quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">                buff.flip();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;执行完flip方法后 limit = &quot;</span> + buff.limit() + <span class="string">&quot;  position = &quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;取出第一个元素: &quot;</span> + buff.get());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;取出第一个元素后，position位置为&quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">                buff.clear();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;执行完clear方法后 limit = &quot;</span> + buff.limit() + <span class="string">&quot;   position = &quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;执行clear后，缓冲区内容并没有被清除，取出第三个元素:&quot;</span> + buff.get(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;执行绝对读取后，position = &quot;</span> + buff.position());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure>
<img
src="D:\各种文档\个人文档\学习总结\Java\输入输出\image\image-20200420153133317.png"
alt="image-20200420153133317" />
<figcaption aria-hidden="true">image-20200420153133317</figcaption>
</figure>
<p>通过allocate()方法创建的Buffer对象是普通的Buffer，ByteBuffer还提供了一个allocateDirect方法来创建直接Buffer，直接Buffer的创建成本比普通Buffer的创建成本高，但直接Buffer的读取效率更高。</p>
<p><strong>提示</strong></p>
<p>由于直接Buffer创建成本很高，所以直接Buffer只适用于生存期长的Buffer，而不适用与短生存期、一次用完就丢弃的Buffer。</p>
<p>而且只有ByteBuffer提供了allocateDirect()方法，所以只能在ByteBuffer级别上创建直接Buffer，如果希望使用其他类型，则应该将该Buffer转为其他类型的Buffer。</p>
<p>直接Buffer和普通Buffer用法基本相同。</p>
<h2 id="使用channel">使用Channel</h2>
<p>Channel类似于传统的流对象，但与传统流对象有两个主要区别：</p>
<ul>
<li>Channel可以直接将指定文件的部分或者全部映射成Buffer</li>
<li>程序不能直接访问Channel中的数据，读取、写入都不可以，必须写通过Buffer，如果要写入Channel，必须先写入Buffer，通过Buffer写入Channel，读取也是一样</li>
</ul>
<p>Java为Channel接口提供了DatagramChannel、FileChannel、Pipe.SinkChannel、Pipe.SourceChannel、SelectableChannel、ServerSocketChannel和SocketChannel等实现类，这里主要介绍FileChannel的用法。新IO的Channel是按功能来分类的，Pipe.SinkChannel、Pipe.SourceChannel是用于支持线程通信的管道Channel，ServerSocketChannel和SocketChannel是用于网络通信的管道Channel。</p>
<p>注意，所有的Channel都不应该通过构造器来创建，而是通过传统节点InputStream，OutputStream的getChannel()方法来返回对应Channel，不同节点流返回的Channel类型不同。FileInputStream和FileutputStream返回的Channel是FileChannel，PipedInputStream和PipedOutputStream返回的Channel是PipeChannel。</p>
<p>Channel最常用的三类方法是map(),read(),write()，其中map()方法用于将Channel对应的部分或者全部数据映射成ByteBuffer，而read()和write()都有一系列重载形式。</p>
<p>map()的方法签名为 <strong>MappedByteBuffer map(FileChannel.MapMode
mode, long position, long size)</strong></p>
<p>第一个参数是执行映射时的模式，有三个取值</p>
<ul>
<li>FileChannel.MapMode.PRIVATE：私有模式(写时复制)</li>
<li>FileChannel.MapMode.READ_ONLY:只读模式</li>
<li>FileChannel.MapMode.READ_WRITE：读写模式</li>
</ul>
<p>第二个参数决定映射数据的起始位置，第三个是数据的长度</p>
<p>例子：直接将FileChannel的全部数据映射成ByteBuffer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileChannelTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;FileChannelTest.java&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建FileInputStream，以该文件输入流创建FileChannel</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">inChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f).getChannel();</span><br><span class="line">			<span class="comment">// 以文件输出流创建FileBuffer，用以控制输出</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">outChannel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;a.txt&quot;</span>).getChannel())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将FileChannel里的全部数据映射成ByteBuffer</span></span><br><span class="line">			<span class="type">MappedByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> inChannel.map(FileChannel</span><br><span class="line">				.MapMode.READ_ONLY, <span class="number">0</span>, f.length());   <span class="comment">// ①</span></span><br><span class="line">			<span class="comment">// 使用GBK的字符集来创建解码器</span></span><br><span class="line">			<span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">			<span class="comment">// 直接将buffer里的数据全部输出</span></span><br><span class="line">			outChannel.write(buffer);     <span class="comment">// ②</span></span><br><span class="line">			<span class="comment">// 再次调用buffer的clear()方法，复原limit、position的位置</span></span><br><span class="line">			buffer.clear();</span><br><span class="line">			<span class="comment">// 创建解码器(CharsetDecoder)对象</span></span><br><span class="line">			<span class="type">CharsetDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> charset.newDecoder();</span><br><span class="line">			<span class="comment">// 使用解码器将ByteBuffer转换成CharBuffer</span></span><br><span class="line">			<span class="type">CharBuffer</span> <span class="variable">charBuffer</span> <span class="operator">=</span> decoder.decode(buffer);</span><br><span class="line">			<span class="comment">// CharBuffer的toString方法可以获取对应的字符串</span></span><br><span class="line">			System.out.println(charBuffer);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>虽然FileChannel可以读取也可以写入，但是FileInputStream创建的FileChannel只能读，FileOutputStream创建的FileChannel只能写。</p>
<p>RandAccessFile中也包含了一个getChannel()方法，RandAccessFile打开文件的模式决定返回的FileChannel是只读的还是读写的。</p>
<p>例子：对a.txt的文件内容进行复制，并追加在文件后面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomFileChannelTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建一个RandomAccessFile对象</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">raf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(f, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">			<span class="comment">// 获取RandomAccessFile对应的Channel</span></span><br><span class="line">			<span class="type">FileChannel</span> <span class="variable">randomChannel</span> <span class="operator">=</span> raf.getChannel())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将Channel中所有数据映射成ByteBuffer</span></span><br><span class="line">			<span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> randomChannel.map(FileChannel</span><br><span class="line">				.MapMode.READ_ONLY, <span class="number">0</span>, f.length());</span><br><span class="line">			<span class="comment">// 把Channel的记录指针移动到最后</span></span><br><span class="line">			randomChannel.position(f.length());</span><br><span class="line">			<span class="comment">// 将buffer中所有数据输出</span></span><br><span class="line">			randomChannel.write(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序也可以使用Channel和Buffer传统的”用竹筒多次重复取水“的方式，代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadFile</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建文件输入流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;ReadFile.java&quot;</span>);</span><br><span class="line">			<span class="comment">// 创建一个FileChannel</span></span><br><span class="line">			<span class="type">FileChannel</span> <span class="variable">fcin</span> <span class="operator">=</span> fis.getChannel())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 定义一个ByteBuffer对象，用于重复取水</span></span><br><span class="line">			<span class="type">ByteBuffer</span> <span class="variable">bbuff</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">256</span>);</span><br><span class="line">			<span class="comment">// 将FileChannel中数据放入ByteBuffer中</span></span><br><span class="line">			<span class="keyword">while</span> (fcin.read(bbuff) != -<span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 锁定Buffer的空白区</span></span><br><span class="line">				bbuff.flip();</span><br><span class="line">				<span class="comment">// 创建Charset对象</span></span><br><span class="line">				<span class="type">Charset</span> <span class="variable">charset</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">				<span class="comment">// 创建解码器(CharsetDecoder)对象</span></span><br><span class="line">				<span class="type">CharsetDecoder</span> <span class="variable">decoder</span> <span class="operator">=</span> charset.newDecoder();</span><br><span class="line">				<span class="comment">// 将ByteBuffer的内容转码</span></span><br><span class="line">				<span class="type">CharBuffer</span> <span class="variable">cbuff</span> <span class="operator">=</span> decoder.decode(bbuff);</span><br><span class="line">				System.out.print(cbuff);</span><br><span class="line">				<span class="comment">// 将Buffer初始化，为下一次读取数据做准备</span></span><br><span class="line">				bbuff.clear();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符集和charset">字符集和Charset</h2>
<p>计算机中的文件、数据、图片等等是一种表面现象，在计算机内部它们都是以二进制序列存储的，对于文本文件，我们之所以可以看到一个个的字符，是因为系统将二进制序列转换为了字符。这个过程有两个概念：编码(Encode)和解码(Decode)。通常，把明文的字符序列转换成计算机理解的二进制序列称为编码，把二进制序列转换成普通人看得懂的明文字符串为解码。</p>
<p>Java默认使用Unicode字符集，但很多操作系统并不是用Unicode字符集，那么当从系统中读取数据到Java程序中时，就可能出现乱码问题。</p>
<p>Java提供了Charset来处理字节序列和字符序列的转换关系，该类包含了创建解码器和编码器的方法，还提供了获取Charset所支持的字符集的方法，Charset类是不可变类。</p>
<p>常用的字符集：</p>
<ul>
<li>GBK：windows操作系统默认字符集，简体中文字符集</li>
<li>BIG5：繁体中文字符集</li>
<li>UTF-8：linux系统默认字符集，8位UCS转换格式</li>
</ul>
<p>可以通过Chatrset的forName()方法创建对应的Charset对象，参数就是字符集的别名</p>
<p>如<code>Charset cs = Charset.forName("GBK");</code></p>
<p>获得了Charset对象后，就可以通过该对象的newDecoder()和newEncoder()方法来获得CharsetDecoder和CharsetEncoder对象，分别是该Charset对象的解码器和编码器。这两个对象分别有decode()和encode()方法来对字节序列和字符序列解码和编码。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.*;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharsetTransform</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">		<span class="keyword">throws</span> Exception</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 创建简体中文对应的Charset</span></span><br><span class="line">		<span class="type">Charset</span> <span class="variable">cn</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取cn对象对应的编码器和解码器</span></span><br><span class="line">		<span class="type">CharsetEncoder</span> <span class="variable">cnEncoder</span> <span class="operator">=</span> cn.newEncoder();</span><br><span class="line">		<span class="type">CharsetDecoder</span> <span class="variable">cnDecoder</span> <span class="operator">=</span> cn.newDecoder();</span><br><span class="line">		<span class="comment">// 创建一个CharBuffer对象</span></span><br><span class="line">		<span class="type">CharBuffer</span> <span class="variable">cbuff</span> <span class="operator">=</span> CharBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">		cbuff.put(<span class="string">&#x27;孙&#x27;</span>);</span><br><span class="line">		cbuff.put(<span class="string">&#x27;悟&#x27;</span>);</span><br><span class="line">		cbuff.put(<span class="string">&#x27;空&#x27;</span>);</span><br><span class="line">		cbuff.flip();</span><br><span class="line">		<span class="comment">// 将CharBuffer中的字符序列转换成字节序列</span></span><br><span class="line">		<span class="type">ByteBuffer</span> <span class="variable">bbuff</span> <span class="operator">=</span> cnEncoder.encode(cbuff);</span><br><span class="line">		<span class="comment">// 循环访问ByteBuffer中的每个字节</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bbuff.capacity(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.print(bbuff.get(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将ByteBuffer的数据解码成字符序列</span></span><br><span class="line">		System.out.println(<span class="string">&quot;\n&quot;</span> + cnDecoder.decode(bbuff));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面程序分别实现了将ByteBuffer转换成CharBuffer，和CharBuffer转换成ByteBuffer的功能。</p>
<p>实际上，Charset类也提供了三个方法</p>
<p><strong>CharBuffer decode(ByteBuffer
bb)</strong>:将ByteBuffer中的字节序列转换成字符序列的快捷方法</p>
<p><strong>ByteBuffer encode(CharBuffer
bb)</strong>:将CharBuffer中的字符序列转换成字节序列的快捷方法</p>
<p><strong>ByteBuffer encode(String
str)</strong>:将String字符序列转换成字节序列的快捷方法</p>
<p>也就是说，获取Charset对象以后，如果仅仅是需要简单的编码和解码操作，不需要创建对应的解码器和编码器，直接调用Charset对象的方法即可。</p>
<p>在String类里也提供了一个getBytes(String
charset)方法，该方法返回byte[],即使用指定字符集将字符串转换成字节序列</p>
<h2 id="文件锁">文件锁</h2>
<p>FileLock文件锁，在操作系统中很常见，如果多个程序同时访问、修改同一个文件，但是因为文件数据不同步而出现问题，给文件加一个锁，同一时间，只有一个程序可以访问该文件，或者所有程序都可以读取此文件，但不能同时写入，这就解决了同步问题。</p>
<p>文件锁是进程级别的，不是线程级别的，文件锁可以解决多个进程并发访问，但不能解决多线程并发访问的问题。</p>
<p>这就是说，当使用文件锁时，同一进程的多个线程可以同时访问修改该文件。</p>
<p>文件锁是当前程序所属的JVM实例持有的，一旦获取到文件锁，要释放文件锁有三种方法</p>
<ul>
<li>调用FileLock类的release方法</li>
<li>关闭对应的FileChannel对象</li>
<li>当前JVM退出</li>
</ul>
<p>文件锁分为两类</p>
<ul>
<li>排他锁：又叫做独占锁，对文件加上排他锁后，该进程可以对文件进行读写，该进程独占此文件，其他进程不能读写该文件，直到该进程释放文件锁。</li>
<li>共享锁：某个进程对文件加共享锁，其他进程也可以访问该文件，<strong>但是这些进程都只能读此文件，不能写</strong>，即读操作是共享的，但写操作是独占的，线程安全，其他进程不能获得该文件的排他锁，可以获得该文件的共享锁。</li>
</ul>
<p>在FileChannel提供的lock/tryLock方法可以获得文件锁FileLock对象,lock和tryLock的区别是：当lock方法试图锁定某个文件时，如果无法得到文件锁，程序将一直阻塞；而tryLock是尝试锁定文件，它将直接返回而不是阻塞，如果获得了文件锁，则该方法返回该文件锁，否则返回null</p>
<p>如果要锁定文件的部分内容，使用<strong>lock(long position, long size,
boolean shared)</strong>和<strong>tryLock(long position, long size,
boolean shared)</strong></p>
<p>所以一共有四种获得文件锁的方式</p>
<ul>
<li><strong>lock()</strong>：对整个文件加锁，默认为排他锁</li>
<li><strong>lock(long position, long size, boolean
shared)</strong>：自定义加锁方式，前两个指定加锁文件的起始位置和大小，第三个参数，如果为true，则是共享锁，false则为排他锁</li>
<li><strong>tryLock()</strong>：对整个文件加锁，默认排他锁，非阻塞式</li>
<li><strong>tryLock(long position, long size, boolean
shared)</strong>：自定义加锁方式，参数与第二个方法一样，非阻塞式</li>
</ul>
<p>FileLock其他常用的两个方法</p>
<ul>
<li><strong>boolean isShared()</strong>：判断此文件锁是否为共享锁</li>
<li><strong>boolean isValid()</strong>：判断此文件是否还有效</li>
</ul>
<p><strong>注意：</strong></p>
<p>文件锁虽然可以用于控制并发访问，但对于高并发访问的情形，还是推荐使用数据库保存程序信息</p>
<p>关于文件锁注意的几点</p>
<ul>
<li>在某些平台上，文件锁仅仅是建议性的，并不是强制性的，
这意味着即使一个程序不能获得文件锁，也可对该文件读写</li>
<li>在某些平台上，不能同步地锁定一个文件并把它映射到内存</li>
<li>文件锁是由Java虚拟机持有，如果两个Java程序使用同一个虚拟机运行，则他们不能对同一个文件进行加锁</li>
<li>在某些平台关闭FileChannel时，会释放虚拟机在该文件上的所有锁，因此避免对同一个被锁定的文件打开多个FileChannel</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84IO%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84IO%E6%B5%81/" class="post-title-link" itemprop="url">Java的IO流</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:12:39 / 修改时间：16:54:06" itemprop="dateCreated datePublished" datetime="2022-05-11T09:12:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在Java中把不同的输入输出源(键盘，文件，网络连接等)抽象表述为”流“，通过流的方式允许Java程序使用相同方式访问不同的输入/输出源。stream是从起源到接收的有序数据。</p>
<h2 id="流的分类">流的分类</h2>
<p>按照不同分类标准，可以将流分成不同类型。</p>
<ol type="1">
<li><p>按照流的流向来分，分为输入流和输出流</p>
<ol type="1">
<li>输入流：只能从中读取数据，不能写入数据</li>
<li>输出流：只能从中写入数据，不能读取数据</li>
</ol>
<p><strong>注</strong>：</p>
<p>此处输入输出是相对内存来说的，数据从硬盘或其他设备到内存是输入，从内存到其他设备是输出。</p>
<p>Java的输入流主要由InputStream和Reader作为基类，输出流由OutputStream和Writer作为基类。它们都是抽象基类，无法直接创建实例。</p></li>
<li><p>按照流的操作数据单元不同，分为字符流和字节流</p>
<ol type="1">
<li>字节流：操作的数据单元是8位的字节</li>
<li>字符流：操作的数据单元是16位的字符</li>
</ol>
<p>除了操作数据单元不同，字符流和字节流的用法几乎一样
字节流主要由InputStream和OutputStream作为基类，而字符流则主要由Reader和Writer作为基类。</p></li>
<li><p>按照流的角色来分，分为节点流和处理流</p>
<ol type="1">
<li>节点流：从一个特定的IO设备(如磁盘、网络)读/写数据的流，称为节点流，也被称为低级流。</li>
<li>处理流：对一个已存在的流就行连接或封装，通过封装后的流来实现数据读/写功能。处理流被称为高级流。</li>
</ol>
<p>注：</p>
<p>当时用处理流进行输入输出时，程序不会直接连接到实际的数据源，没有和实际的输入输出节点相连接，使用处理流的一个好处就是，只要使用相同的处理流，程序就可以采用完全相同的输入输出代码来访问不同数据源。</p></li>
</ol>
<h2 id="流的概念模型">流的概念模型</h2>
<p>Java把所有设备的有序数据抽象成流模型，简化了输入输出处理。</p>
<p>Java的IO流共涉及40多个类，非常规则，而且彼此之间存在紧密联系，Java的IO流的40多个类都是从如下的4个基类派生出来的：</p>
<ul>
<li>InputStream/Reader：所有输入流的基类，前者是字节输入流，后者字符输入流</li>
<li>OutputStream/Writer：所有输出流基类，前者字节输出流，后者字符输出流</li>
</ul>
<p>其中，处理流的功能主要体现在两个方面：</p>
<ul>
<li>性能的提高：主要以增加缓冲的方式提高输入/输出效率。</li>
<li>操作的便捷：处理流提高了一系列便捷的方式来一次输入/输出大批量的内容。</li>
</ul>
<p>处理流可以”嫁接“在任何已经存在的流的的基础上，这允许Java采用相同代码来访问不同输入/输出设备的数据流。</p>
<h2 id="字节流和字符流">字节流和字符流</h2>
<h3 id="inputstream和reader">InputStream和Reader</h3>
<p>这是所有输入流的抽象基类，它们本身并不能创建实例来执行，但是它们是所有输入流的模板，包含的方法是所有输入流都可使用的方法。</p>
<p>InputStream里包含三个方法：</p>
<p><strong>int read()</strong></p>
<p>功能：从输入流读取单个字节。</p>
<p>参数：无</p>
<p>返回值：返回读取的字节数据(字节数据可直接转换为int类型)</p>
<hr />
<p><strong>int read(byte[] b)</strong></p>
<p>功能：从输入流读取b.length个字节的数据，并储存在数组b中。</p>
<p>参数：byte数组</p>
<p>返回值：返回实际读取的字节数</p>
<hr />
<p><strong>int read(byte[] b, int off, int len)</strong></p>
<p>功能：从输入流读取len个字节的数据，存储在数组b中，不是从数组起点开始，而是从off位置开始。</p>
<p>参数：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>byte[] b</td>
<td>将读取的数据存入数组b中</td>
</tr>
<tr class="even">
<td>int off</td>
<td>从数组的off位置开始存</td>
</tr>
<tr class="odd">
<td>int len</td>
<td>从输入流读取len个字节的数据</td>
</tr>
</tbody>
</table>
<p>返回值：返回实际读取的字节数</p>
<hr />
<p>Reader里也包含三个方法</p>
<p><strong>int read()</strong></p>
<p>功能：从输入流读取单个字符。</p>
<p>参数：无</p>
<p>返回值：返回读取的字符数据(字节数据可直接转换为int类型)</p>
<hr />
<p><strong>int read(char[] cbuf)</strong></p>
<p>功能：从输入流读取cbuf.length个字符的数据，并储存在数组cbuf中。</p>
<p>参数：char数组</p>
<p>返回值：返回实际读取的字符数</p>
<hr />
<p><strong>int read(char[] cbuf int off, int len)</strong></p>
<p>功能：从输入流读取len个字符的数据，存储在数组cbuf中，不是从数组起点开始，而是从off位置开始。</p>
<p>参数：</p>
<table>
<thead>
<tr class="header">
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>char cbuf</td>
<td>将读取的数据存入数组cbuf中</td>
</tr>
<tr class="even">
<td>int off</td>
<td>从数组的off位置开始存</td>
</tr>
<tr class="odd">
<td>int len</td>
<td>从输入流读取len个字符的数据</td>
</tr>
</tbody>
</table>
<p>返回值：返回实际读取的字符数</p>
<p>可以发现，两个基类的功能基本一样，只是一个是字节，一个是字符</p>
<p>当read方法返回-1时，表明到了输入流的结束点</p>
<p>它们两个基类分别有用于读取文件的输入流：FileInputStream和FileReader,他们都是节点流——与指定文件关联。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileInputStreamTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 创建字节输入流</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;FileInputStreamTest.java&quot;</span>);</span><br><span class="line">		<span class="comment">// 创建一个长度为1024的“竹筒”</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">bbuf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="comment">// 用于保存实际读取的字节数</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">hasRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 使用循环来重复“取水”过程</span></span><br><span class="line">		<span class="keyword">while</span> ((hasRead = fis.read(bbuf)) &gt; <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 取出“竹筒”中水滴（字节），将字节数组转换成字符串输入！</span></span><br><span class="line">			System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(bbuf, <span class="number">0</span>, hasRead));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭文件输入流，放在finally块里更安全</span></span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<p>上面创建了一个1024字节的数组，但源文件不到1024个字节，只需要执行一次read即可，但如果创建较小长度的字节数组，程序运行时再输出中文注释时可能会出现乱码——因为Windows保存文件默认用GBK编码方法，这种方式下，每个中文字符占两个字节，如果只读到了半个中文字符，会出现乱码。</p>
<p>程序可以使用close()方法来关闭输入流，与JDBC编程一样，程序里打开的文件IO资源不属于内存资源，垃圾回收机制无法回收，应该显式关闭文件IO资源,IO资源类都实现了AutoCloseable接口，可以通过自动关闭资源的try语句来关闭IO流。</p>
<p>InoutStream和Reader还支持如下几个方法移动记录指针：</p>
<p><strong>void mark(int readAheadLimit)</strong></p>
<p>功能：在记录指针当前位置记录一个标记</p>
<p>参数：</p>
<p>readAheadLimit: 在标记位置变为无效之前可以读取的最大字节数限制。</p>
<p>返回值:无</p>
<hr />
<p><strong>boolean markSupported()</strong></p>
<p>功能：判断此输入流是否支持mark操作，即是否支持记录标记。</p>
<p>参数：无</p>
<p>返回值：</p>
<p>支持返回true，否则false</p>
<hr />
<p><strong>void reset()</strong></p>
<p>功能：将该流的记录指针重新定位到上一次记录标记的mark位置</p>
<p>参数：无</p>
<p>返回值：无</p>
<hr />
<p><strong>long skip(long n)</strong></p>
<p>功能：从记录指针开始，跳过n个字节/字符</p>
<p>参数：需要跳过的字符/字节数</p>
<p>返回值：实际跳过的字符/字节数</p>
<hr />
<p><strong>重要</strong>：<strong>Windows默认使用GBK编码保存文件，在GBK编码中，一个中文字符占两个字节，中文标点两个字节，英文字母和标
点占一个字节。且在文本文件中，每行末尾有，各占一个字节。</strong>
<strong>Linux系统默认使用UTF-8编码，在UTF-8编码中，一个中文字符和标点占三个字节，英文字母和标点占一个字节。
IDEA中默认使用UTF-8编码</strong></p>
<h3 id="outputstream和writer">OutputStream和Writer</h3>
<p>这两个类也非常相似，两个流都提供了三个方法。</p>
<p><strong>void write(int c)</strong></p>
<p>功能：将字节/字符输出到输出流。</p>
<p>参数：c可以代表字节，也可以代表字符。</p>
<p>返回值：无</p>
<hr />
<p><strong>void write(byte[]/char[] buf)</strong></p>
<p>功能：将字节数组/字符数组中的数据输出到指定输出流。</p>
<p>参数：要输出的字节数组/字符数组的数据</p>
<p>返回值：无</p>
<hr />
<p><strong>void write(byte[]/char[] buf, int off, int len)</strong></p>
<p>功能：将字节数组/字符数组中从off位置开始，长度为len的数据输出到指定输出流。</p>
<p>参数：</p>
<ul>
<li>byte[]/char[]:要输出的字符数组/字节数组</li>
<li>off：开始输出的数组位置</li>
<li>len：要输出的字符/字节长度</li>
</ul>
<p>返回值：无</p>
<hr />
<p>因为字符流以字符为基本操作单位，所以Writer可以用字符串来代替字符数组，即以String对象为参数，Writer里还包含两个方法：</p>
<p><strong>void write(String str)</strong></p>
<p>功能：将字符串中的数据输出到指定输出流。</p>
<p>参数：要输出的字符串</p>
<p>返回值：无</p>
<hr />
<p><strong>void write(String src, int off, int len)</strong></p>
<p>功能：将字符串中从off位置开始，长度为len的数据输出到指定输出流。</p>
<p>参数：</p>
<ul>
<li>src：要输出的字符串</li>
<li>off：开始输出的数组位置</li>
<li>len：要输出的字符/字节长度</li>
</ul>
<p>返回值：无</p>
<hr />
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileOutputStreamTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建字节输入流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;FileOutputStreamTest.java&quot;</span>);</span><br><span class="line">			<span class="comment">// 创建字节输出流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;newFile.txt&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">bbuf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">32</span>];</span><br><span class="line">			<span class="type">var</span> <span class="variable">hasRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 循环从输入流中取出数据</span></span><br><span class="line">			<span class="keyword">while</span> ((hasRead = fis.read(bbuf)) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 每读取一次，即写入文件输出流，读了多少，就写多少。</span></span><br><span class="line">				fos.write(bbuf, <span class="number">0</span>, hasRead);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="post-title-link" itemprop="url">Java的对象序列化和反序列化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:11:39 / 修改时间：16:54:04" itemprop="dateCreated datePublished" datetime="2022-05-11T09:11:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="序列化的含义和意义">序列化的含义和意义</h2>
<p>对象序列化的目标就是将对象保存到磁盘中，或者直接在网络传输对象，对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许永久保存在磁盘上。程序一旦获得了这种二进制流，都可以将这种二进制流恢复成原来的Java对象,即反序列化。</p>
<p>对象的序列化(Serialize)指将一个Java对象写入IO流，与此对应，对象的反序列化，指从IO流中恢复该Java对象。</p>
<p>Java
9增强了对象序列化机制，它允许对读入的序列化数据进行过滤，这种过滤在反序列化之前对数据进行校验，从而提高了安全性和健壮性。</p>
<p>如果需要让某个对象支持序列化机制，则必须让它的类是可序列化的，该类必须实现两个接口之一：</p>
<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
<p>Java很多类实现了Serializable，该接口为标记接口，无需实现任何方法，只是表明该类的实例是可以序列化的。</p>
<p>所有在网络上传输的对象的类都应该是实例化的。</p>
<h2
id="使用对象流实现序列化和反序列化">使用对象流实现序列化和反序列化</h2>
<p>实现序列化应该实现Serializable接口或者Externalizable接口之一，这两接口区别和联系，后面会有介绍，暂时不用理会Externalizable接口。</p>
<p>使用Serializable接口实现序列化很简单，只要让对应的类实现该接口即可。然后程序可以通过两个步骤序列化对象</p>
<ol type="1">
<li><p>创建一个ObjectOutputStream，这个输出流是一个处理流，必须建立在其他节点流的基础上</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.txt&quot;</span>));</span><br></pre></td></tr></table></figure></p></li>
<li><p>调用ObjectOutputStream对象的writeObject()方法输出该可序列化对象</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(per);</span><br></pre></td></tr></table></figure></p>
<p>下面程序定义了一个可序列化的类：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>然后使用ObjectOutputStream将Person对象写入磁盘文件</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> 									<span class="title class_">FileOutputStream</span>(<span class="string">&quot;transient.txt&quot;</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                        oos.writeObject(per);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>从IO流中恢复该Java对象，即反序列化，也需两步：</p>
<ol type="1">
<li><p>创建ObjectInputStream处理流：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.txt&quot;</span>));</span><br></pre></td></tr></table></figure></p></li>
<li><p>调用ObjectInputStream对象的readObject()方法读取流中的对象，该方法返回一个Object对象，如果程序知道该Java对象类型，应强制转换，代码：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br></pre></td></tr></table></figure></p>
<p>完整的从object文件读取Java对象：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadObject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(object.txt)))</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;名字为&quot;</span> + p.getName() + <span class="string">&quot;年龄为&quot;</span> + p.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong></p>
<ol type="1">
<li>反序列化读取的仅仅是Java对象的数据，不是Java类，因此采用反序列化恢复Java对象时，必须提供Java对象所属类的class文件，否则将会引发ClassNotFoundException异常。</li>
<li>Person类只有一个有参数的构造器，没有无参数的构造器，而且该构造器有打印语句，但反序列化java对象时，没有看到程序调用该构造器，说明反序列化机制不需要通过构造器来初始化Java对象。</li>
<li><strong>当使用序列化机制向文件写入多个Java对象，使用反序列化机制时必须按写入的顺序来读取</strong>。</li>
<li>当一个可序列化类有多个父类时(包括直接父类和间接父类)，这些父类要么有无参数的构造器，要么也是可序列化的，否则反序列化时会抛出InvalidClassException异常，如果父类是不可序列化的，只是带有无参数的构造器，则该父类定义的成员变量值不会序列化到二进制流中。</li>
</ol>
<p>## 对象引用的序列化</p>
<p>之前介绍的序列化对象对应的类Person，两个成员变量分别是String和int类型，如果某个类的成员变量不是基本类型或者String类型，而是另一种引用类型，那么这个引用类型必须是可序列化的，否则拥有该变量的类也是不可序列化的。<strong>换句话说，只有一个类的所有成员变量对应的类都是可序列化的，这个类才是可序列化的，基本类型和String已经实现了可序列化。</strong></p>
<p>比如Teacher类里有一个成员变量是Person类，只有Person是可序列化的，Teacher才是可序列化的。</p>
<p>那么现在假设有一种特殊的情形，程序有两个Teacher对象，它们的student实例变量都引用同一个Person对象，而且该Person对象还有一个引用变量引用它，代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;唐僧&quot;</span>, per);</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;菩提祖师&quot;</span>, per);</span><br></pre></td></tr></table></figure></p>
<p>上面代码创建了两个Teacher对象和一个Person对象，这里产生了一个问题，如果先序列化t1对象，则系统会将t1对象引用的Person对象一起序列化，如果程序再序列化t2对象，系统会序列化t2对象，如果再序列化per对象，系统会再次序列化该Person对象，整个过程似乎会序列化三个Person对象。</p>
<p>那么当输入流反序列化这些对象时，将会得到三个Person对象，从而引起t1和t2对象引用的不是同一个Person对象，这违背了Java序列化机制的初衷。</p>
<p>所以Java序列化机制采用特殊序列化算法如下：</p>
<ul>
<li>所有保存到磁盘中的对象都有一个序列化编号</li>
<li>当程序试图序列化一个对象，程序先检查该对象是否已经被序列化过，只有该对象从未(在本次虚拟机中)被序列化过，系统才会将该对象转换成字节序列输出</li>
<li>如果某个对象已经被序列化，程序将只输出一个序列化编号，而不是重新序列化该对象</li>
</ul>
<p>根据上述序列化算法，可以知道当第二次第三次序列化Person对象时，程序将只会输出一个序列化编号。</p>
<p><strong>注意</strong></p>
<p>这种序列化算法也会引起潜在问题，当多次序列化一个对象时，只有第一次会序列化该对象，那么当第一次序列化该对象时，如果修改了该对象成员变量的值，再次序列化，也只会输出一个序列化编号，即第一次序列化的对象，因此改变的成员变量值不会被输出。</p>
<p><strong>所以在序列化Java对象时，一定要注意，只有第一次序列化才会将对象转换成字节序列，在后面程序中，即使该对象实例变量发生改变，再次调用writeObject方法时，改变的实例变量也不会被输出。</strong></p>
<p>## Java 9增加的过滤功能</p>
<p>Java
9为ObjectInputStream增加了setObjectFilter(),getObjectFilter()两个方法，其中一个方法为对象输入流设置过滤器，当程序通过ObjectInputStream反序列化对象时，过滤器的checkInput()方法会被自动激发，用于检查序列化数据是否有效。</p>
<p>使用checkInput()方法检查序列化数据有三种返回值：</p>
<ul>
<li>Status.REJECTED:拒绝恢复</li>
<li>Status.ALLOWED:允许恢复</li>
<li>Status.UNDECIDED:未决定状态，程序将继续执行检查</li>
</ul>
<p>ObjectInputStream会根据ObjectInputFilter检查结果来决定是否执行反序列化，如果返回Status.REJECTED，反序列化将会被阻止，返回ALLOWED，反序列化会被执行。</p>
<p>例子：该程序会在反序列化之前对数据执行检查：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			ois.setObjectInputFilter((info) -&gt; &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;===执行数据过滤===&quot;</span>);</span><br><span class="line">				<span class="type">ObjectInputFilter</span> <span class="variable">serialFilter</span> <span class="operator">=</span> ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">					<span class="keyword">if</span> (serialFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="comment">// 首先使用ObjectInputFilter执行默认的检查</span></span><br><span class="line">						ObjectInputFilter.<span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> serialFilter.checkInput(info);</span><br><span class="line">						<span class="comment">// 如果默认检查的结果不是Status.UNDECIDED</span></span><br><span class="line">						<span class="keyword">if</span> (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">							<span class="comment">// 直接返回检查结果</span></span><br><span class="line">							<span class="keyword">return</span> status;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 如果要恢复的对象不是1个</span></span><br><span class="line">					<span class="keyword">if</span> (info.references() != <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// 不允许恢复对象</span></span><br><span class="line">						<span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (info.serialClass() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">						<span class="comment">// 如果恢复的不是Person类</span></span><br><span class="line">						info.serialClass() != Person.class)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// 不允许恢复对象</span></span><br><span class="line">						<span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">				&#125;);</span><br><span class="line">			<span class="comment">// 从输入流中读取一个Java对象，并将其强制类型转换为Person类</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">			System.out.println(<span class="string">&quot;名字为：&quot;</span> + p.getName()</span><br><span class="line">				+ <span class="string">&quot;\n年龄为：&quot;</span> + p.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码重写了checkInput方法，先使用默认的ObjectInputFilter执行检查，如果检查结果不是Status.UNDECIDED，程序直接返回检查结果，接下来通过FilterInfo检查序列化数据，如果序列化数据不唯一，拒绝执行，如果不是Person对象，拒绝执行，通过这种检查，程序可以保证反序列化出来的是唯一的Person对象。</p>
<p>## 自定义序列化</p>
<p>在一些特殊的情景，如果一个类的某些实例变量是敏感信息，这时不希望程序将该实例变量进行实例化，或者某个实例变量类型是不可序列化的，因此不希望对该实例变量进行递归序列化。</p>
<p><strong>递归序列化</strong>：</p>
<p>当对某个对象进行序列化时，系统会自动把该对象的所有实例变量依次进行序列化，如果某个实例变量引用到另一个对象，则该引用的对象也会被序列化，这样一层一层的递归的进行对象序列化，就是递归序列化。</p>
<p>通过在实例变量前面使用transient关键词修饰，可以指定Java序列化时无需理会该实例变量。</p>
<p>例子：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// name的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// age的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong></p>
<p>transient关键词只能用于修饰实例变量，不可修饰Java程序其他成分。</p>
<p>下面先序列化一个Person对象，然后反序列化读取，再输出age变量</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransientTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;transient.txt&quot;</span>));</span><br><span class="line">			<span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;transient.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">			<span class="comment">// 系统会per对象转换字节序列并输出</span></span><br><span class="line">			oos.writeObject(per);</span><br><span class="line">			<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">			System.out.println(p.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>age使用transient关键词修饰，所以输出age的值为0.</p>
<p>使用transient关键词修饰实例变量虽然简单，方便，但是所修饰的实例变量将被完成隔离在序列化机制之外，这样导致反序列化时无法取得该实例变量值，Java提供了一种自定义序列化机制，可以让程序控制如何序列化各实例变量。</p>
<p>需要特殊处理的类应该提供如下特殊签名的方法，这些方法用于实现自定义序列化。</p>
<p><strong>private void writeObject(java.io.ObjectOutputStream out)
throws IOException</strong></p>
<p>功能：负责写入特定类的实例状态，以便readObject()如何恢复它</p>
<p>参数:out:特定对象输出流</p>
<p>返回值：无</p>
<p><strong>注：</strong></p>
<p>默认情况，该方法会调用out.defaultWriteObject来保存Java对象实例变量。</p>
<hr />
<p><strong>private void writeObject(java.io.ObjectOutputStream out)
throws IOException</strong></p>
<p>功能：负责从流中读取并恢复实例变量</p>
<p>参数:in:特定对象输入流</p>
<p>返回值：无</p>
<p><strong>注：</strong></p>
<p>默认情况，该方法会调用in.defaultReadObject来恢复Java对象的非瞬态实例变量，通常情况，readObject和writeObject方法相对应。</p>
<hr />
<p><strong>private void readObjectNoData() throws
ObjectStreamException</strong></p>
<p>功能：如果序列化流不完整，此方法可以正确初始化反序列化的对象，例如，接收方使用的反序列化类版本不同于发送方，或者序列化流被篡改时，系统调用此方法初始化反序列化的对象。</p>
<hr />
<p>下面Person类重写了writeObject方法和readObject方法，其中写入时先将name变量包装成SringBuffer，然后反转进行写入，读取时，先将读取的数据强制类型转换为StringBuffer，再将其反转后赋给name变量。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// name的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// age的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将name实例变量的值反转后写入二进制流</span></span><br><span class="line">		out.writeObject(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(name).reverse());</span><br><span class="line">		out.writeInt(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">		<span class="built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse()</span><br><span class="line">			.toString();</span><br><span class="line">		<span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于这个Person类而言，序列化和反序列化Person实例与不重写两个方法效果一样，区别在于序列化后的处理流，即使有Cracker截获到Person对象流，它看到的也是加密后的name，提高了序列化的安全性。</p></li>
</ol>
<p><strong>注意：</strong></p>
<p>writeObject方法存储实例变量的顺序应该和readObject方法恢复实例变量的顺序一致。</p>
<p>还有一种更彻底的自定义机制，它甚至可以在序列化对象之前，将该对象替换成其他对象，如果需要，则应该为序列化类提供如下特殊方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANY_ACCESS_MODIFIER Object <span class="title function_">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span><br></pre></td></tr></table></figure>
<p>此序列化方法由序列化机制调用，只要该方法存在。因为该方法可以拥有private、protected和包私有权限，所以子类可能获得该方法。</p>
<p>下面例子提供了writeReplace方法，可以在写入Person对象是将该对象替换成ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// name的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// age的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	重写writeReplace方法，程序在序列化该对象之前，先调用该方法</span></span><br><span class="line">	<span class="keyword">private</span> Object <span class="title function_">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span><br><span class="line">	&#123;</span><br><span class="line">		ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(name);</span><br><span class="line">		list.add(age);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java序列化机制保证在序列化某个对象之前，先调用该对象的writePeplace方法，如果该对象返回另一个Java对象，则需系统转为序列化另一个对象。如下程序表明序列化Person对象，实际序列化的是ArrayList对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplaceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;replace.txt&quot;</span>));</span><br><span class="line">			<span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;replace.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">			<span class="comment">// 系统将per对象转换字节序列并输出</span></span><br><span class="line">			oos.writeObject(per);</span><br><span class="line">			<span class="comment">// 反序列化读取得到的是ArrayList</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> (ArrayList) ois.readObject();</span><br><span class="line">			System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>综上所述，系统在序列化某个对象之前，首先调用该对象的writeReplcae方法，如果该方法返回另一个对象，系统将再次调用另一个对象的writeReplace方法，直到该方法不再返回另一个对象为止。然后程序最后调用该对象的writeObject方法保存对象状态。</p>
<p>与writeReplace方法相对应的是，序列化机制还有一个特殊的方法，它可以实现保护性复制整个对象，该方法是：</p>
<p><code>ANY_ACCESS_MODIFIER Object readResolve() throws
ObjectStreamException</code></p>
<p>这个方法会在readObject方法调用后被调用，该方法的返回值会替代原来反序列化的对象，而原来使用readObject方法反序列化的对象会被丢弃。</p>
<p>readResolve方法在序列化单例类。枚举类时尤其有用。</p>
<p>例如下面一个枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orientation</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Orientation</span> <span class="variable">HORIZONTAL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Orientation</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Orientation</span> <span class="variable">VERTICAL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Orientation</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Orientation</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>该枚举类构造器私有，程序有两个Orientation对象，但如果让该类实现Serializable接口，会引发一个问题，如果将Orientation.HORIZONTAL值序列化后再读入，如果立即拿读入后的对象与Orientation.HORIZONTAL进行比较，返回false，也就是说读入的对象是一个新的Orientation对象，而不等于Orientation类中的任何枚举类，虽然Orientation的构造器是私有的，但反序列化依然可以创建新的Orientation对象。</p>
<p><strong>提示</strong>：</p>
<p>反序列化机制在恢复Java对象时无序调用构造器来初始化对象，从这个意义上看，序列化对象可以“克隆”对象。</p>
<p>在这种情况下，可以为Orientation类提供一个readResolve方法来解决，readResolve方法返回值会代替原反序列化对象，也就是让反序列化得到的Orientation对象直接被丢弃。</p>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 为枚举类增加readResolve()方法</span></span><br><span class="line">	<span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> HORIZONTAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> VERTICAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过重写readResolve方法可以保证反序列化得到的依然是Orientation的两个枚举对象之一。</p>
<p><strong>注意</strong>：所有单例类、枚举类序列化时都应该提供readResolve方法，这样才能保证反序列化的对象依然正常。</p>
<p>与writeReplace方法类似，readResolve方法一可以用任意访问控制符，因此父类readResolve方法可能被子类继承，这样使用该方法就会存在明显的缺点：当父类已经实现readResolve方法，子类将变得无从下手，如果父类包含protected或public的readResolve方法，而且子类没有重写该方法，会使得子类反序列化时得到一个父类的对象。总是让子类重写readResolve方法无疑是个负担。因此对于要作为父类继承的类而言，实现readResolve方法可能会有潜在危险。
<strong>通常建议时，对于final类重写readResolve方法不会有任何问题，因为该类不可以被继承，否则重写readResolve尽量使用private修饰。</strong></p>
<h2 id="另一种自定义序列化机制">另一种自定义序列化机制</h2>
<p>Java提供了另一种序列化机制，即Externalizable接口，这种序列化方式完全由程序员决定存储和恢复对象数据，该接口定义了两个方法。</p>
<p><strong>void readExternal(ObjectInput in)</strong></p>
<p>功能：实现反序列化，从输入流中读取对象</p>
<p>参数：in:输入流</p>
<p>返回值：无</p>
<p><strong>注</strong></p>
<p>该方法调用DataInput的方法来恢复<strong>基本类型</strong>的实例变量值，调用ObjectOutput的writeObject()方法来保存<strong>引用类型</strong>的实例变量。</p>
<hr />
<p><strong>void writeExternal(ObjectOutput out)</strong></p>
<p>功能：实现序列化</p>
<p>参数：out：输出流</p>
<p>返回值：无</p>
<p><strong>注</strong></p>
<p>该方法调用DataOutput的方法来保存<strong>基本类型</strong>的实例变量值，使用ObjectOutput的writeObject方法保存<strong>引用类型</strong>的实例变量值。</p>
<hr />
<p>实际上，采用Externalizable接口序列化和前面的Serializable序列化很相似，只是Externalizable强制自定义序列化，必须要实现上述两个方法，下面的Person类实现了Externalizable接口，并且实现了该接口的两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Externalizable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 注意必须提供无参数的构造器，否则反序列化时会失败。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// name的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// age的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(java.io.ObjectOutput out)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将name实例变量的值反转后写入二进制流</span></span><br><span class="line">		out.writeObject(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(name).reverse());</span><br><span class="line">		out.writeInt(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(java.io.ObjectInput in)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">		<span class="built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">		<span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果程序需要序列化实现Externalizable接口对象，一样调用writeObject方法，反序列化则调用readObject方法，和之前用法一样。</p>
<p><strong>注意</strong>：</p>
<p>当时用Externalizable机制反序列化对象时，程序会首先使用public的无参数构造器创建实例，然后才执行readExternal方法进行反序列化，因此<strong>实现Externalizable的序列化类必须提供public的无参数构造器</strong>。</p>
<h2 id="两种序列化机制对比">两种序列化机制对比</h2>
<table>
<colgroup>
<col style="width: 54%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>实现Serializable接口</th>
<th>实现Externalizable接口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>系统自动存储必要信息</td>
<td>程序员决定存储哪些信息</td>
</tr>
<tr class="even">
<td>Java内建支持，易于实现，只需实现该接口即可，无需任何代码支持</td>
<td>仅提供两个空方法，实现该接口要为两个空方法提供实现</td>
</tr>
<tr class="odd">
<td>性能略差</td>
<td>性能略好</td>
</tr>
</tbody>
</table>
<p>虽然Externalizable接口性能较好，但是实现Externalizable接口导致编程复杂，所以但部分时候还是使用Serializable接口。</p>
<p>关于对象序列化，以下几点需要注意：</p>
<ul>
<li>对象的类名、实例变量(包括基本类型、数组、对其他对象的引用)，都会被序列化，但是方法，类变量，transient实例变量(也被称为瞬态实例变量)不会被序列化</li>
<li>实现Serializable接口的类如果需要让某个实例变量不被序列化，应该添加transient关键词，而不应该用static修饰，虽然也可达到这个效果，但这个关键词不是这么用的，而且也会出现其他问题。</li>
<li>保证序列化对象的实例变量类型也是可序列化的。</li>
<li>反序列化对象必须有序列化对象的class文件</li>
<li>当通过文件、网络读取序列化后的对象时，必须按实际写入的顺序读取。</li>
</ul>
<p>##　版本</p>
<p>反序列化对象时必须提供该对象对应类的class文件，现在问题是，随着项目升级，系统的class文件也会升级，Java如何保证class文件的兼容性。</p>
<p>Java序列化机制允许为序列化类提供一个private static
final的serialVersionUID值，该类变量的值用于标识该Java类的序列化版本，也就是说，如果一个类升级以后，只要它的serialVersionUID值不变，序列化机制会把它们当成同一个序列化版本。</p>
<p>分配serialVersionUID值很简单，</p>
<p><code>private static final long serialVersionUID = 512L;</code></p>
<p>为了在反序列化时确保序列化版本的兼容性，最好在每个序列化类中加入这个类变量，具体数值可以自己定义，这样即使在某个对象被序列化后，它所对应的类被修改了，该对象也容易被正确反序列化。</p>
<p>每个类的serialVersionUID值都是唯一的，也就是说不同类的serialVersionUID值不应该相同。</p>
<p>如果不显式指定这个类变量的值，该类变量的值由JVM根据类的相关信息计算，而修改后的类的计算结果和之前的计算结果往往不同，造成对象反序列化因为类版本不兼容而失败。</p>
<p>不显式指定这个serialVersionUID值的另一个坏处是，不利于程序在不同JVM之间移植，因为不同编译器对该类变量的计算策略可能不同，从而造成类可能没有改变，但是serialVersionUID值不同。</p>
<p>那么对类的哪些修改可能会导致改变serialVersionUID值呢？</p>
<p>分三种情况讨论：</p>
<ul>
<li><p>如果修改类时仅仅修改了静态变量或者瞬态实例变量，则反序列化不受任何影响，serialVersionUID值不会改变</p></li>
<li><p>如果修改类时，仅仅修改了方法，则反序列化不受任何影响，serialVersionUID值不改变</p></li>
<li><p>如果修改类时修改了非瞬态的实例变量，则可能导致序列化版本不兼容。</p>
<ol type="1">
<li>如果对象流中的对象与新类中包含同名的实例变量，而实例变量类型不同，则反序列化失败，serialVersionUID值会改变</li>
<li>如果对象流的对象比新类中包含更多的实例变量，即新类删除了部分实例变量，则多出的实例变量值被忽略，序列化版本可以兼容，serialVersionUID值不会改变</li>
<li>如果新类比对象流中的对象包含更多的实例变量，即新类增加了一些实例变量，那么序列化版本也可以兼容，serialVersionUID值不会更新，但是反序列化中的对象得到的新对象多出来的实例变量值都是null(引用类型变量)或者0(基本类型变量)。</li>
</ol></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" class="post-title-link" itemprop="url">重定向输入输出</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:10:39 / 修改时间：16:53:59" itemprop="dateCreated datePublished" datetime="2022-05-11T09:10:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java的标准输入输出分别通过System.in和System.out来代表，默认情况他们分别代表键盘和显示器，在System.in类里提供了三个重定向标准输入输出的方法：</p>
<p><strong>static void setErr(PrintStram err)</strong></p>
<p>功能：重定向标准错误输出</p>
<p>参数:</p>
<ul>
<li>err：重新定向的标准错误输出流</li>
</ul>
<p>返回值：无</p>
<hr />
<p><strong>static void setIn(InputStream in)</strong></p>
<p>功能：重定向标准输入</p>
<p>参数:</p>
<ul>
<li>in：重新定向的标准输入流</li>
</ul>
<p>返回值：无</p>
<hr />
<p><strong>static void setOut(PrintStram out)</strong></p>
<p>功能：重定向标准输出</p>
<p>参数:</p>
<ul>
<li>out：重新定向的标准输出流</li>
</ul>
<p>返回值：无</p>
<hr />
<p>下面两个例子，分别是标准输出重定向:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedirectOut</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 一次性创建PrintStream输出流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;out.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将标准输出重定向到ps输出流</span></span><br><span class="line">			System.setOut(ps);</span><br><span class="line">			<span class="comment">// 向标准输出输出一个字符串</span></span><br><span class="line">			System.out.println(<span class="string">&quot;普通字符串&quot;</span>);</span><br><span class="line">			<span class="comment">// 向标准输出输出一个对象</span></span><br><span class="line">			System.out.println(<span class="keyword">new</span> <span class="title class_">RedirectOut</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>标准输入重定向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedirectIn</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">var</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;RedirectIn.java&quot;</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 将标准输入重定向到fis输入流</span></span><br><span class="line">			System.setIn(fis);</span><br><span class="line">			<span class="comment">// 使用System.in创建Scanner对象，用于获取标准输入</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">			<span class="comment">// 增加下面一行将只把回车作为分隔符</span></span><br><span class="line">			sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">			<span class="comment">// 判断是否还有下一个输入项</span></span><br><span class="line">			<span class="keyword">while</span> (sc.hasNext())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 输出输入项</span></span><br><span class="line">				System.out.println(<span class="string">&quot;键盘输入的内容是：&quot;</span> + sc.next());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/File%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/File%E7%B1%BB/" class="post-title-link" itemprop="url">File类</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:09:39 / 修改时间：16:54:02" itemprop="dateCreated datePublished" datetime="2022-05-11T09:09:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>File类代表与平台无关的文件和<strong>目录</strong>，
File可以操作文件和目录，如新建、创建和重命名目录，但是File不能访问文件内容，要想访问文件内容，需要输入输出流。</p>
<h2 id="访问文件和目录">访问文件和目录</h2>
<p>File类可以使用文件路径字符串创建File实例，字符串既可以是相对路径，也可以是绝对路径。在默认情况，系统依据用户工作路径解释相对路径，这个路径由系统属性“user.dir”指定，通常就是运行Java虚拟机所在的路径。</p>
<h4 id="解释">解释</h4>
<p>绝对路径：盘符开头的路径，表示是一个绝对路径，如"C:/download/a.txt"</p>
<p>相对路径：
相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。</p>
<hr />
<p>"./"：代表当前目录。</p>
<p>"../"：代表父目录。</p>
<p>注：在Java源文件用相对路径，默认是工作空间所在目录。</p>
<ol type="1">
<li><p>访问文件名相关方法：</p>
<p><strong>String getName()</strong></p>
<p>功能：返回此File对象表示的文件名或路径名(如果是路径，只返回最后一级目录名)</p>
<p>参数：无</p>
<p>返回值：字符串</p>
<p>例子：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/a/b/c/test.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/a/b/c&quot;</span>);</span><br><span class="line">System.out.println(file.getName());</span><br><span class="line">System.out.println(dir.getName());</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<p><img src="C:\Users\Bu'l'l'shi't\AppData\Roaming\Typora\typora-user-images\image-20200412175643211.png" alt="image-20200412175643211" style="zoom:120%;" /></p>
<hr />
<p><strong>String getPath()</strong></p>
<p>功能：返回File对象对应的路径名。</p>
<p>参数：无</p>
<p>返回值：路径名字符串</p>
<p><strong>注意</strong>：</p>
<p>若File对象使用绝对路径构造的，则返回的是绝对路径，若用相对路径构造的，则返回的是相对路径</p>
<p>例子：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/a/b/c/test.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line">System.out.println(file.getPath());</span><br><span class="line">System.out.println(file1.getPath());</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<figure>
<img
src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200412184557985.png"
alt="image-20200412184557985" />
<figcaption aria-hidden="true">image-20200412184557985</figcaption>
</figure>
<hr />
<p><strong>File getAbsoluteFile()</strong></p>
<p>功能：返回此对象的绝对路径。</p>
<p>参数：无</p>
<p>返回值：返回用此File对象绝对路径构造的File对象。</p>
<hr />
<p><strong>String getAbsolutePath()</strong></p>
<p>功能：返回此File对象的绝对路径<strong>名</strong>。</p>
<p>参数：无</p>
<p>返回值：返回此File对象的绝对路径名字符串。</p>
<p><strong>注意</strong>：</p>
<p>打印同一个对象使用该方法和上述方法，输出都是一样的，但是该方法返回的只是绝对路径名字构成的字符串，</p>
<hr />
<p><strong>String getParent()</strong></p>
<p>功能：返回此对象对应目录的父目录名。</p>
<p>参数：无</p>
<p>返回值：父目录名构成的字符串</p>
<p><strong>注意</strong></p>
<ol type="1">
<li><p>若File对象是文件，则返回该文件所在目录，若File是路径，则返回该目录上一级目录。</p></li>
<li><p>如果File对象是以相对路径构造的，则用该方法返回的是null，即没有父目录。</p></li>
<li><p>如果File对象是用绝对路径，则返回绝对路径。</p></li>
</ol>
<p>例子：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/a/b/c/test.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;a.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">dir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:/a/b/c&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">dir1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">System.out.println(file.getParent());</span><br><span class="line">System.out.println(file1.getParent());</span><br><span class="line">System.out.println(dir.getParent());</span><br><span class="line">System.out.println(dir1.getParent());</span><br></pre></td></tr></table></figure></p>
<p>输出：</p>
<p><img src="picture/image-20200413092038023.png" alt="image-20200413092038023"  /></p>
<hr />
<p><strong>boolean renameTo(File newName)</strong></p>
<p>功能：重命名File对象对应的文件或者目录</p>
<p>参数：新名字字符串构成的File对象</p>
<p>返回值：</p>
<p>如果重命名成功，返回true，否则返回false</p>
<p><strong>注意</strong></p>
<p>只可以该最后一级文件或者目录。</p>
<p>其实前面几级也可以改，但会出现错误的情况，所以用就只改最后一级目录。</p>
<hr /></li>
<li><p>文件检测相关方法：</p>
<hr />
<p><strong>boolean exists()</strong></p>
<p>功能：判断File对象对应文件目录是否存在</p>
<p>参数：无</p>
<p>返回值：</p>
<p>存在返回true，否则false</p>
<hr />
<p><strong>boolean canWrite()</strong></p>
<p>功能：判断File对象对应文件或目录是否可写</p>
<p>参数：无</p>
<p>返回值：</p>
<p>可写返回true，否则false</p>
<hr />
<p><strong>boolean canRead()</strong></p>
<p>功能：判断对应文件或目录是否可读</p>
<p>参数：无</p>
<p>返回值：</p>
<p>可读返回true，否则false</p>
<hr />
<p><strong>boolean isFile()</strong></p>
<p>功能：判断File对象对应的是否为文件</p>
<p>参数：无</p>
<p>返回值：</p>
<p>是文件返回true，否则false</p>
<hr />
<p><strong>boolean isDirectory()</strong></p>
<p>功能：判断是否为目录</p>
<p>参数：无</p>
<p>返回值：</p>
<p>是目录返回true，否则false</p>
<hr />
<p><strong>boolean isAbsolute()</strong></p>
<p>功能：判断File对象是否为绝对路径，该方法消除了不同平台差异。</p>
<p>参数：无</p>
<p>返回值：</p>
<p>是绝对路径返回true，否则返回false</p>
<p><strong>注意</strong></p>
<p>在UNIX/Linux系统上，绝对路径开头是一条斜线/，在Windows系统上，绝对路径开头是盘符，C盘D盘等等。</p>
<hr /></li>
<li><p>获取常规文件信息方法：</p>
<p><strong>long lastModified()</strong></p>
<p>功能：返回文件最后修改时间</p>
<p>参数：无</p>
<p>返回值：</p>
<p>时间构成的long型整数</p>
<hr />
<p><strong>long length()</strong></p>
<p>功能：返回文件内容长度，以字节为单位。</p>
<p>参数：无</p>
<p>返回值：</p>
<p>文件内容长度构成的long型整数</p>
<hr /></li>
<li><p>文件操作相关方法：</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th>函数原型</th>
<th>功能</th>
<th>参数</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>boolean createNewFile()</td>
<td>如果File对象对应的文件不存在，<br />则创建一个新文件，<br />创建成功返回ture，<br />否则返回false</td>
<td>无</td>
</tr>
<tr class="even">
<td>boolean delete()</td>
<td>删除File对象对应的文件或路径，<br /><strong>如果是路径，则对应路径必须是空目录</strong></td>
<td>无</td>
</tr>
<tr class="odd">
<td>static File createTempFile(String prefix, String suffix)</td>
<td>在默认临时文件目录创建临时文件</td>
<td>prefix:给定前缀，至少3字节长<br />suffix:后缀，若null，默认".tmp"</td>
</tr>
<tr class="even">
<td>static File createTempFile(String prefix, String suffix, File
directory)</td>
<td>在指定目录创建临时空文件</td>
<td>prefix和suffix同上<br />directory:指定目录</td>
</tr>
</tbody>
</table></li>
<li><p>目录操作相关方法：</p>
<p><strong>boolean mkdir()</strong></p></li>
</ol>
<p>功能：创建一个File对象对应的<strong>一个</strong>目录，File对象必须是路径。</p>
<p>参数：无</p>
<p>返回值：</p>
<p>若创建成功，返回ture，否则返回false.</p>
<p><strong>注意</strong>：</p>
<p>该方法只能创建一个，若需要创建多级目录，则会创建失败。</p>
<p>例如 <code>dir.mkdir()</code>
其中dir对应目录“D:/a/b/c”，只能创建c目录，若b目录不存在，会创建失败。</p>
<hr />
<p><strong>boolean medirs()</strong></p>
<p>功能：创建一个File对象对应的多级目录，File对象必须是路径。</p>
<p>参数：无</p>
<p>返回值：</p>
<p>创建成功返回ture，失败返回false</p>
<p><strong>注意</strong>：</p>
<p>该方法可以创建多级目录，例如例如 <code>dir.mkdir()</code>
其中dir对应目录“D:/a/b/c”，若a目录不存在，则会按照目录关系一级一级创建。</p>
<hr />
<p><strong>String[] list()</strong></p>
<p>功能：返回File对象的所有子文件名和目录名，File对象必须是路径。</p>
<p>参数：无</p>
<p>返回值：返回一个String数组。</p>
<p><strong>注意</strong>：</p>
<p>只会返回本目录所有文件的名字和目录的名字。</p>
<hr />
<p><strong>File[] listFiles</strong></p>
<p>功能：列出File对象所有子文件名和目录名，File对象必须是路径。</p>
<p>参数：无</p>
<p>返回值：返回一个包含所有File对象的File数组</p>
<p><strong>注意</strong>:</p>
<p>若File对象是用绝对路径构造的，则返回的子文件名和目录用getPath()方法返回的是绝对路径
若用的是相对路径，则返回的File对象用getPath()方法返回的是相对路径。</p>
<hr />
<p><strong>static File[] listRoots()</strong></p>
<p>功能：列出系统所有的根路径，就是C盘，D盘，静态方法，可用File类直接调用</p>
<p>参数：无</p>
<p>返回值：返回一个包含根路径的File对象数组。</p>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File[] a = File.listRoots();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(a[i].getPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="C:\Users\Bu'l'l'shi't\AppData\Roaming\Typora\typora-user-images\image-20200412175210822.png" alt="image-2" style="zoom:120%;" /></p>
<p>​</p>
<p>​</p>
<p>​</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/blog_images/avatar.png">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BD%93%E7%B3%BB/" class="post-title-link" itemprop="url">输入/输出体系</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:08:39 / 修改时间：16:53:57" itemprop="dateCreated datePublished" datetime="2022-05-11T09:08:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="处理流的用法">处理流的用法</h2>
<p>使用处理流的典型思路是，使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层IO设备、文件进行交互。</p>
<p>实际识别处理流非常简单，只要流的构造器参数不是一个物理节点，而是已经存在的流，它就一定是处理流。
所有节点流都是直接以物理IO节点作为构造器参数的。</p>
<p>使用PrintStream处理流来包装OutputStream的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintStreamTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="type">var</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">			<span class="type">var</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 使用PrintStream执行输出</span></span><br><span class="line">			ps.println(<span class="string">&quot;普通字符串&quot;</span>);</span><br><span class="line">			<span class="comment">// 直接使用PrintStream输出对象</span></span><br><span class="line">			ps.println(<span class="keyword">new</span> <span class="title class_">PrintStreamTest</span>());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提示：由于PrintStream类的输出功能非常强大，通常如果需要输出文本内容，都应该包装成PrintStream后进行输出。</p>
<p><strong>注意</strong>：</p>
<p>使用处理流包装了底层节点流后，关闭输入/输出资源时，只要关闭最上层的处理流即可，系统会自动关闭被该处理流包装的节点流。</p>
<p>##输入/输出体系</p>
<p>Java输入/输出流体系常用流分类</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 23%" />
<col style="width: 24%" />
<col style="width: 19%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>抽象基类</td>
<td><em>InputStream</em></td>
<td><em>OutputStream</em></td>
<td><em>Reader</em></td>
<td><em>Writer</em></td>
</tr>
<tr class="even">
<td>访问文件</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
</tr>
<tr class="odd">
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr class="even">
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr class="odd">
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr class="even">
<td>缓冲流</td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
</tr>
<tr class="odd">
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
</tr>
<tr class="even">
<td>对象流</td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>抽象基类</td>
<td><em>FilterInputStream</em></td>
<td><em>FilterOutputStream</em></td>
<td><em>FilterReader</em></td>
<td><em>FilterWriter</em></td>
</tr>
<tr class="even">
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr class="odd">
<td>推回输入流</td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr class="even">
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：</p>
<p>字节流的功能比字符流的功能强大，因为计算机的所有数据都是二进制的，但问题是，如果使用字节流来处理文本文件，需要使用合适的方式把字节转换成字符，增加了编程难度。所以一个规则是：如果进行输入输出的数是文本文件，则考虑使用字符流，如果是二进制内容，考虑字节流。</p>
<h2 id="计算机的文件分类">计算机的文件分类</h2>
<p>计算机文件通常分为二进制文件和文本文件两类，所有能用记事本打开并且可以看到字符内容的文件都是文本文件，反之则是二进制文件。实际上，计算机里所有文件都是二进制文件，文本文件只是二进制的一种特例。当二进制的内容刚好能被正常解析成文本，该二进制文件就变成了文本文件。如果要看到正常的文本内容，则必须在打开文件时与保存文件时使用相同的字符集，Windows系统简体中文默认使用GBK字符集，Linux系统默认使用UTF-8字符集。</p>
<h2 id="转换流">转换流</h2>
<p>输入/输出体系提供了两个转换流InputStreamReader
、OutputStreamWriter，用于将字节流转换为字符流，一个将字节输入流转换为字符输入流，一个将字节输出流转换为字符输出流。</p>
<p>Java没有提供将字符流转换为字节流的类。</p>
<p>Java使用System.in代表标准输入，但这个标准输入流是InputStream类的实例，使用不方便，而且键盘输入都是文本内容，所以可以使用InputStreamReader将其转换为字符输入流，普通的Reader读取输入内容依然不太方便，可以将Reader再次包装成BufferedReader，利用BufferedReader的readLine()方法可以一次性读取一行。</p>
<p>如下程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KeyinTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 将Sytem.in对象转换成Reader对象</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in);</span><br><span class="line">			<span class="comment">// 将普通Reader包装成BufferedReader</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">			<span class="comment">// 采用循环方式来一行一行的读取</span></span><br><span class="line">			<span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 如果读取的字符串为&quot;exit&quot;，程序退出</span></span><br><span class="line">				<span class="keyword">if</span> (line.equals(<span class="string">&quot;exit&quot;</span>))</span><br><span class="line">				&#123;</span><br><span class="line">					System.exit(<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 打印读取的内容</span></span><br><span class="line">				System.out.println(<span class="string">&quot;输入内容为:&quot;</span> + line);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="推回输入流">推回输入流</h2>
<p>有两个特殊的类，就是PushbackInputStream和PushbackReader，他们都提供了三个方法：</p>
<p><strong>void unread(byte[]/char[] buf)</strong></p>
<p>功能：将一个字节/字符数组推回到缓冲区里，从而允许重复读取内容。</p>
<p>参数：</p>
<ul>
<li>byte[]/char[] buf:需要推回的字节/字符数组；</li>
</ul>
<p>返回值：无</p>
<hr />
<p><strong>void unread(byte[]/char[] buf, int off, int len)</strong></p>
<p>功能：将一个字节/字符数组从off开始，长度为len字节/字符的内容推回到缓冲区里，从而允许重复读取内容。</p>
<p>参数：</p>
<ul>
<li>byte[]/char[] buf:需要推回的字节/字符数组；</li>
<li>off：需要推回内容的开始位置；</li>
<li>len:推回内容的长度</li>
</ul>
<p>返回值：无</p>
<hr />
<p><strong>void unread(int b)</strong></p>
<p>功能：将一个字节/字符推回到缓冲区里，从而允许重复读取内容。</p>
<p>参数：</p>
<ul>
<li>b:需要推回的字节/字符；</li>
</ul>
<p>返回值：无</p>
<hr />
<p>这两个推回输入流都带有一个推回缓冲区，当程序调用这两个推回输入流的unread()方法时，系统会把指定内容推回该缓冲区，而推回输入流每次调用read()方法时，总是先从推回缓冲区读取，只有完全读取了推回缓冲区的内容以后，才会从原输入流读取。</p>
<p>创建推回输入流实例需要指定缓冲区大小，默认缓冲区长度为1，如果推回缓冲区内容超过缓冲区大小，会引发异常。</p>
<p>下面程序找出程序的"new
PushbackReader"字符串，找到后，程序打印目标字符串之前的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PushbackTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建一个PushbackReader对象，指定推回缓冲区的长度为64</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">pr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PushbackReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(</span><br><span class="line">				<span class="string">&quot;PushbackTest.java&quot;</span>), <span class="number">64</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">32</span>];</span><br><span class="line">			<span class="comment">// 用以保存上次读取的字符串内容</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">lastContent</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">			<span class="type">var</span> <span class="variable">hasRead</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="comment">// 循环读取文件内容</span></span><br><span class="line">			<span class="keyword">while</span> ((hasRead = pr.read(buf)) &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 将读取的内容转换成字符串</span></span><br><span class="line">				<span class="type">var</span> <span class="variable">content</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, hasRead);</span><br><span class="line">				<span class="type">var</span> <span class="variable">targetIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 将上次读取的字符串和本次读取的字符串拼起来，</span></span><br><span class="line">				<span class="comment">// 查看是否包含目标字符串, 如果包含目标字符串</span></span><br><span class="line">				<span class="keyword">if</span> ((targetIndex = (lastContent + content)</span><br><span class="line">					.indexOf(<span class="string">&quot;new PushbackReader&quot;</span>)) &gt; <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 将本次内容和上次内容一起推回缓冲区</span></span><br><span class="line">					pr.unread((lastContent + content).toCharArray());</span><br><span class="line">					<span class="comment">// 重新定义一个长度为targetIndex的char数组</span></span><br><span class="line">					<span class="keyword">if</span> (targetIndex &gt; <span class="number">32</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						buf = <span class="keyword">new</span> <span class="title class_">char</span>[targetIndex];</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 再次读取指定长度的内容（就是目标字符串之前的内容）</span></span><br><span class="line">					pr.read(buf, <span class="number">0</span>, targetIndex);</span><br><span class="line">					<span class="comment">// 打印读取的内容</span></span><br><span class="line">					System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, targetIndex));</span><br><span class="line">					System.exit(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 打印上次读取的内容</span></span><br><span class="line">					System.out.print(lastContent);</span><br><span class="line">					<span class="comment">// 将本次内容设为上次读取的内容</span></span><br><span class="line">					lastContent = content;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (IOException ioe)</span><br><span class="line">		&#123;</span><br><span class="line">			ioe.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/15/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><span class="page-number current">16</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/17/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhaoXin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
