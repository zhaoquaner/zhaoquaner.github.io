<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhaoquaner.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="赵圈儿的博客">
<meta property="og:url" content="https://zhaoquaner.github.io/page/17/index.html">
<meta property="og:site_name" content="赵圈儿的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ZhaoXin">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhaoquaner.github.io/page/17/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/17/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>赵圈儿的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">赵圈儿的博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">23</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">169</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZhaoXin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">169</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E9%9B%86%E5%90%88/Set%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E9%9B%86%E5%90%88/Set%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Set集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:07:39 / 修改时间：16:53:37" itemprop="dateCreated datePublished" datetime="2022-05-11T09:07:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Set集合不允许元素重复，如果向Set集合添加一个已经存在的元素，则会添加失败</p>
<h2 id="hashset类">HashSet类</h2>
<p>HashSet类是Set接口典型实现，大多时候使用Set时就是使用这个，HashSet按Hash算法来存储集合中的元素，因此存取和查找性能很好。</p>
<p>几个特点</p>
<ul>
<li>不保证元素的排列顺序，顺序可能与添加顺序不一致</li>
<li>HashSet不是同步的，如果有多个线程访问同一个HashSet，假设有两个或以上的线程同时修改了HashSet集合，必须通过代码保证同步</li>
<li><strong>集合元素值可以是null</strong></li>
</ul>
<p>当向HashSet集合添加元素时，HashSet会调用该对象的hashcode()方法得到hashcode值，然后依据这个值来决定存储位置，<strong>如果有两个元素通过equals方法比较返回true，但是hashcode()方法返回值不相等，HashSet会把它们存储在不同位置，依然可以添加成功。</strong></p>
<p>即HashSet集合判断元素是否相等的标准是equals方法返回相等，并且hashcode()方法返回值也相等。</p>
<p>那么如果要重写对象对应类的equals方法，也应该重写对应的hashcode()方法，规则是：<strong>如果两个对象通过equals方法返回true，那么hashcode()也应该返回值也应该相同。</strong></p>
<p>HashSet集合每一个能存储元素的位置通常称为“桶”，如果多个元素的hashcode值相等，但是equals方法返回false，那么就需要在一个“桶”里放多个元素，这会导致性能下降。</p>
<p>重写hashcode方法的基本原则</p>
<ul>
<li>程序运行时，同一个对象多次调用hashcode()方法应该返回相同的值</li>
<li>两个对象通过equals比较返回true时，hashcode值也应该相同</li>
<li><strong>对象中用作equals方法比较标准的实例变量，也应该用于计算hashcode值</strong></li>
</ul>
<p>重写hashcode方法的一般步骤</p>
<ol type="1">
<li><p>把对象内每个有意义的实例变量计算出一个int类型的hashcode值</p></li>
<li><p>用第一步算出来的多个hashcode值组合成一个hashcode值返回</p>
<p>为了避免直接相加产生偶然相等，可以使各实例变量的hashcode值乘以任意一个质数</p></li>
</ol>
<p><strong>当把可变对象添加到HashSet中之后，不要再去修改该集合元素参与运算hashcode()、equals方法的实例变量</strong>，否则会导致HashSet无法正确操作这些集合元素。</p>
<h3 id="linkedhashset类">LinkedHashSet类</h3>
<p>它是HashSet类的子类，LinkedHashSet集合也使用hashcode值来决定存储位置，但它同时使用链表维护元素的次序，当遍历LinkedHashSet集合的元素时，LinkedHashSet会按元素的添加顺序来访问集合元素。</p>
<p>LinkedHashSet需要维护元素插入顺序，所以性能略低于HashSet性能</p>
<p><strong>注意：虽然使用链表来维护内部顺序，但是LinkedHashSet依然不允许元素重复。</strong></p>
<h2 id="treeset类">TreeSet类</h2>
<p>TreeSet类是SortedSet接口的实现类，TreeSet可以保证集合元素处于排序状态，与HashSet相比，TreeSet还提供了几个额外方法</p>
<ul>
<li><p><strong>Comparator
comparator()</strong>：如果TreeSet采用了定制排序，则该方法返回定制排序所使用的Comparator，如果TreeSet使用了自然排序，则返回null</p></li>
<li><p><strong>Object first()</strong>：返回集合第一个元素</p></li>
<li><p><strong>Object last()</strong>：返回集合最后一个元素</p></li>
<li><p><strong>Object lower(Object
e)</strong>：返回集合中位于指定元素e之前的元素(即小于指定元素e的最大元素，e不一定是TreeSet里的元素)</p></li>
<li><p><strong>Object higher(Object
e)</strong>：返回集合中位于指定元素e之后的元素(即大于指定元素e的最小元素，e不一定是TreeSet里的元素)</p></li>
<li><p><strong>SortedSet subSet(Object fromElement, Object
toElement)</strong>：返回此Set的子集合，返回从formElement(包含)到toElement(不包含)</p></li>
<li><p><strong>SortedSet headSet(Object
toElement)</strong>：返回此Set的子集合，由小于toElement的元素组成</p></li>
<li><p><strong>SortedSet tailSet(Object
fromElement)</strong>：返回此Set的子集合，由大小或等于romElement的元素组成</p></li>
</ul>
<p>TreeSet支持两种排序方式：自然排序、定制排序</p>
<p>默认情况，TreeSet使用自然排序。</p>
<h3 id="自然排序">自然排序</h3>
<p>TreeSet会调用元素的compareTo(Object
obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种方式就是自然排序。</p>
<p>Java提供了一个Comparable接口，<strong>该接口定义了一个compareTo(Object
obj)方法，该方法返回一个整数值，若该对象大于obj对象，返回正整数，小于obj对象返回负整数，等于返回0</strong></p>
<p>实现了该接口才可以比较大小，也才可以把对应类的对象放入TreeSet集合中</p>
<p>实现了Comparaable接口的常用类</p>
<ul>
<li>BigDecimal，BigInteger以及所有数组型对应的包装类</li>
<li>Character：按字符Unicode值进行比较</li>
<li>Boolean：true对应包装类实例大于false对应包装类实例</li>
<li>String：依次比较字符串每个字符的Unicode值</li>
<li>Date、Time：后面的时间大于前面的时间</li>
</ul>
<p><strong>注意：因为只有相同类的实例才会比较大小，所有向TreeSet中添加的元素应该是同一类的对象，否则会抛出ClassCastException异常。</strong></p>
<p><strong>对于TreeSet来说，判断两个对象相等的唯一方法就是调用对象的compareTo()方法，返回0，则相等，否则不相等</strong></p>
<p><strong>当判断相等时，TreeSet无法把元素添加到集合中。</strong></p>
<p>这里应该注意一个问题，当重写该对象对应类的equals方法时，应该保证该方法与compareTo(Object
obj)方法有一致的结果，即<strong>如果两个对象通过equals方法返回相等时，这两个对象通过compareTo方法也应该返回0。</strong></p>
<p><strong>不要修改放入HashSet和TreeSet集合中元素的关键实例变量。</strong></p>
<h3 id="定制排序">定制排序</h3>
<p>如果需要实现定制排序，则可以通过<strong>Comparator</strong>接口的帮助，该接口包含一个<strong>int
compare(T o1, T
o2)</strong>方法，如果o1大于o2，返回正整数，o1小于o2返回负整数，相等返回0</p>
<p>如果要实现定制排序，则在创建TreeSet集合对象时，需要提供一个Comparator对象与该集合关联，Comparator是一个函数式接口，可以用Lambda表达式来代替Comparator对象。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">M</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">M</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;M [age:&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest4</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 此处Lambda表达式的目标类型是Comparator</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">ts</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeSet</span>((o1, o2) -&gt;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">m1</span> <span class="operator">=</span> (M) o1;</span><br><span class="line">			<span class="type">var</span> <span class="variable">m2</span> <span class="operator">=</span> (M) o2;</span><br><span class="line">			<span class="comment">// 根据M对象的age属性来决定大小，age越大，M对象反而越小</span></span><br><span class="line">			<span class="keyword">return</span> m1.age &gt; m2.age ? -<span class="number">1</span></span><br><span class="line">				: m1.age &lt; m2.age ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">		&#125;);</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(<span class="number">5</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(-<span class="number">3</span>));</span><br><span class="line">		ts.add(<span class="keyword">new</span> <span class="title class_">M</span>(<span class="number">9</span>));</span><br><span class="line">		System.out.println(ts);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：使用定制排序时，依然不能向TreeSet集合添加不同类的对象，否则会引发异常。</strong></p>
<h2 id="enumset类">EnumSet类</h2>
<p>EnumSet是一个专为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或者隐式的指定，EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类里定义顺序来决定集合元素的顺序。</p>
<p><strong>EnumSet集合不允许添加null元素</strong>。</p>
<p>EnumSet没有暴露任何构造器，程序应该用它提供的类方法来创建EnumSet对象</p>
<ul>
<li><strong>EnumSet allOf(Class
elementType)</strong>：创建一个包含指定枚举类所有枚举值的EnumSet集合</li>
<li><strong>EnumSet complementOf(EnumSet
s)</strong>：创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，该集合包含原EnumSet集合不存在的、枚举类剩下的枚举值(新EnumSet集合和旧EnumSet集合加起来就是枚举类所有的枚举值)</li>
<li><strong>EnumSet copyOf(Collection
c)</strong>：使用一个普通集合来创建EnumSet集合,要求Collection所有元素必须是同一枚举类的枚举值</li>
<li><strong>EnumSet copyOf(EnumSet
s)</strong>：创建一个与指定EnumSet具有相同类型相同集合元素的EnumSet集合</li>
<li><strong>EnumSet noneOf(Class
elementType)</strong>：创建一个元素类型为指定枚举类型的空EnumSet</li>
<li><strong>EnumSet of(E
first,E....rest)</strong>：创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必须属于同一个枚举类</li>
<li><strong>EnumSet range(E from, E
to)</strong>：创建一个从from枚举值到to枚举值范围内所有枚举值的EnumSet集合</li>
</ul>
<h2 id="各set实现类的性能分析">各Set实现类的性能分析</h2>
<p>HahsSet的性能总是比TreeSet好(特别是常用的添加查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护元素次序，只有需要一个保持排序的Set时，才需要TreeSet，否则都应该用HashSet</p>
<p>LinkedHashSet需要维护链表，所有也比HashSet性能差一点，但遍历集合会更快</p>
<p>Set的三个实现类都是线程不安全的，如果有多个线程访问该集合，并且超过一个线程修改了该Set集合，则必须手动保证该Set集合的同步性。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E9%9B%86%E5%90%88/Queue%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E9%9B%86%E5%90%88/Queue%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Queue集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:06:39 / 修改时间：16:53:35" itemprop="dateCreated datePublished" datetime="2022-05-11T09:06:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Queue用于模拟队列这种数据结构，Queue接口定义了几个方法</p>
<ul>
<li><strong>void add(Object e)</strong>：将指定元素加入到队列尾部</li>
<li><strong>boolean offer(Object
e)</strong>：将指定元素添加到队列尾部，当使用容量有限的队列时，此方法比add更好一些</li>
<li><strong>Object
element()</strong>：获取队列头部的元素，但是不删除该元素</li>
<li><strong>Object
peek()</strong>：获取队列头部元素,但是不删除该元素，如果队列为空，返回null</li>
<li><strong>Object
poll()</strong>：获取队列头部元素，并删除该元素，如果队列为空，返回null</li>
<li><strong>Object
remove()</strong>：获取队列头部元素，并删除该元素</li>
</ul>
<p>Queue接口有一个PriorityQueue实现类。除此之外Queue还有一个Deque子接口，Deque代表一个双端队列，可以从两端增加、删除元素，因此Deque的实现类既可以当成队列使用，也可以当成栈来使用。Deque有ArrayDeque和LinkedList两个实现类。</p>
<h2 id="priorityqueue实现类">PriorityQueue实现类</h2>
<p>PriorityQueue是一个比较标准的队列实现类，之所以说是比较标准，而不是绝对标准，<strong>是因为PriorityQueue保存队列元素并不是按加入队列的顺序，而是按队列元素的大小重新排序。</strong>因此当使用peek或者poll取出队列元素时，并不是取出最先进入的元素，而是最小的元素。从这个意义上看，PriorityQueue已经违反了队列的最基本原则：先入先出</p>
<p><strong>PriorityQueue不允许插入null元素</strong></p>
<p>PriorityQueue有两种排序方式，自然排序和定制排序。和TreeSet一样，在这里不重复。</p>
<h2 id="deque接口和arraydeque实现类">Deque接口和ArrayDeque实现类</h2>
<p>Deque接口是Queue的子接口，它代表一个双端队列，有一些操作元素的方法</p>
<ul>
<li><p><strong>void addFirst(Object
e)</strong>：将指定元素插入到双端队列的开头</p></li>
<li><p><strong>boolean offerFirst(Object
e)</strong>：将指定元素插入到该队列的开头</p></li>
<li><p><strong>void addLast(Object
e)</strong>：将指定元素插入到双端队列的末尾</p></li>
<li><p><strong>boolean offerLast(Object
e)</strong>：将指定元素插入到该队列的末尾</p></li>
<li><p><strong>Iterator
descendingIterator()</strong>：返回该双端队列对应的迭代器，它将以逆向顺序迭代队列</p></li>
<li><p><strong>Object
getFirst()</strong>：获取但不删除队列第一个元素</p></li>
<li><p><strong>Object
getLast()</strong>：获取但不删除队列的最后一个元素</p></li>
<li><p><strong>Object
peekFirst()</strong>：获取但不删除该队列的第一个元素，如果队列为空，返回null</p></li>
<li><p><strong>Object
peekLast()</strong>：获取但不删除该队列的最后一个元素，如果队列为空，返回null</p></li>
<li><p><strong>Object
pollFirst()</strong>：获取并且删除该队列的第一个元素，如果队列为空，返回null</p></li>
<li><p><strong>Object
pollLast()</strong>：获取并且删除该队列的最后一个元素，如果队列为空，返回null</p></li>
<li><p><strong>Object pop()
(栈方法)</strong>：弹出该栈的栈顶元素，相等于removeFirst()</p></li>
<li><p><strong>Object push(Object e)
(栈方法)</strong>：将元素e放入栈的栈顶，相等于addFirst()</p></li>
<li><p><strong>Object
removeFirst()</strong>：获取并删除该双端队列第一个元素</p></li>
<li><p><strong>Object removeFirstOccurence(Object
e)</strong>：删除该双端队列的第一次出现元素o</p></li>
<li><p><strong>Object
removeLast()</strong>：获取并删除该双端队列最后一个元素</p></li>
<li><p><strong>Object removeLastOccurence(Object
e)</strong>：删除该双端队列的最后一次出现元素o</p></li>
</ul>
<p>Deque接口提供了一个典型实现类：ArrayDeque，它是一个基于数组实现的双端队列，创建Deque时可以指定numElements参数，如果不指定，默认为16</p>
<p><strong>Tips：ArrayList和ArrayDeque两个集合类实现机制基本类似，底层都使用一个动态的、可重分配的Object[]数组来存储集合元素，当超出数组容量时，系统会在底层重新分配一个Object[]数组来存储集合元素。</strong></p>
<h2 id="linkedlist实现类">LinkedList实现类</h2>
<p>LinkedList实现类是List接口的实现类,意味着它是一个List集合，可以根据索引随机访问集合中的元素，除此之外LinkedList还实现了Deque接口，可以被当成双端队列来使用。</p>
<p>LinkedList可以作为List集合、双端队列、栈来使用，说明LinkedList是一个功能很强大的集合类。</p>
<p>LinkedList内部以链表的方式保存元素，在随意访问集合元素时性能较差，但插入和删除时性能出色。</p>
<h2 id="各种线性表的性能分析">各种线性表的性能分析</h2>
<p>数组使用连续内存区保存元素，因此在随即访问时性能最好，而内部以链表实现的集合在执行插入和删除时有较好性能。</p>
<p>但是总体来说，ArrayList比LinkedList性能更好，因此大部分时候都使用ArrayList</p>
<p>关于使用List集合有如下建议</p>
<ul>
<li>如果需要遍历List集合，对于ArrayList、Vector集合，应该使用随机访问(get)来遍历集合元素，这样性能更好，对于LinkedList集合，采用迭代器Iterator遍历更好</li>
<li>如果需要经常执行插入删除操作，可以考虑使用LinkedList集合</li>
<li>如果有多个线程需要同时访问List集合中的元素，可以考虑使用Collections将集合包装成线程安全的集合。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E9%9B%86%E5%90%88/Map%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E9%9B%86%E5%90%88/Map%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">Map集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:05:39 / 修改时间：16:53:33" itemprop="dateCreated datePublished" datetime="2022-05-11T09:05:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Map集合用于保存具有映射关系的数据，因此Map集合保存两组值，一组是Map里的key，一组是Map里的value。两者都可以是任何引用类型的数据，<strong>key不允许重复，即同一个Map对象的任意两个key通过equals方法比较总是返回false。</strong></p>
<p>如果把Map里所有key放在一起，他们就组成了一个Set集合(没有顺序，不能重复)。</p>
<p>Map有时候有人被称为字典或者关联数组。</p>
<p>Map类提供了一个Entry内部类来封装key-value对。</p>
<p>Map定义了以下方法：</p>
<p><strong>void clear</strong>：删除所有key-value对</p>
<p><strong>boolean
containsKey()</strong>：查询Map中是否包含指定key，包含返回true</p>
<p><strong>boolean
containsValue()</strong>：查询Map中是否包含一个或多个value，包含返回true</p>
<p><strong>Set
entrySet()</strong>：返回Map中包含的key-value对所组成的Set集合，每个集合元素是一个Map.Entry对象</p>
<p><strong>Set keySet()</strong>：返回该Map中所有key组成的Set集合</p>
<p><strong>Object get(Object
key)</strong>：返回指定key对应的value，如果此Map中不包含该key，返回null</p>
<p><strong>boolean
isEmpty()</strong>：查询该Map是否为空，如果为空返回true</p>
<p><strong>Object put(Object key, Object
value)</strong>：添加一个key-value对，如果当前Map中有一个与该key相等的key-value对，则
新的会覆盖旧的</p>
<p><strong>void putAll(Map
m)</strong>：将指定Map中所有的key-value对复制到本Map中</p>
<p><strong>Object remove(Object
key)</strong>：删除指定key对应的key-value对，并返回，如果不存在返回null</p>
<p><strong>boolean remove(Object key, Object
value)</strong>：删除指定key和value对应的key-value对，删除成功返回true</p>
<p><strong>int size()</strong>：返回该Map里的key-value对的个数</p>
<p><strong>Collection
values()</strong>：返回该Map里所有value组成的Collection</p>
<hr />
<p>Java 8新增方法</p>
<p><strong>Object compute(Object key, BiFunction
remappingFunction)</strong></p>
<p>该方法使用remappingFunction根据原来的key-value对计算出一个新的value。只要新value不为null，就使用新value覆盖旧value，返回新value；如果原value不为null，但新value为null，则删除原来key-value对，并返回null；如果原来(即不存在指定的key)、新的value都为null，就不改变任何key-value对，直接返回null。</p>
<hr />
<p><strong>Object computeIfAbsent(Object key, Function
remappingFunction)</strong></p>
<p><strong>如果传给该方法的key对应value为null，即Map集合不存在此key</strong>，则根据key计算一个新的value，如果新value不为null，则替换旧value，并返回新value；如果新value为null，则删除原key-value对，直接返回null。(<strong>如果指定key对应value不为null，直接返回对应value</strong>)</p>
<hr />
<p><strong>Object computeIfPresent(Object key, BiFunction
remappingFunction)</strong></p>
<p><strong>如果传给该方法key参数在Map对应value不为null，即Map集合存在该key</strong>，则该方法会用remappingFunction根据原key，value计算一个新value，如果计算结果不为null，则替换原来value，如果为null，则删除原来key-value对。(<strong>如果传给方法的key对应value为null，即Map集合不存在value则直接返回nul</strong>l)</p>
<hr />
<p><strong>void forEach(BiConsumer action)</strong></p>
<p>该方法可以更简洁遍历Map的key，value对。</p>
<hr />
<p><strong>Object getOrDefault(Object key, V defaultValue)</strong></p>
<p>获取指定key对应value，如果key不存在，返回defaultValue</p>
<hr />
<p><strong>Object merge(Object key, Object value, BiFunction
remappingFunction)</strong></p>
<p>该方法会先根据key参数获取该Map中对应的value，如果获取的value为null，则直接用传入的value覆盖原来的value，即添加一组新的key-value对；
如果获取的value不为null，则使用remappingFunction根据原value和新value计算新的结果，并覆盖原来value。</p>
<hr />
<p><strong>Object putIfAbsent(Object key, Object value)</strong></p>
<p>该方法会自动检测指定key对应的value是否为null，如果为null，则会用新的value替换旧的value。并返回null，如果对应value不为空，则返回对应value。</p>
<hr />
<p><strong>Object replace(Object key, Object value)</strong></p>
<p>将Map中指定的key对应的value替换成新的value，并返回旧的value。与传统put方法不同，如果不存在指定的key，那么不会添加新key-value对，而是直接返回null</p>
<hr />
<p><strong>boolean replace(K key, V oldValue, V newValue)</strong></p>
<p>将Map中指定key-value对的原value替换成新value，如果找到指定key-value对，则执行替换并返回true，否则返回false</p>
<hr />
<p><strong>void replaceAll(BiFunction function)</strong></p>
<p>使用function对原来的每组key-value对执行计算，并将计算结果作为该key-value对的value值</p>
<hr />
<p>Entry是Map类的内部类，包含三个方法</p>
<ul>
<li><strong>Object getKey()</strong>：返回该Entry里包含的key值</li>
<li><strong>Object getValue()</strong>：返回该Entry里包含的value值</li>
<li><strong>Object setValue(V
value)</strong>：设置该Entry里包含的value，并返回新设置的value值</li>
</ul>
<h2 id="hashmap和hashtable实现类">HashMap和Hashtable实现类</h2>
<p>HashMap和Hashtable都是Map接口的典型实现类，他们之间的关系类似于ArrayList和Vector。Hahstable是一个古老的Map实现类。尽量少使用Hahstable类。</p>
<p>HashMap和Hashtable有几个典型区别</p>
<ul>
<li>Hahstable是线程安全的，HashMap不是</li>
<li>Hashtable不允许使用null作为key或者value，但HahsMap允许。</li>
</ul>
<p>由于HashMap里的key不允许重复，所以HashMap最多有一个key-value对的key为null，但可以由无数多个key-value对的value为null。</p>
<p>HashMap和Hashtable不能保证其中key-value对的顺序。</p>
<p>HashMap和Hashtable判断两个key相等的标准是：两个key通过equals方法返回true，且hashcode值相同。</p>
<p>HashMap保存key的方式和HashSet保存集合元素的方式一样，所以都有同样的要求，即重写对应类的equals方法和hashcode时，应保持一致。</p>
<h2 id="linkedhashmap实现类">LinkedHashMap实现类</h2>
<p>LinkedHashMap实现类是HashMap的子类，LinkedHashMap实现类使用双向链表来维护key-value对的顺序，该链表负责维护Map的迭代顺序，这与插入顺序一致。</p>
<p>LinkedHashMap实现类因为使用链表来维护元素插入顺序，性能略低于HashMap，但在迭代访问所有元素时，有较好的性能。</p>
<h2 id="使用properites类读写属性文件">使用Properites类读写属性文件</h2>
<p>Properites类是Hashtable的子类，该对象在处理属性文件时很方便，Windows操作系统的ini文件就是一种属性文件。</p>
<p>Properites类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入属性文件，也可以把属性文件的”属性名=属性值“加载到Map对象中。由于属性文件的属性名和属性值都只能是字符串类型，所以Properites类的key和value都是字符串类型。</p>
<p>其实，Properites相当于一个key、value都是String的Map。</p>
<p>Properites类提供了几个方法</p>
<ul>
<li><strong>String getProperty(String
key)</strong>：获取Properites中指定属性名的属性值，类似于Map的get(Object
key)方法</li>
<li><strong>String getProperty(String key, String
defaultValue)</strong>：该方法与前一个基本类似，多一个功能是如果Properites中不存在指定key，则返回defaultValue</li>
<li><strong>Object setProperty(String key, String
value)</strong>：设置属性值</li>
<li><strong>void load(InputStream
inStream)</strong>：从属性文件中加载key-value对，把加载到的key-value对追加到Properites中</li>
<li><strong>void store(OutputStream out, String
comments)</strong>：将Properites中的key-value对输出到指定的属性文件中</li>
</ul>
<h2 id="sortedmap接口和treemap实现类">SortedMap接口和TreeMap实现类</h2>
<p>SortedMap接口有一个TreeMap实现类,TreeMap就是一个红黑树数据结构，每个key-value对作为一个节点，根据key对节点进行排序。</p>
<p>TreeMap有两种排序方式。</p>
<ul>
<li>自然排序：TreeMap的所有key必须实现Comparable接口，该对象负责对TreeMap中所有的key进行排序，否则会抛出异常</li>
<li>定制排序：创建TreeMap时，传入一个Compatator对象，来负责对所有key进行排序，采用定制排序不要求Map的key实现Comparable接口</li>
</ul>
<p>如果使用自定义类作为TreeMap的key，则重写该类的equals方法和comnpareTo方法时，应保持一致的结果。</p>
<p>TreeMap提供了一系列根据key顺序访问key-value对的方法</p>
<ul>
<li><strong>Map.Entry
firstEntry()：</strong>返回该Map中最小key对应的key-value对，如果Map为空，返回null</li>
<li><strong>Map.Entry
lastEntry()：</strong>返回该Map中最大key对应的key-value对，如果Map为空，返回null</li>
<li><strong>Map.Entry higherEntry()
：</strong>返回该Map中位于key后一位的key-value对(即大于指定key的最小key对应的key-value对)，如果Map为空，返回null</li>
<li><strong>Map.Entry
lowerEntry()：</strong>返回该Map中位于key前一位的key-value对(即小于指定key的最大key对应的key-value对)，如果Map为空，返回null</li>
<li><strong>Object
firstKey()：</strong>返回该Map中最小的key值，如果该Map为空，返回null</li>
<li><strong>Object
lastKey()：</strong>返回该Map中最大的key值，如果该Map为空，返回null</li>
<li><strong>Object
higherKey()：</strong>返回该Map中位于key后一位的key值(即大于指定key的最小key值)，如果该Map为空，返回null</li>
<li><strong>Object
lowerKey()：</strong>返回该Map中位于key前一位的key值(即小于指定key值的最大key值)，如果该Map为空，返回null</li>
<li><strong>NavigableMap subMap(Object fromKey, boolean fromInclusive,
Object toKey, boolean
toInclusive)</strong>：返回该Map的子Map，其key的范围是从fromKey到toKey,是否包含两个边界取决于每个参数后面的布尔参数</li>
<li><strong>SortedMap subMap(Object fromKey, Object
toKey)：</strong>返回该Map的子Map，其key的范围是从fromKey(包括)到toKey(不包括)</li>
<li><strong>SortedMap tailMap(Object
fromKey)：</strong>返回该Map的子Map，其key的范围是大于fromKey(包括)的所有key</li>
<li><strong>NavigableMap tailMap(Object fromKey, boolean
fromInclusive)</strong>：返回该Map的子Map，其key的范围是大于fromKey(是否包含取决于第二个参数)的所有key</li>
<li><strong>SortedMap headMap(Object
toKey)</strong>：返回该Map的子Map，其key的范围是小于toKey(不包括)的所有key</li>
<li><strong>NavigableMap headMap(Object toKey, boolean
inclusive)</strong>：返回该Map的子Map，其key的范围是小于toKey(是否包含取决于第二个参数)的所有key</li>
</ul>
<h2 id="weakhashmap实现类">WeakHashMap实现类</h2>
<p>WeakHashMap实现类和HashMap的用法基本相似，与HashMap的区别在于，HashMap的key保留了对实际对象的强引用，这意味着只要该HashMap对象不被销毁，该HashMap的所有key所饮用的对象就不会被垃圾回收，HashMap也不会自动删除这些key对应的key-value对，但WeakHashMap的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除这些key对应的key-value对</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">Map</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>();</span><br><span class="line"></span><br><span class="line">                a.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;语文&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;良好&quot;</span>));</span><br><span class="line">                a.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;数学&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;及格&quot;</span>));</span><br><span class="line">                a.put(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;英语&quot;</span>), <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;中等&quot;</span>));</span><br><span class="line"></span><br><span class="line">                a.put(<span class="string">&quot;物理&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;超级棒的&quot;</span>));</span><br><span class="line"></span><br><span class="line">                System.out.println(a);</span><br><span class="line"></span><br><span class="line">                System.gc();</span><br><span class="line"></span><br><span class="line">                System.runFinalization();</span><br><span class="line"></span><br><span class="line">                System.out.println(a);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure>
<img
src="D:\各种文档\个人文档\学习总结\Java\集合\image\image-20200504180133511.png"
alt="image-20200504180133511" />
<figcaption aria-hidden="true">image-20200504180133511</figcaption>
</figure>
<p>可以看出，当进行垃圾回收时，删除了WeakHashMap对象的前三个key-value对，因为添加前三个时，三个key都是匿名的字符串对象，WeakHashMap只保留了对他们的弱引用，这样垃圾回收时会自动删除。</p>
<p>WeakHashMap对象的第四个key-value对的key是一个字符串直接量，系统会使用缓冲池保留对该字符串对象的强引用，所以垃圾回收时不会回收它。</p>
<h2 id="identityhashmap实现类">IdentityHashMap实现类</h2>
<p>这个Map实现类的机制和HashMap基本相似，但它在处理两个key相等时比较独特，在IdentityHashMap中，仅当两个key严格相等(key1
== key2)时，IdentityHashMap才会认为他们相等。</p>
<p>对于普通的HashMap，只要key1和key2通过equals方法返回true并且hashcode值相等即可。</p>
<h2 id="enummap实现类">EnumMap实现类</h2>
<p>EnumMap是一个和枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值，创建EnumMap时必须显式或者隐式的指定它对应的枚举类，EnumMap具有如下特征</p>
<ul>
<li>EnumMap在内部以数组形式保存，这种实现形式紧凑高效</li>
<li>EnumMap根据key的自然顺序(即枚举值在枚举类的定义顺序)来维护key-value对的顺序</li>
<li>EnumMap不允许以null作为key，但允许使用null作为value，</li>
</ul>
<h2 id="各map实现类的性能分析">各Map实现类的性能分析</h2>
<p>对于Map常用实现类来说，HashMap和Hashtable实现机制几乎一样，但是由于Hashtable是一个古老的线程安全的集合，所以HashMap比Hashtable要快</p>
<p>TreeMap通常比HashMap和Hashtable要慢，因为TreeMap使用红黑树来维护key-value对的顺序。</p>
<p>对于一般的应用场景，程序应该多考虑使用HashMap。</p>
<p>LinkedHashMap比HashMap慢一点，因为它需要链表来维护顺序。</p>
<p>IdentityHashMap性能没有出色之处，只是它使用==而不是equals方法来判断元素相等</p>
<h2 id="section"></h2>
<h2 id="hashset和hashmap的性能选项">HashSet和HashMap的性能选项</h2>
<p>HashSet和HashMap都采用hash算法来绝对元素存储位置。</p>
<p>hash表中可以存储元素的位置称为"桶"，通常情况下，单个"桶"存储一个元素，此时性能是最好的。但是hash表的状态是open的，在发生hash冲突的情况下，单个桶会存储多个元素，这些元素以链表形式存储，必须按顺序存储。</p>
<p>HashSet和HashMap的hash表有一些属性</p>
<ul>
<li>容量(capacity)：hash表中桶的数量</li>
<li>初始化容量(initial
capacity)：创建hash表时桶的数量，HashSet和HashMap都允许在构造器中指定初始化容量</li>
<li>尺寸(size)：当前hash表中记录的数量</li>
<li>负载因子(load factor)：等于<strong><span
class="math inline">\(\frac{size}{capacity}\)</span>,</strong>负载因子为0，表示空的hash表。</li>
</ul>
<p>除此之外，hash表还有一个负载极限，它是一个0~1之间的数，决定了hash表的最大填满程度，当hash表的负载因子达到最顶负载极限时，hash表会自动成倍的增加容量，并将原有对象重新分配，这称为rehashing。</p>
<p>HashSet和HashMap的构造器都允许指定一个负载极限。HashSet、HashMap和Hashtable的默认负载极限时0.75。</p>
<p>较高的负载极限可以降低hash表占用的内存，但会增加查询数据的时间开销；较低的负载极限会提高查询数据的性能，但会增加内存消耗。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E9%9B%86%E5%90%88/List%E9%9B%86%E5%90%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E9%9B%86%E5%90%88/List%E9%9B%86%E5%90%88/" class="post-title-link" itemprop="url">List集合</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:04:39 / 修改时间：16:53:30" itemprop="dateCreated datePublished" datetime="2022-05-11T09:04:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>List集合代表一个元素有序可以重复的集合，每个元素有对应的顺序索引，从0开始。</p>
<p>List接口作为Collection的子接口，可以使用Collection的所有方法，除此之外，List集合还增加一个根据索引操作集合元素的方法</p>
<ul>
<li><strong>void add(int index, Object
element)</strong>：将元素插入到List集合的index处(index从0开始，例如插入第一个元素，index为0)</li>
<li><strong>boolean addAll(int index, Collection
c)</strong>：将集合c包含的所有元素都插入到List集合的index处</li>
<li><strong>Object get(int index)</strong>：返回集合index处的元素</li>
<li><strong>int indexOf(Object
o)</strong>：返回对象o在List集合第一次出现的位置索引</li>
<li><strong>int lastIndexOf(Object
o)</strong>：返回对象o在List集合中最后一次出现的位置索引</li>
<li><strong>Object remove(int
index)</strong>：删除并返回index索引处的元素</li>
<li><strong>Object set(int index, Object
element)</strong>：将List集合index位置处的元素替换成element对象，返回被替换的旧元素</li>
<li><strong>List subList(int fromIndex, int
toIndex)</strong>：返回从索引fromIndex(包括)到toIndex(不包括)处所有集合元素组成的子集合</li>
</ul>
<p>所有的List实现类都可以调用这些方法</p>
<p>Java 8为List接口增加了两个新的默认方法</p>
<ul>
<li><strong>void replaceAll(UnaryOperator
operator)</strong>：根据operator指定的计算规则重新设置List集合中的所有元素</li>
<li><strong>void sort(Comparator
c)</strong>：根据Comparator参数对List集合元素排序</li>
</ul>
<p><strong>注意：使用indexOf、lastIndexOf和remove方法时，需要在集合中匹配和给定参数相同的元素，List集合判断相等的方式是只要equals方法返回true即可</strong>。</p>
<p>sort方法需要一个Comparator对象来控制元素排序，可以用Lambda表达式；replaceAll方法需要一个UnaryOperator接口实现类，它也是一个函数式接口，可以使用Lambda表达式。</p>
<p>使用sort和replaceAll方法的例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListTest3</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">		<span class="comment">// 向books集合中添加4个元素</span></span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂iOS讲义&quot;</span>);</span><br><span class="line">		<span class="comment">// 使用目标类型为Comparator的Lambda表达式对List集合排序</span></span><br><span class="line">        <span class="comment">//字符串越长，字符串越大</span></span><br><span class="line">		books.sort((o1, o2) -&gt; ((String) o1).length() - ((String) o2).length());</span><br><span class="line">		System.out.println(books);</span><br><span class="line">		<span class="comment">// 使用目标类型为UnaryOperator的Lambda表达式来替换集合中所有元素</span></span><br><span class="line">		<span class="comment">// 该Lambda表达式控制使用每个字符串的长度作为新的集合元素</span></span><br><span class="line">		books.replaceAll(ele -&gt; ((String) ele).length());</span><br><span class="line">		System.out.println(books); <span class="comment">// 输出[7, 8, 11, 16]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>List集合额外提供了一个listIterator方法，该方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供专门操作List的方法，ListIterator还增加了一个方法</p>
<ul>
<li><strong>boolean
hasPrevious()</strong>：返回该迭代器关联的集合是否还有上一个元素</li>
<li><strong>Object previous()</strong>：返回该迭代器的上一个元素</li>
<li><strong>void add(Object o)</strong>：在指定位置插入一个元素</li>
</ul>
<h2 id="arraylist和vector实现类">ArrayList和Vector实现类</h2>
<p>ArrayList和Vector作为List接口的实现类，完全支持List接口所有的功能</p>
<p>ArrayList和Vector实现类都是基于数组实现的List类，ArrayList和Vector封装了一个动态的、允许再分配的Object[]数组，</p>
<p>ArrayList和Vector对象使用initialCapacity参数来设置该对象的长度，当向ArrayList或Vector-添加元素超过了数组长度后，它们的initialCapacity会自动增加。</p>
<p>通常来说，我们无需关注initialCapacity，但是如果向ArrayList或Vector集合添加大量元素时，可以使用ensureCapacity方法一次性增加initialCapacity，可以减少重分配的次数，提高性能。</p>
<p>如果开始就知道要存储多少元素，可以在创建时指定initialCapacity参数，<strong>如果不指定，默认长度为10。</strong></p>
<p>ArrayList和Vector提供了两个方法来重分配Object[]数组</p>
<ul>
<li><strong>void ensureCapacity(int
minCapacity)</strong>：将Object[]数组的大小增加，以确保它至少可以容纳由minCapacity参数指定的元素数。</li>
<li><strong>void
trimToSize()</strong>：调整Object[]数组长度为当前元素的个数</li>
</ul>
<p>ArrayList和Vector在用法上几乎完全相同，但是Vector是一个比较古老的集合，有一些很长的方法名，也有很多缺点，尽量少用Vector。</p>
<p>除此之外，ArrayList和Vector的一个显著区别是ArrayList是线程不安全的，程序必须手动保证该集合的同步性，Vector是线程安全的。</p>
<p>Coolections工具类可以使ArrayList变成线程安全的。</p>
<p>Vector还提供了一个子类Stack，它模拟“栈”这种数据结构，提供了几个方法</p>
<ul>
<li>Object peek():返回栈的第一个元素，但并不将该元素出栈</li>
<li>Object pop()：返回栈的第一个元素，并将该元素出栈</li>
<li>void push(Object item)：将元素入栈</li>
</ul>
<p>##　固定长度的List</p>
<p>操作数组的工具类Arrays，该工具类提供了asList(Object ...
a)方法，该方法可以把一个数组或指定个数的对象转换为一个List集合，<strong>但是这个集合List即不是ArrayList实现类的实例，也不是Vector实现类的实例，而是Arrays的内部类ArrayList的实例。</strong></p>
<p>Arrays.ArrayList是一个固定长度的List集合，程序只能遍历该集合的元素，不可以增加和删除</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E9%9B%86%E5%90%88/%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E9%9B%86%E5%90%88/%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/" class="post-title-link" itemprop="url">操作集合的工具类：Collections</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:03:39 / 修改时间：16:53:26" itemprop="dateCreated datePublished" datetime="2022-05-11T09:03:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java提供了操作Set、List和Map等集合的工具类Collections,提供了大量的方法对集合元素排序、查询修改等操作，还可以将集合元素设置为不可变，对集合对象实现同步控制。</p>
<h2 id="排序操作">排序操作</h2>
<p>常用类方法来排序</p>
<ul>
<li><strong>void reverse(List
list)</strong>：反转指定集合元素的顺序</li>
<li><strong>void shuffle(List
list)</strong>：对集合的元素进行随机排序</li>
<li><strong>void sort(List
list)</strong>：根据元素自然顺序对指定list集合的元素按升序排序</li>
<li><strong>void sort(List list, Comparator
c)</strong>：根据指定Comparator产生的顺序对List集合元素进行排序</li>
<li><strong>void swap(List list, int i, int
j)</strong>：将指定List集合中的i处元素按升序进行排序</li>
<li><strong>void rotate(List list, int
distance)</strong>：当distance为正数时，将list集合的后distance个元素整体移到前面；distance为负数时，将list集合的前distance个元素整体移到后面，该方法不会改变集合长度</li>
</ul>
<h2 id="查找替换操作">查找替换操作</h2>
<p>Collections提供的类方法用于查询替换集合元素</p>
<ul>
<li><strong>int binarySearch(List list, Object
key)</strong>：使用二分搜索法搜索指定的List集合，以获得指定对象在List集合中的索引，如果要使用此方法，则List集合元素必须已经处于有序状态</li>
<li><strong>Object max(Collection
coll)</strong>：根据元素的自然顺序，返回给定集合的最大元素</li>
<li><strong>Object max(Collection coll, Comparator
comp)</strong>：根据Comparator给定的顺序，返回给定集合中最大元素</li>
<li><strong>Object min(Collection
coll)</strong>：根据元素的自然顺序，返回给定集合的最小元素</li>
<li><strong>Object min(Collection coll, Comparator
comp)</strong>：根据Comparator给定的顺序，返回给定集合中最小元素</li>
<li><strong>void fill(List list, Object
obj)</strong>：使用指定元素替换指定集合中所有元素</li>
<li><strong>int frequency(Collection c, Object
o)</strong>：返回指定集合中指定元素出现的次数</li>
<li><strong>int indexOfSubList(List source, List
target)</strong>：返回子List对象target在父List对象source第一次出现的位置索引</li>
<li><strong>int lastIndexOfSubList(List source, List
target)</strong>：返回子List对象target在父List对象source最后一次出现的位置索引</li>
<li><strong>boolean replaceAll(List list, Object oldVal, Object
newVal)</strong>：使用一个新值替换List对象的所有旧值</li>
</ul>
<h2 id="同步控制">同步控制</h2>
<p>Collections提供了多个synchronizedXxx()方法，可以把指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>Java常用的集合框架的实现类HashSet,TreeSet, ArrayList, ArrayDeque,
LinkedList, HashMap和TreeMap都是线程不安全的。</p>
<p>可以使用<code>ArrayList a = Collections.synchronizedList(new
ArrayList());</code>将新创建的集合对象传给Collections的synchronizedXxx方法，获取对应的线程安全版本。</p>
<h2 id="java-9新增的不可变集合">Java 9新增的不可变集合</h2>
<p>以前假如要创建一个包含6个元素的Set集合，程序需要先创建Set集合，然后调用6次add()方法，Java
9进行简化，程序直接调用Set、List、Map的of()方法即可创建一个包含N个元素的不可变集合。</p>
<p>不可变集合意味着不能向集合中添加元素也不能从集合中删除元素。</p>
<p>例子：创建一个Set、List的不可变集合</p>
<p><code>var a = Set.of("java", "C", "C++");</code> <code>var b =
List.of("13, 56, 62");</code></p>
<p>上述代码分别创建了三个元素的Set集合和List集合。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%E6%8E%A5%E5%8F%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%E6%8E%A5%E5%8F%A3/" class="post-title-link" itemprop="url">Java集合概述及其遍历接口</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:02:39 / 修改时间：16:53:28" itemprop="dateCreated datePublished" datetime="2022-05-11T09:02:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>集合主要负责保存其他数据，集合和数组不一样，数组元素可以是基本类型如int，float，但集合里只能保存对象(实际保存的是对象的引用变量)。</p>
<p>Java集合类由两个接口派生而出：Collection和Map，这两个接口又包含了一些子接口和实现类。</p>
<p>继承树</p>
<p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/集合接口.png" alt="集合接口" style="zoom:100%;" /></p>
<p>大致分为四种集合：Set、List、Queue和Map</p>
<p>特点</p>
<ul>
<li>Set是无序集合，元素不能重复</li>
<li>List是有序集合，每个元素有对应索引，元素可以重复</li>
<li>Map保存的数据都是key-value对，即每项数据由两个值组成</li>
</ul>
<h2 id="collection接口">Collection接口</h2>
<p>Collection接口是List、Set和Queue接口的父接口，它包含了几个操作集合元素的方法。</p>
<ul>
<li><strong>boolean add(Object o)
</strong>：向集合添加一个元素，添加成功返回true</li>
<li><strong>boolean addAll(Collection
c)</strong>：把集合c的所有元素添加到指定集合中，如果添加成功返回true</li>
<li><strong>void clear()</strong>：清除集合所有元素</li>
<li><strong>boolean contains(Object
o)</strong>：判断集合是否包含指定元素，包含返回true</li>
<li><strong>boolean containsAll(Collection
c)</strong>：判断集合是否包含c中所有元素，是返回true</li>
<li><strong>boolean
isEmpty()</strong>：判断集合是否为空，是返回true</li>
<li><strong>Iterator
iterator()</strong>：返回一个Iterator对象，用于遍历集合元素</li>
<li><strong>boolean remove(Object
o)</strong>：从集合中删除指定元素o，如果集合包含多个元素o时，只删除第一个符合条件的元素</li>
<li><strong>boolean removeAll(Collection
c)</strong>：从集合删除集合c中不包含的元素(相等于该集合和c集合求交集)</li>
<li><strong>int size()</strong>：返回集合里元素个数</li>
<li><strong>Object[]
toArray()</strong>：该方法把集合转换成一个数组，所有集合元素变成对应数组元素</li>
</ul>
<h2 id="使用iterator遍历集合元素">使用Iterator遍历集合元素</h2>
<p>Iterator接口是Collection的父接口，Iterator接口主要用来遍历Collection集合中的元素，Iterator对象也被称为迭代器。有四个方法</p>
<ul>
<li><strong>boolean
hasNext()</strong>：如果被迭代的集合元素还没有被遍历完，返回true</li>
<li><strong>Object next()</strong>：返回集合下一个元素</li>
<li><strong>void
remove()</strong>：删除集合中上一次next方法返回的元素</li>
<li><strong>void forEachRemaining(Consumer
action)</strong>：使用Lambda表达式遍历集合元素</li>
</ul>
<p>Iterator仅仅用于遍历集合，如果需要创建Iterator对象，则必须有一个需要被迭代的集合。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IteratorTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 创建集合、添加元素的代码与前一个程序相同</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line">		<span class="comment">// 获取books集合对应的迭代器</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">it</span> <span class="operator">=</span> books.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// it.next()方法返回的数据类型是Object类型，因此需要强制类型转换</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">book</span> <span class="operator">=</span> (String) it.next();</span><br><span class="line">			System.out.println(book);</span><br><span class="line">			<span class="keyword">if</span> (book.equals(<span class="string">&quot;疯狂Java讲义&quot;</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 从集合中删除上一次next方法返回的元素</span></span><br><span class="line">				it.remove();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 对book变量赋值，不会改变集合元素本身</span></span><br><span class="line">			book = <span class="string">&quot;测试字符串&quot;</span>;   <span class="comment">// ①</span></span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(books);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用Iterator遍历集合时，Iterator并不是把集合元素本身传给迭代变量，而是把对应的值传给迭代变量，所以修改迭代变量的值对集合本身没有影响。</p>
<p>虽然remove方法可以删除集合元素，但尽量不要使用remove来删除集合元素。</p>
<h3
id="使用iterator接口的新增方法来遍历集合">使用Iterator接口的新增方法来遍历集合</h3>
<p>Iterator接口有一个默认方法forEach(Consumer
action)，该方法参数是一个函数式接口，可以使用Lambda来遍历，因为Iterator接口是Collection的父接口，所有Collection可以直接调用该方法。</p>
<p>当调用该方法时，程序会依次将集合元素传给Consumer的accept(T
t)方法。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">                c.add(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;同学&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;再见&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                c.forEach(obj-&gt;&#123;System.out.println(obj);&#125;);</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Iterator接口同样有一个forEachRemaining(Consumer
action)，该方法所需参数是函数式接口，当程序调用Iterator的该方法时，程序会把集合元素传给Consumer的accpet(T
t)方法</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">                c.add(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;同学&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;再见&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">Iterator</span> <span class="variable">a</span> <span class="operator">=</span> c.iterator();</span><br><span class="line"></span><br><span class="line">                a.forEachRemaining(obj-&gt;&#123;System.out.println(obj);&#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2
id="使用foreach循环来遍历集合元素">使用foreach循环来遍历集合元素</h2>
<p>可以直接使用for each循环来遍历集合，更加方便</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">                c.add(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;同学&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;再见&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">var</span> obj : c)</span><br><span class="line">                &#123;</span><br><span class="line">                        System.out.println(obj);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用foreach循环遍历集合时也不能修改集合元素</p>
<h2 id="使用predicate操作集合">使用Predicate操作集合</h2>
<p>Collection集合有一个removeIf(Predicate
filter)方法，该方法会批量删除符合filter条件的所有元素</p>
<p>该方法需要一个Predicate对象来作为参数，Predicate是函数式接口，可以用Lambda表达式</p>
<p>该接口中的唯一抽象方法test，如果符合filter条件，该方法返回true，否则false</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                <span class="type">var</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"></span><br><span class="line">                c.add(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;同学&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;再见&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;9dorgja[we0uf&quot;</span>);</span><br><span class="line">                c.add(<span class="string">&quot;sidufhsd&quot;</span>);</span><br><span class="line"></span><br><span class="line">                c.removeIf(e-&gt;&#123;<span class="keyword">return</span> ((String)e).length() &gt; <span class="number">10</span>;&#125;);</span><br><span class="line"></span><br><span class="line">                System.out.println(c);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码会把c集合里长度大于10的字符串删掉。</p>
<p>其中 <code>c.removeIf(e-&gt;&#123;return ((String)e).length() &gt;
10;&#125;)</code>的参数e可以用任意名称代替</p>
<p>##　使用Stream操作集合</p>
<p>Stream是一个通用流接口，IntStream,LongStream,DoubleStream则代表元素类型为int、long、double的流。</p>
<p>Java为每个流提供对应的Builder，例如Stream.Builder等等，可以用这些Builder创建对应的流</p>
<p>独立使用Stream步骤为</p>
<ol type="1">
<li>使用Stream或XxxStream的builder类方法创建对应Builder</li>
<li>重复调用Builder的add方法向该流添加元素</li>
<li>调用Builder的build方法获取对应Stream</li>
<li>调用Stream的聚集方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">                IntStream.<span class="type">Builder</span> <span class="variable">a</span> <span class="operator">=</span> IntStream.builder();</span><br><span class="line"></span><br><span class="line">                a.add(<span class="number">4</span>);</span><br><span class="line">                a.add(<span class="number">85</span>);</span><br><span class="line">                a.add(<span class="number">14</span>);</span><br><span class="line">                a.add(-<span class="number">15</span>);</span><br><span class="line">                a.add(-<span class="number">45</span>);</span><br><span class="line">                a.add(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">                <span class="type">IntStream</span> <span class="variable">b</span> <span class="operator">=</span> a.build();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面调用聚集方法的代码每次只能执行一个</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;is所有元素的最大值：&quot;</span> + b.max().getAsInt());</span><br><span class="line">		<span class="comment">//System.out.println(&quot;is所有元素的最小值：&quot; + b.min().getAsInt());</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;is所有元素的总和：&quot; + b.sum());</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;is所有元素的总数：&quot; + b.count());</span></span><br><span class="line">		<span class="comment">//System.out.println(&quot;is所有元素的平均值：&quot; + b.average());</span></span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;is所有元素的平方是否都大于20:&quot;</span></span><br><span class="line">			+ b.allMatch(ele -&gt; ele * ele &gt; <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">&quot;is是否包含任何元素的平方大于20:&quot;</span></span><br><span class="line">			+ b.anyMatch(ele -&gt; ele * ele &gt; <span class="number">20</span>));</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将is映射成一个新Stream，新Stream的每个元素是原Stream元素的2倍+1</span></span><br><span class="line"></span><br><span class="line">                <span class="type">var</span> <span class="variable">newIs</span> <span class="operator">=</span> b.map(ele -&gt; ele * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用方法引用的方式来遍历集合元素</span></span><br><span class="line">                newIs.forEach(System.out::println); <span class="comment">// 输出41 27 -3 37</span></span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面聚集方法只能执行一行，需要把其他聚集操作注释掉。</p>
<p>Stream提供了很多方法来进行操作，分为“中间方法”和“末端方法”</p>
<ul>
<li>中间方法：中间操作允许流保持打开状态，并允许直接调用后续的方法，中间方法的返回值是另外一个流</li>
<li>末端方法：末端方法是对流的最终操作，<strong>当对某个Stream执行末端方法后，该流会被“消耗”且不能再使用</strong></li>
</ul>
<p>除此之外关于流的方法有两个特征</p>
<ul>
<li>有状态的方法：这种方法会给流增加一些新的属性，比如元素唯一性、元素的最大数量等等，有状态的方法往往需要更大的性能开销</li>
<li>短路方法：短路方法可以尽早结束对流的操作，不必检查所有元素</li>
</ul>
<p>Stream常用中间方法(全部返回一个新的流)</p>
<ul>
<li><strong>filter(Predicate
predicate)</strong>：过滤所有不符合predicate的元素</li>
<li><strong>mapToXxx(ToXxxFunction
mapper)</strong>：使用ToXxxFunction对流元素执行一对一转换，返回的新流包含转换生成的所有元素</li>
<li><strong>peek(Consumer
action)</strong>：依次对每个元素执行一些操作，返回的流与原有流包含元素相同，主要用于调试</li>
<li><strong>distinct()</strong>：用于排序流中所有重复的流</li>
<li><strong>sorted()</strong>：用于保证流中所有元素在后序访问中处于有序状态</li>
</ul>
<p>Stream常用末端方法</p>
<ul>
<li><strong>forEach(Consumer
action)</strong>：遍历流中所有元素，对每个元素执行action</li>
<li><strong>toArray()</strong>：将流中所有元素转换为一个数组</li>
<li><strong>reduce()</strong>：有三个重载版本，都是通过某种操作合并流中元素</li>
<li><strong>min()</strong>：返回流中最小值</li>
<li><strong>max()</strong>：返回流中最大值</li>
<li><strong>count()</strong>：返回所有元素数量</li>
<li><strong>anyMatch(Predicate
predicate)</strong>：判断流中是否至少有一个元素符合Predicate条件</li>
<li><strong>allMatch(Predicate
predicate)</strong>：判断流中是否所有元素符合Predicate条件</li>
<li><strong>noneMatch(Predicate
predicate)</strong>：判断流中是否所有元素都不符合Predicate条件</li>
<li><strong>fndFirst()</strong>：返回流中第一个元素</li>
<li><strong>findAny</strong>：返回流中任意一个元素</li>
</ul>
<p>Java允许使用这些流来操作集合，Collection提供了一个stream默认方法，该方法返回该集合对应流，然后可以使用流的方法来操作集合元素</p>
<p>例子：对集合元素进行批量操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.function.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CollectionStream</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 创建books集合、为books集合添加元素的代码与8.2.5小节的程序相同。</span></span><br><span class="line">		<span class="type">var</span> <span class="variable">books</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        </span><br><span class="line">		books.add(<span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Java讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂iOS讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Ajax讲义&quot;</span>);</span><br><span class="line">		books.add(<span class="string">&quot;疯狂Android讲义&quot;</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 统计书名包含“疯狂”子串的图书数量</span></span><br><span class="line">        </span><br><span class="line">		System.out.println(books.stream()</span><br><span class="line">			.filter(ele-&gt;((String) ele).contains(<span class="string">&quot;疯狂&quot;</span>))</span><br><span class="line">			.count()); <span class="comment">// 输出4</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 统计书名包含“Java”子串的图书数量</span></span><br><span class="line">		System.out.println(books.stream()</span><br><span class="line">			.filter(ele-&gt;((String) ele).contains(<span class="string">&quot;Java&quot;</span>) )</span><br><span class="line">			.count()); <span class="comment">// 输出2</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 统计书名字符串长度大于10的图书数量</span></span><br><span class="line">		System.out.println(books.stream()</span><br><span class="line">			.filter(ele-&gt;((String) ele).length() &gt; <span class="number">10</span>)</span><br><span class="line">			.count()); <span class="comment">// 输出2</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 先调用Collection对象的stream()方法将集合转换为Stream,</span></span><br><span class="line">		<span class="comment">// 再调用Stream的mapToInt()方法获取原有的Stream对应的IntStream</span></span><br><span class="line">		books.stream().mapToInt(ele -&gt; ((String) ele).length())</span><br><span class="line">			<span class="comment">// 调用forEach()方法遍历IntStream中每个元素</span></span><br><span class="line">			.forEach(System.out::println);<span class="comment">// 输出8 11 16 7 8</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/" class="post-title-link" itemprop="url">面向对象(下)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:01:39 / 修改时间：16:53:52" itemprop="dateCreated datePublished" datetime="2022-05-11T09:01:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>##　包装类</p>
<p>基本数据类型的数据不具备“对象”的特性，例如所有引用变量类型都继承了Object类，但基本数据类型却没有。</p>
<p>因此为了解决基本数据类型的变量不能当做Object类型变量使用的问题，Java提供了包装类</p>
<p>byte---&gt;Byte, short---&gt;Short, int---&gt;Integer,
long---&gt;Long, char---&gt;Character, float---&gt;Float,
double---&gt;Double,</p>
<p>boolean---&gt;Boolean</p>
<p>Java还提供了自动装箱和自动拆箱，自动装箱是把基本类型变量直接赋给对应包装类变量，不需要强制转换。</p>
<p>拆箱就是反过来。</p>
<p>除此之外，包装类提供了基本类型变量和字符串之间的转换，把字符串值转换成基本类型的值有两种方式</p>
<ul>
<li>利用包装类提供的<strong>parseXxx(String s)</strong>静态方法</li>
<li>利用包装类提供的<strong>valueOf(String s)</strong>静态方法</li>
</ul>
<p>String类也提供了多个重载valueOf()方法，把基本类型变量转换成字符串。</p>
<p><strong>提示：如果把基本类型变量转换成字符串，有一种更简单方法，就是将基本类型变量与""相连接</strong></p>
<p><strong>注意：包装类的实现，例如Integer包装类，系统会创建一个cache的数组，把-128~127的整数放在数组中，缓存起来，当把一个在这个范围内的数自动装箱成一个实例时，实际指向的是数组对应的元素。</strong></p>
<h2 id="处理对象">处理对象</h2>
<p>Java对象都是Object类的实例，都可以直接调用该类的方法。</p>
<p>toString()是Object类的一个实例方法，它总是返回”类名@hashcode“值，当使用System.out.println(p)打印p对象时，打印的实际上是p对象toString的返回值。</p>
<p>这个返回值不能满足输出对象内容的功能，因此用户需要自定义类能实现这个功能，就要重写这个方法。</p>
<hr />
<p>Java测试变量相等有两种方法，一个是用==运算符，一个是用equals方法。</p>
<p>当时用==来判断两个变量是否相等时，如果都是基本类型变量且都是数值类型，则只要两个变量值相等，返回true</p>
<p>但是如果是两个引用类型变量，则只有他们指向同一个对象时，即他们存放的地址值相等时，才会返回true。</p>
<p>使用equals判断，与使用==判断没有区别，仍然要求引用变量指向同一个对象才回返回true，因此如果要采用自定义的相等标准，需要重写equals方法。</p>
<p><strong>注意：String类已经重写了euqals方法，可以直接判断两个字符串包含的字符序列是否相等。</strong></p>
<p>重写equals方法需要满足几个条件</p>
<ul>
<li>自反性：对任意x，x.equals(x)一定返回true</li>
<li>对称性：对任意x和y，如果x.equals(y)返回true，则y.equals(x)也必须返回true</li>
<li>传递性：对任意x,y,z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)也必须返回true</li>
<li>一致性：对任意x和y，如果对象中判断相等的信息没有改变，则无论调用多少次equals方法，返回的结果应该保持一致</li>
<li>对任意不是null的x，x.equals(null)一定返回false</li>
</ul>
<h3 id="关于常量池">关于常量池</h3>
<p>JVM有一个常量池来管理在编译时被确定并被保存在已编译的.class文件中，它包括了类、方法、接口中的常量和字符串常量。</p>
<p>常量池分为两种：静态常量池和运行时常量池</p>
<p>静态常量池就是上述所说的，被保存在了class文件，当运行时，class文件被加载到内存中，就是运行时常量池。</p>
<p>当时用<code>String p1 = "hello"</code>和使用<code>String p2 = new
String("hello")</code>时，前者会将字符串"hello"放在常量池中，让p1去引用，后者会先使用常量池管理"hello"直接量，然后调用String构造器创建一个新的String对象，它被保存在堆内存中。</p>
<p>需要注意的是，如果在上面两句代码后再加<code>String p3 = "he" +
"llo"</code>，则<code>p3 ==
p1</code>返回true,因为系统在编译期间执行了+号，将字符串拼接起来，并自动进行优化，所以还是引用常量池的字符串。</p>
<p>上面所说的包装类的实现也是一种常量池应用</p>
<hr />
<h2 id="类成员">类成员</h2>
<p>用static修饰的成员就是类成员，类变量属于整个类，当系统第一次准备使用该类时，系统会为该类变量分配内存，类变量生效，直到该类被卸载。</p>
<p>类变量可以通过类来访问，也可以通过类的对象来访问。但是当类的对象访问类变量时，<strong>其实系统会在底层转换成该类来访问类变量。当创建类的对象时，系统也不会再为类变量分配内存。</strong>即对象根本不拥有对应类的类变量。</p>
<p>当一个类的对象为null时，如<code>Person
p;</code>创建了一个Person类对应的对象，但是p还没有指向任何内存，即p =
null，<strong>p依然可以直接访问类的类成员。</strong></p>
<h2 id="final修饰符">final修饰符</h2>
<p>final用于修饰类、变量和方法。表明是不可变的。</p>
<p>final修饰变量时，表示该变量一旦获得初始值就不能再改变了，final可以修饰成员变量，也可以修饰局部变量和形参。</p>
<ul>
<li>当final修饰成员变量时，虽然系统会默认初始化，但必须由程序员另外显式指定初始值</li>
<li>final修饰局部变量时，系统不会默认初始化，也必须要显式指定初始值</li>
</ul>
<p><strong>final修饰引用类型变量时，引用类型变量本身不能改变，即它必须一直引用这个对象，但它所引用的对象是可以改变的。</strong></p>
<hr />
<p>对一个final变量来说，不管是类变量、成员变量还是局部变量，只要满足三个条件，这个final变量就不是一个变量，而是一个直接量或者常量。</p>
<ul>
<li>使用final修饰</li>
<li>在定义该final变量时指定了初始值</li>
<li>该初始值可以在编译时被确定下来</li>
</ul>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.put.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于这个程序来说，a变量不存在，当执行System.put.println(a)时，实际转换为执行System.put.println(5)。</p>
<p>即变成了一个宏变量。编译器会把所有用到该变量的地方都替换成对应的值。</p>
<hr />
<p><strong>final方法</strong></p>
<p>final修饰的方法不可以被重写，但可以被重载。</p>
<hr />
<p><strong>final类</strong></p>
<p>final修饰的类不能有子类，</p>
<hr />
<p><strong>不可变类</strong></p>
<p>不可变类是指创建该类的实例后，该实例的实例变量是不可改变的。</p>
<p>如果要创建自定义的不可变类，要遵守几条规则</p>
<ul>
<li>使用private和final修饰符来修饰该类的成员变量</li>
<li>提供带参数的构造器，用于根据传入参数来初始化类的成员变量</li>
<li>仅为该类提供getter方法，不要为该类成员变量提供setter方法</li>
<li>如果有必要，重写equals和hashcode方法</li>
</ul>
<p><strong>注意：如果定义一个不可变类，但这个不可变类有引用类型变量，final修饰引用类型变量，则变量引用的对象不能改变，但对象本身可以改变，因此一定要采用必要措施来保护引用类型对象不会被改变，这样才能创建真正的不可变类。</strong></p>
<hr />
<h2 id="抽象类">抽象类</h2>
<p>抽象方法和抽象类使用abstract修饰符来修饰，有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。</p>
<p>抽象类只能用public修饰符或者省略修饰符来修饰</p>
<p>几条规则</p>
<ul>
<li>抽象类和抽象方法必须使用abstract修饰，抽象方法不能有方法体</li>
<li>抽象类不能被实例化，也无法使用new关键字来调用抽象类的构造器，即使抽象类不包含抽象方法</li>
<li>抽象类里可以包含成员变量，方法(普通方法和抽象方法)，构造器，初始化块，内部类(接口和枚举)五种成分，抽象类的构造器不能用于创建实例，主要用于被子类调用</li>
<li>含有抽象方法的类(<strong>包括直接定义了一个抽象方法，或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或者实现了一个接口，但没有完全实现接口包含的抽象方法三种情况</strong>)只能被定义为抽象类</li>
</ul>
<p>抽象类不能用于创建实例，只能当做父类被子类继承。</p>
<p><strong>注意：如果抽象类里有抽象方法和普通方法，则它的子类必须实现抽象方法，普通方法可实现可不实现。</strong></p>
<p><strong>注意：abstract和static不能同时使用，但不是绝对的，它俩可以同时用来修饰内部类；abstract和final也不能同时使用；private和abstract也不能同时使用，因为abstract修饰的方法必须被子类重写才有意义。</strong></p>
<hr />
<h2 id="接口">接口</h2>
<p>将抽象类进行的更彻底，可以提炼出一种更加特殊的“抽象类”——接口，接口可以定义默认方法、类方法和私有方法，都可以提供方法实现。</p>
<p>接口可以继承多个接口，但是不能继承类。</p>
<p>接口只能用public或者省略访问控制符来修饰。</p>
<p>接口不能包含构造器和初始化块定义，可以包含成员变量(<strong>只能是静态变量</strong>)、方法(<strong>只能是抽象实例方法、默认方法、类方法和私有方法</strong>)、内部类(内部接口、枚举)。</p>
<hr />
<table>
<colgroup>
<col style="width: 36%" />
<col style="width: 14%" />
<col style="width: 28%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th>有无方法体</th>
<th>是否需要被实现类重写</th>
<th>默认修饰符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>普通方法(抽象实例方法)</td>
<td>无</td>
<td>必须被实现类重写</td>
<td>public abstract</td>
</tr>
<tr class="even">
<td>默认方法(带方法体实例方法)</td>
<td>有</td>
<td>可以被实现类重写</td>
<td>public default</td>
</tr>
<tr class="odd">
<td>类方法</td>
<td>有</td>
<td>不可以</td>
<td>public static</td>
</tr>
<tr class="even">
<td>私有方法</td>
<td>有</td>
<td>不可以</td>
<td>private</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong></p>
<ul>
<li>系统会自自动为普通方法加上abstract修饰符</li>
<li>默认方法必须使用的default修饰，不能使用static修饰</li>
<li>私有方法主要作为工具方法，不能使用default修饰，可以是类方法或者实例方法</li>
</ul>
<hr />
<p>接口中定义的静态变量，不管是否使用public static
final修饰符，系统都会为变量自动加上。
<strong>且可以在接口修饰的访问范围内，使用静态变量，直接用“接口名.变量名”来进行调用。</strong></p>
<p>接口中定义的内部类。内部接口和内部枚举都会自动采用public static
修饰符。</p>
<hr />
<p>一个接口如果继承了另一个接口，将会获得该接口的所有抽象方法和静态变量。</p>
<p>一个类如果实现了一个接口，必须实现该接口所有抽象方法，可以实现该接口默认方法，同时获得该接口的静态变量。</p>
<hr />
<h3 id="使用接口">使用接口</h3>
<p>接口不能用于创建实例，但可以声明引用类型变量，并且变量所引用的对象对应的类实现了该接口。</p>
<p>接口主要的用途就是被实现类实现。归纳来说，接口的用途有：</p>
<ul>
<li>定义变量，也可以用于强制类型转换</li>
<li>调用接口中定义的常量</li>
<li>被其他类实现</li>
</ul>
<p>一个类可以实现多个接口，使用implements关键字，一旦实现接口，可以获得该接口的静态变量，普通方法和默认方法。</p>
<p>而且因为子类重写父类方法时，访问权限只能更大或者相等，<strong>所以实现类实现接口的方法只能使用public修饰。</strong></p>
<hr />
<h2 id="接口和抽象类">接口和抽象类</h2>
<p>接口和抽象类的相同点</p>
<ul>
<li>都不可以被实例化</li>
<li>都位于继承树顶端，用于被其他类实现或继承</li>
<li>都可以包含抽象方法，实现接口或继承抽象类的类都必须实现这些抽象方法</li>
</ul>
<p>接口和抽象类的不同点</p>
<ol type="1">
<li><ul>
<li>接口体现的是一种规范，对于接口实现者来说，接口规定了实现者必须向外提供什么服务，对于接口调用者来说接口规定调用者可以使用哪些服务，某种程度上来说，接口类似整个系统的“总纲”，接口不应该经常被改变</li>
<li>抽象类则体现了一种模块化设计，抽象类作为多个子类的抽象父类，可以当成系统实现的中间产品，这个中间产品已经实现了部分功能，但不能被当成最终产品，必须有进一步完善</li>
</ul></li>
<li><ul>
<li>接口只能包含抽象方法、类方法、默认方法和私有方法，不能为普通的方法提供实现</li>
<li>抽象类可以包含普通方法</li>
</ul></li>
<li><ul>
<li>接口只能定义静态常量，不能定义普通成员变量</li>
<li>抽象类既可以定义普通成员变量，也可以定义静态常量</li>
</ul></li>
<li><ul>
<li>接口中不包含初始化块和构造器</li>
<li>抽象类可以包含初始化块和构造器，构造器不是为了创建对象，而是让子类调用</li>
</ul></li>
<li><ul>
<li>一个类可以实现多个接口</li>
<li>一个类最多只有一个直接父类，包括抽象类</li>
</ul></li>
</ol>
<hr />
<h2 id="内部类">内部类</h2>
<p>定义在其他类内部的类就是内部类，包含内部类的类是外部类。</p>
<p>内部类有几个作用</p>
<ul>
<li>内部类提供更好的封装，把内部类隐藏在外部类之内，同一个包的其他类无法访问</li>
<li>内部类成员可以访问外部类的私有数据，因为内部类被当成外部类成员，同一个类的成员之间可以相互访问</li>
<li>匿名内部类适用于创建只需要使用一次的类</li>
</ul>
<p>同时，内部类可以比外部类多使用三个修饰符：private、protected、static，外部类不能使用这三个修饰符。</p>
<p>内部类主要分四类</p>
<ul>
<li>成员内部类：即在类里定义的，没有用static修饰的类</li>
<li>静态内部类：在类里定义的，但使用static修饰的类</li>
<li>局部内部类：定义在一个方法或者一个作用域里面的类</li>
<li>匿名内部类：通过已有的接口或者类来创建，没有名字</li>
</ul>
<hr />
<h3 id="成员内部类">成员内部类</h3>
<p>成员内部类是最普通的内部类，被定义在外部类的内部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;drawshape&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如Draw就是一个成员内部类</p>
<p>特点：</p>
<ul>
<li><strong>成员内部类可以无条件访问外部类的所有成员变量和方法</strong></li>
<li><strong>成员内部类是依附于外部类的，因此如果要创建一个成员内部类对象，首先要创建一个外部类对象</strong></li>
<li><strong>成员内部类不能定义静态变量或者方法</strong></li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><strong>外部类不能直接访问成员内部类的成员变量和方法，必须要创建一个内部类对象，通过这个对象才能进行访问。</strong></li>
<li><strong>如果成员内部类里定义了和外部类重名的变量，会发生隐藏现象，即默认访问的是成员内部类定义的变量，如果要访问外部类的同名成员，需要用“外部类名.this.成员变量/方法”来使用</strong></li>
</ul>
<hr />
<h3 id="静态内部类">静态内部类</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;     <span class="comment">//静态内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;drawshape&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用static修饰的成员内部类就是静态内部类，可以把外部类当成静态内部类的包</p>
<p>特点</p>
<ul>
<li><strong>静态内部类不需要依附于外部类的对象，可以直接用“外部类名.内部类名”的方式来创建静态内部类</strong></li>
<li><strong>静态内部类可以包含静态成员和非静态成员</strong></li>
<li><strong>静态内部类只能访问外部类的静态成员，不能访问非静态成员</strong></li>
</ul>
<p>除此之外，接口里也可以定义内部类，默认使用public
static修饰符，也就是说，接口内部类只能是静态内部类</p>
<hr />
<h2
id="关于成员内部类和静态内部类访问问题">关于成员内部类和静态内部类访问问题</h2>
<p>成员内部类可以访问外部类的静态成员和非静态成员，也可以访问它的外部类定义的其他静态内部类里的静态成员</p>
<p>外部类不能直接访问成员内部类的成员，只能通过创建成员内部类的对象来访问。</p>
<p>静态内部类只能访问外部类的静态成员，不能访问外部类的非静态成员</p>
<p>外部类可以访问静态内部类的静态成员，不能访问静态内部类的非静态成员</p>
<p><strong>简单的来说，非静态的“东西”可以访问静态的和非静态的，但是静态的“东西”只能访问静态的</strong></p>
<hr />
<h2 id="局部内部类">局部内部类</h2>
<p>局部内部类非常简单，把一个类放在方法中或者一个作用域中定义，它就是局部内部类，在这个方法或者作用域之外，这个类不存在，也不能被访问，因此局部内部类不能使用访问控制符或者static修饰符修饰</p>
<p>实际开发很少使用局部内部类，因为它的作用域太小</p>
<hr />
<p>##　匿名内部类</p>
<p>匿名内部类适合只需要使用一次的类，创建匿名内部类时会立即创建一个该类的实例，匿名内部类不能重复使用</p>
<p>定义匿名内部类的格式为</p>
<p><code>new 实现接口() | 父类构造器(实参列表)
&#123;匿名内部类的类体部分&#125;</code></p>
<p>可以看出，匿名内部类必须继承一个父类或实现一个接口，但最多只能继承一个父类，或实现一个接口</p>
<p>还有两条规则</p>
<ul>
<li>匿名内部类不能是抽象类，因为系统创建匿名类时，会立即创建匿名内部类的对象</li>
<li>匿名内部类不能定义构造器，因为匿名内部类没有类名，但可以有初始化块</li>
</ul>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Product</span>&#123;</span><br><span class="line">	<span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span>;</span><br><span class="line">	String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Product p)</span>&#123;</span><br><span class="line">        System.out.println(p.getName + p.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Main</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">        a.test(<span class="keyword">new</span> <span class="title class_">Product</span>()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getPrice</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">567.8</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;AGP&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即在Main里定义了test方法，需要Product参数，但Product无法直接创建实例，需要考虑传入Product接口实现类的对象，则可创建一个匿名内部类。</p>
<p>匿名内部类必须实现它的抽象父类或者接口包含的所有抽象方法。</p>
<p>被匿名内部类访问的局部变量必须使用final修饰。</p>
<hr />
<h2 id="lambda表达式">Lambda表达式</h2>
<p>Lambda表达式就是用来创建只有一个抽象方法的接口的实例。</p>
<p>只有一个抽象方法的接口叫做函数式接口，但可以包含多个默认方法和类方法。</p>
<p>Lambda表达式的主要作用就是就是代替匿名内部类的繁琐语法，它由三部分组成</p>
<ul>
<li>形参列表：<strong>如果形参列表只有一个参数，甚至连形参列表的圆括号也可以省略</strong></li>
<li>箭头：-&gt;</li>
<li>代码块：如果代码块只包含一条语句，可以省略代码块的花括号</li>
</ul>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ProcessArray</span> <span class="variable">pa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessArray</span>();</span><br><span class="line">pa.process(array, (<span class="type">int</span> elemenmt)-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;数组元素的平方是:&quot;</span> + element * element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上述代码中，pa的第二个参数是一个函数式接口的实现类，就可以使用Lambda表达式直接创建一个实现类。</p>
<p>Lambda表达式有两个限制</p>
<ul>
<li>Lambda表达式的目标类型只能是明确的的函数式接口</li>
<li>Lambda表达式只能为函数式接口创建对象，Lambda表达式只能实现一个方法</li>
</ul>
<h3 id="方法引用和构造器引用">方法引用和构造器引用</h3>
<p>如果Lambda表达式的代码块只有一条代码，程序可以省略Lambda表达式的花括号，不仅如此，如果Lambda表达代码块只有一条代码，还可以在代码块中使用方法引用和构造器引用</p>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 14%" />
<col style="width: 41%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th>种类</th>
<th>示例</th>
<th>说明</th>
<th>对应的表达式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>引用类方法</td>
<td>类名::类方法</td>
<td>函数式接口被实现方法<br />全部参数传给该类方法</td>
<td>(a, b..)-&gt;类名::类方法(a, b, ...)</td>
</tr>
<tr class="even">
<td>引用特定对象实例方法</td>
<td>特定对象::实例方法</td>
<td>函数式接口被实现方法<br />全部参数传给该方法</td>
<td>(a, b..)-&gt;特定对象.实例方法(a, b..)</td>
</tr>
<tr class="odd">
<td>引用某类对象实例方法</td>
<td>类名::实例方法</td>
<td>接口第一个参数作为调用者<br />后面参数全部传给该方法</td>
<td>(a. b...)-&gt;a.实例方法(a,b...)</td>
</tr>
<tr class="even">
<td>引用构造器</td>
<td>类名::new</td>
<td>接口全部参数传给该构造器</td>
<td>(a, b...)-&gt;new 类名(a, b...)</td>
</tr>
</tbody>
</table>
<hr />
<p>定义一个函数式接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Converter</span>&#123;</span><br><span class="line">    Integer <span class="title function_">convert</span><span class="params">(String from)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><p>引用类方法</p>
<p><code>Converter converter1 = from-&gt;
Integer.valueOf(from);</code></p>
<p>可以写成：</p>
<p><code>Converter converter1 = Integer::valueOf;</code></p></li>
<li><p>引用特定对象实例方法</p>
<p><code>Converter converter2 = from
-&gt;"kit.org".indexOf(from);</code></p>
<p>可以写成：</p>
<p><code>Converter converter2 = "fkit.org::indexOf;"</code></p></li>
<li><p>引用某类对象的实例方法</p>
<p>定义如下函数式接口</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mytest</span>&#123;</span><br><span class="line">    String <span class="title function_">test</span><span class="params">(String a, <span class="type">int</span> b, <span class="type">int</span> c)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Lambda表达式创建对象</p>
<p><code>Mytest mt = (a, b, c)-&gt; a.substring(a, b);</code></p>
<p>可以写成：</p>
<p><code>Mytest mt = String::substring;</code></p></li>
<li><p>引用构造器</p>
<p>定义如下函数式接口</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Mytest</span>&#123;</span><br><span class="line">    JFrame <span class="title function_">win</span><span class="params">(String title)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Lambda表达式创建一个对象</p>
<p><code>Mytest mt = a -&gt; new JFrame(a);</code></p>
<p>可以写成：</p>
<p><code>Mytest mt = JFrame::new;</code></p></li>
</ol>
<h3
id="匿名内部类和lambda表达式的区别和联系">匿名内部类和Lambda表达式的区别和联系</h3>
<p>相似点：</p>
<ul>
<li>都可以直接访问“effectively
final”的局部变量，以及外部类的成员变量</li>
<li>它们创建的对象都可以直接调用从接口继承的默认方法</li>
</ul>
<p>不同点：</p>
<ul>
<li>匿名内部类可以为任意接口创建实例，不管有多少抽象方法，但Lambda表达式只能为函数式接口创建实例</li>
<li>匿名内部类可以为抽象类甚至普通类创建实例，但Lambda表达式不是</li>
<li>匿名内部类实现的抽象方法的方法体允许调用接口定义的默认方法，但Lambda表达式不允许</li>
</ul>
<hr />
<h2 id="枚举类">枚举类</h2>
<p>实例有限且固定的类称为枚举类</p>
<p>使用enum定义枚举类，他也可以有自己的成员变量、构造器和方法，可以实现接口</p>
<p>但枚举类和普通类有区别</p>
<ul>
<li>枚举类可以实现接口，使用enum定义的枚举类默认继承了java.lang.Enum类，<strong>不是默认继承Object类，因此枚举类不能显式继承其他的父类</strong></li>
<li>使用enum定义的非抽象的枚举类<strong>默认使用final修饰</strong></li>
<li><strong>枚举类构造器只能使用private修饰，如果省略了访问控制符，系统会默认加上</strong></li>
<li><strong>枚举类所有实例必须在枚举类第一行显式列出</strong>，否则这个枚举类永远不能产生实例，这些实例系统会自动添加<strong>public
static final修饰</strong>，无需显式添加</li>
</ul>
<p>枚举类提供一个values方法，可以遍历所有枚举值</p>
<p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public enum SeasonEnum&#123;</span><br><span class="line">	SPRING, SUMMER, FALL, WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EnumTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">judge</span><span class="params">(SeasonEnum s)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// switch语句里的表达式可以是枚举值</span></span><br><span class="line">		<span class="keyword">switch</span> (s)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> SPRING:</span><br><span class="line">				System.out.println(<span class="string">&quot;春暖花开，正好踏青&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> SUMMER:</span><br><span class="line">				System.out.println(<span class="string">&quot;夏日炎炎，适合游泳&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> FALL:</span><br><span class="line">				System.out.println(<span class="string">&quot;秋高气爽，进补及时&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> WINTER:</span><br><span class="line">				System.out.println(<span class="string">&quot;冬日雪飘，围炉赏雪&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 枚举类默认有一个values方法，返回该枚举类的所有实例</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> s : SeasonEnum.values())</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(s);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用枚举实例时，可通过EnumClass.variable形式来访问</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">EnumTest</span>().judge(SeasonEnum.SPRING);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>switch括号的表达式可以是任何枚举类型，且后面case无需添加枚举类作为限定。</p>
<p>枚举类提供几种常用方法</p>
<ul>
<li><strong>int compareTo(E
o)</strong>:用于与指定枚举对象比较顺序，如果该枚举对象在指定枚举对象之后，返回正整数，之前负整数，否则返回0</li>
<li><strong>String name()</strong>：返回此枚举实例的名称</li>
<li><strong>String
toString()</strong>:也是返回枚举实例名称，优先使用这个</li>
<li><strong>int
ordinal()</strong>:返回枚举值在类中的索引值，就是声明索引中的位置，从零开始</li>
<li><strong>public static &lt;T extends Enum<T>&gt; T valueOf(Class<T>,
String
name)</strong>:静态方法，返回指定枚举类中制定名称的枚举值，名称必须与在该枚举类中声明时一致</li>
</ul>
<h3 id="枚举类成员变量方法和构造器.">枚举类成员变量、方法和构造器.</h3>
<p>Java应该把所有类设计成良好封装的类，所以不应该允许直接访问枚举类的成员变量，应该把成员变量全部设为private
final修饰。</p>
<p>例如一个枚举类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">    MALE, FEMALE;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不应该允许直接访问Gender的name成员变量，如果出现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Gender</span> <span class="variable">g</span> <span class="operator">=</span> Enum.valueOf(Gender.class, <span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line">g.name = <span class="string">&quot;男&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>就会出现混乱。</p>
<p>如果每个成员用final修饰，就应该在构造器为成员变量指定初始值，例子如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span>&#123;</span><br><span class="line">    MALE(<span class="string">&quot;男&quot;</span>), FEMALE(<span class="string">&quot;女&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"> 	<span class="keyword">private</span> <span class="title function_">Gender</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在列出枚举值时直接调用构造器创建枚举类对象，这里无需使用new关键字</p>
<p>###　实现接口的枚举类</p>
<p>枚举类可以实现一个或多个接口</p>
<p>例如定义一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenderDesc</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后可以使枚举类实现这个接口，但是如果直接实现info()方法时，<strong>那么每个枚举值在调用这个方法时都有相同行为方法，如果要让每个枚举值在调用这个方法时呈现不同的行为，可以让每个枚举值实现该方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Gender</span> <span class="keyword">implements</span> <span class="title class_">GenderDesc</span>&#123;</span><br><span class="line">	MALE(<span class="string">&quot;男&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;代表男性&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	FEMALE(<span class="string">&quot;女&quot;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;代表女性&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样相当于定义了两个Gender的匿名子类实例，所有实际并没有创建Gender枚举类的实例。</p>
<p>这相等于这个枚举类是一个抽象类因为它并没有实现它实现的接口的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">	PLUS</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> x + y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	MINUS</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> x - y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	TIMES</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> x * y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	DIVIDE</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> x / y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">// 为枚举类定义一个抽象方法</span></span><br><span class="line">	<span class="comment">// 这个抽象方法由不同的枚举值提供不同的实现</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">eval</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(Operation.PLUS.eval(<span class="number">3</span>, <span class="number">4</span>));</span><br><span class="line">		System.out.println(Operation.MINUS.eval(<span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">		System.out.println(Operation.TIMES.eval(<span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">		System.out.println(Operation.DIVIDE.eval(<span class="number">5</span>, <span class="number">4</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面例子四个枚举值PLUS,MINUS,TIMES,DIVIDE代表四种运算，该枚举类定义一个eval()方法进行运算。</p>
<p>我们可以让Operation枚举类定义一个eval()抽象方法，然后让四个枚举值去实现它，编译上面程序会产生五个class文件，四个匿名内部子类分别对应一个class文件，Operatin类对应一个class文件。</p>
<p>枚举类定义抽象方法时，不需要加上abstract，系统会自动加上，当定义每个枚举值时，必须实现这个抽象方法，否则会出现编译错误。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8A)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/11/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8A)/" class="post-title-link" itemprop="url">面向对象(上)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:00:39 / 修改时间：16:53:49" itemprop="dateCreated datePublished" datetime="2022-05-11T09:00:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="一类和对象">一、类和对象</h2>
<p>面向对象有两个基本概念：类和对象，对象也被称为实例，类是某一批对象的抽象，对象是具体存在的实体。</p>
<p>类最常见的三种成员</p>
<ul>
<li>构造器</li>
<li>成员变量</li>
<li>方法</li>
</ul>
<p>定义顺序没有任何影响，成员之间可以相互调用</p>
<p><strong>注意：</strong>
<strong>static修饰的成员不能访问没有static修饰的成员。</strong>很好理解，static修饰的成员属于这个类的成员，如果还没有创建对象，但是调用了含有访问没有static修饰的成员的类方法，就会出现错误。</p>
<p>构造器是一个类创建对象的根本途径，如果一个类没有构造器，这个类无法创建实例。因此Java提供了一个功能：<strong>如果没有为一个类编写构造器，Java会默认为该类提供一个无参数的构造器。但是如果编写了一个有参数的构造器，则不会再有默认的无参数构造器。</strong></p>
<h3 id="static修饰字">static修饰字</h3>
<p>static修饰字是一个特殊的关键字，可以用来修饰方法变量等，它修饰的成员表明这个成员属于这个类本身，不属于任何对象，因此把static修饰的成员变量和方法叫做类变量和类方法，把没有用static修饰的成员变量和方法叫做实例变量和方法。</p>
<h3 id="对象的this调用">对象的this调用</h3>
<p>Java提供了一个this关键词，this关键词总是指向调用该方法的对象，根据出现位置不同，this作为对象默认调用有两种情况</p>
<ul>
<li>构造器中引用该构造器正在初始化的对象</li>
<li>在方法中调用该方法的对象</li>
</ul>
<p>this可以代表任何对象，当this出现在某个方法体中时，它代表的对象是不确定的，但可以确定的是，它所代表的只能是当前类的实例，只有当这个方法被真正调用的时候，才能确定this代表的是哪个对象，谁在调用这个对象，this就代表谁。</p>
<p>但注意，static修饰的方法不能用this引用。由前面可知，静态成员不能访问非静态成员，所以静态方法不能访问普通成员，如果必须访问的话，则只能在静态方法中定义一个对象，通过这个对象来进行访问。</p>
<p>大部分时候访问类成员时可以不用this关键词，但如果出现方法中一个局部变量与成员变量同名，又需要访问这个成员变量，则需要加上this。</p>
<h4 id="注意">注意</h4>
<p>Java允许某个类的实例来调用类方法，但这是不应该的，类方法属于这个类，而不属于任何对象，所以不要用对象去调用类方法，而应该直接用类名来调用类方法。</p>
<h3 id="方法详解">方法详解</h3>
<p>方法必须定义在类里，所有方法在逻辑上，要么属于这个类本身，要么属于对象。</p>
<p>​
Java语言是静态的，一个类定义完成后，只要不重新编译这个类文件，该类和该类对象所拥有的方法是固定的，不会改变。</p>
<p>执行方法时，必须使用类或者对象作为调用者，即所有的方法都必须使用“类.方法”或者“对象.方法”的形式进行调用。</p>
<p>需要指出：同一类的方法调用另一个方法时，如果被调方法是普通方法，默认使用this作为调用者，如果是类方法，默认使用类作为调用者。</p>
<h4 id="方法参数传递机制">方法参数传递机制</h4>
<p>Java里方法传递参数方式只有一种，值传递。即如果是基本类型变量，则会将实际参数复制一份传递给方法形参，原来变量不会出现任何改动，如果是引用变量，则变量保存的是实际数据的内存地址，将会把地址传递给方法形参，实际就是C语言中的指针。</p>
<p>Java允许定义形参变量可变的参数，如果在定义方法时，在最后一个形参类型后增加三点，则表明该形参可以接受多个参数值。</p>
<p>例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Varargs</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 定义了形参个数可变的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, String... books)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// books被当成数组处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">var</span> tmp : books)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.println(tmp);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 输出整数变量a的值</span></span><br><span class="line">		System.out.println(a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 调用test方法</span></span><br><span class="line">		test(<span class="number">5</span>, <span class="string">&quot;疯狂Java讲义&quot;</span>, <span class="string">&quot;轻量级Java EE企业应用实战&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="方法重载">方法重载</h5>
<p>Java允许同一个类定义多个同名方法，只要形参列表不同就行，这被称为方法重载。</p>
<p><strong>注意：方法重载只要求方法名相同，形参列表不同，至于其他部分，没有要求。</strong></p>
<p><strong>不推荐在重载形参个数可变的方法。</strong></p>
<h3 id="成员变量和局部变量">成员变量和局部变量</h3>
<p>成员变量是在类里定义的变量，局部变量是在方法里定义的变量，其中static修饰的变量是类变量。</p>
<p>类变量的生存域与类的生存范围相同，实例变量则从该类实例创建起存在，直到系统销毁这个实例。类变量和实例变量统称为成员变量。</p>
<p>成员变量不需要显式初始化，系统在创建这个变量时会进行默认初始化，int，double，float等数值类型默认初始化为0，布尔类型默认初始化为false。</p>
<p>局部变量则根据定义形式不同，分为三种</p>
<ul>
<li>形参：在定义方法时定义的变量，在整个方法内有效</li>
<li>方法局部变量：在方法体内定义的变量，作用域是从创建的地方开始，到该方法结束</li>
<li>代码块局部变量：在代码块中定义的局部变量，作用域从定义地方开始到代码块结束</li>
</ul>
<p>局部变量除了形参之外，都需要显式初始化，否则不能访问。</p>
<h2 id="隐藏和封装">隐藏和封装</h2>
<p>封装是指不允许外部程序直接访问对象内部信息，而应该通过该类提供的方法间接访问。</p>
<p>为了实现良好封装，考虑以下两个方面</p>
<ul>
<li>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问</li>
<li>把方法暴露出来，让方法来控制这下成员变量进行安全访问和操作</li>
</ul>
<p>使用访问控制符来实现控制访问</p>
<p>Java提供了3个控制符:public, private, protected</p>
<p>Java的访问控制级别由小到大依次为</p>
<p>private-----&gt;default----&gt;protected----&gt;public</p>
<p>default表示没有访问符修饰</p>
<p>访问控制级别表</p>
<table>
<tbody>
<tr class="odd">
<td>权限</td>
<td>private</td>
<td>default</td>
<td>protected</td>
<td>public</td>
</tr>
<tr class="even">
<td>同一个类</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr class="odd">
<td>同一个包</td>
<td></td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
</tr>
<tr class="even">
<td>子类中</td>
<td></td>
<td></td>
<td>可以</td>
<td>可以</td>
</tr>
<tr class="odd">
<td>全局范围</td>
<td></td>
<td></td>
<td></td>
<td>可以</td>
</tr>
</tbody>
</table>
<p>但对于一个外部类(相对于内类而言的类，没有子类)而言，只能有public和默认来修饰，其他修饰符没有意义。</p>
<p>关于控制访问符的使用，几条基本原则</p>
<ul>
<li>类里的绝大部分变量应该用private修饰，有一些方法辅助实现该类的其他方法，被称为工具方法，也应该用private修饰。</li>
<li>如果某个类做其他类的父类，该类里包含的大部分方法仅希望被子类重写，不希望被外界直接调用，用protected修饰</li>
<li>希望暴露出来给其他类自由调用的方法应该用public修饰。</li>
</ul>
<h2 id="深入构造器">深入构造器</h2>
<p>构造器是创建Java对象的重要途径，但这个对象不是完全由构造器负责创建，事实上，当程序调用构造器时，系统会先为该对象分配内存空间，并未这个对象默认初始化，这个对象产生了，这些操作是在构造器执行前完成的。
也就是说，当系统执行构造器之前，构造器已经创建了一个对象，只是这个对象还不能被外界程序访问，只能在构造器中通过this来引用，当构造器执行结束后，这个对象被作为构造器的返回值返回，赋给一个引用类型的变量。</p>
<p>###　构造器重载</p>
<p>同一个类里有多个构造器，但形参列表不同，被称为构造器重载。</p>
<p>如果系统包含了多个构造器，其中一个构造器Ｂ的执行体完全包含另一个构造器Ａ的执行体，那么可以在Ｂ中调用Ａ，使用ｔｈｉｓ关键词来调用相应构造器。</p>
<h2 id="类的继承">类的继承</h2>
<p>继承通过extends来实现。</p>
<p>子类可以获得父类的<strong>所有成员变量，方法和内部类</strong>，但不能获得父类的构造器。</p>
<p><strong>如果父类的成员变量是private修饰的，则子类虽然继承得到了这些变量，但不能直接访问，需通过父类提供的方法来间接访问。</strong></p>
<h3 id="重写父类方法">重写父类方法</h3>
<p>子类与父类同名方法的现象被称为方法重写，或者方法覆盖。</p>
<p>重写要遵循“两同两小一大”原则：“两同”即方法名相同，形参列表形同，“两小”指子类方法返回值比父类方法返回值更小或者相等，子类方法声明抛出的异常比父类方法生命抛出的异常更小或者相等，“一大”指子类方法访问权限比父类方法访问权限更大或者相等。</p>
<p>需要指出：覆盖方法和被覆盖的方法要么都是类方法，要么都是实例方法。</p>
<h3 id="super限定">super限定</h3>
<p>如果需要在子类方法中调用父类中被覆盖的实例方法，可以使用super限定来调用父类被覆盖的实例。
例如父类中有方法fly(),子类可以使用super.fly()来调用父类fly方法。</p>
<p>super用于限定该对象调用它从父类继承得到的实例变量或方法，super也不能出现在static修饰的方法里。</p>
<p>当然如果子类没有与父类同名的成员变量可以直接使用名字访问子类从父类继承得到的成员变量，如果同名则应该使用super.a来访问从父类继承得到的a变量。</p>
<p>如果在构造器中使用super,即直接用<code>super()</code>即可调用父类构造器，super限定该构造器初始化的是该对象从父类继承得到的实例变量，而不是该类自己定义的实例变量。</p>
<p>使用父类构造器必须出现在子类构造器的第一行，不管是否通过super调用父类构造器，子类构造器总会调用父类构造器一次，即如果子类构造器执行体没有super和this调用，系统会在执行子类构造器之前，隐式调用父类无参数的构造器。</p>
<p>当执行父类构造器时，系统会再上溯执行父类的父类的构造器，依次类推，创建任何Java对象，最先执行的总是Object类的构造器。</p>
<p>##　多态</p>
<p>Java引用变量有两个类型：编译时类型和运行时类型。</p>
<p>编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给的变量对象决定。如果两个类型不一致，就有可能出现多态。</p>
<p>Java允许把一个子类对象赋给父类引用变量，无需任何类型转换，这个称为向上转型，由系统自动完成。</p>
<p>当运行时，调用父类的引用变量方法时，方法行为体现出子类方法的行为特征，一个父类可能有多个子类，这就有可能出现同一个类型的变量调用同一个方法时，呈现出不同的行为特征，即多态。</p>
<p>但与方法不同，对象的实例变量不具有多态性，如果子类和父类中有相同名称的成员变量，当使用父类引用变量输出该变量时，输出的就是父类的成员变量。</p>
<p><strong>注意：引用变量在编译阶段只能调用编译时类型的方法，但运行时执行运行时类型具有的方法，因此写代码时，引用变量只能调用声明该变量时所用类里的方法，例如<code>Object
p = new
Person();</code>，这个p只能调用Object类里的方法，不能调用Person类里的方法。</strong></p>
<p>###　引用变量的强制类型转换</p>
<p>如果需要让引用变量调用运行时类型的方法，则必须把它强制类型转换为运行时类型，使用类型转换运算符，(type)variable。</p>
<p>需要注意：</p>
<ul>
<li>基本类型之间转换只能在数值类型之间进行，数值类型和布尔类型不能相互转换</li>
<li>引用类型之间转换只能在具有继承关系的两个类型之间进行，没有任何继承关系的类型，无法进行强制转换。</li>
</ul>
<p>在强制类型转换之前，使用instanceof运算符进行判断是否可以成功转换，可以使程序更加健壮。</p>
<p>instanceof运算符的前一个操作数是引用类型变量，后一个通常是一个类(也可以是接口)，它用于判断前面的对象是否属于后面的类，或者其子类、实现类的实例，是返回true，否则false</p>
<p>使用时注意：前面操作数编译时类型要么与后面类相同，要么与后面的类具有继承关系，否则会编译错误</p>
<h2 id="继承和组合">继承和组合</h2>
<p>继承是实现类复用的重要手段，但继承最大的坏处是破坏了封装。而采用组合实现类复用可以提供更好的封装性。</p>
<p>使用继承需要注意的几点</p>
<ul>
<li>尽量隐藏父类的内部数据，把所有成员变量设为private类型，不要让子类直接访问父类的成员变量</li>
<li>不要让子类随意访问修改父类的方法，父类中的工具方法应该使用private控制符修饰，如果父类方法需要被外部类调用，但又不希望子类重写，可以使用final修饰符修饰</li>
<li>尽量不要在父类构造器中调用将被子类重写的方法。</li>
</ul>
<p>如果不想让某个类被继承，可以使用final修饰这个类，也可以使用private修饰这个类的所有构造器，从而使子类无法调用该类构造器，也就无法继承该类。</p>
<p>利用组合来实现类复用实际就是在新类中创建一个需要复用的类的引用变量，这样就可以使用旧类的成员变量和方法。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/09/hexo%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/05/09/hexo%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">hexo使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-05-09 21:55:39" itemprop="dateCreated datePublished" datetime="2022-05-09T21:55:39+08:00">2022-05-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-05-10 13:24:38" itemprop="dateModified" datetime="2022-05-10T13:24:38+08:00">2022-05-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">工具使用</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="发布文章">发布文章</h2>
<p>在source的_post文件夹中创建markdown文件，并在文章最上方写明文章基本属性。</p>
<p>基本属性使用yaml格式，冒号和后面文字必须空一格。使用---可以创建yaml，即三个杠。</p>
<p>或使用命令<code>hexo n "文件名称"</code></p>
<p>写完文章后，依次执行以下命令：</p>
<p><code>hexo clean</code>：清理静态文件</p>
<p><code>hexo generate / hexo g</code>：重新生成文件</p>
<p><code>hexo deploy / hexo d</code>：部署</p>
<p>即可完成文章发布。</p>
<p>修改文章也类似。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhaoXin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
