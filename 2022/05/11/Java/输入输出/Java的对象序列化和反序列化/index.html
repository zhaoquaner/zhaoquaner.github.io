<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhaoquaner.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.11.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="序列化的含义和意义 对象序列化的目标就是将对象保存到磁盘中，或者直接在网络传输对象，对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许永久保存在磁盘上。程序一旦获得了这种二进制流，都可以将这种二进制流恢复成原来的Java对象,即反序列化。 对象的序列化(Serialize)指将一个Java对象写入IO流，与此对应，对象的反序列化，指从IO流中恢复该Java对象。 Ja">
<meta property="og:type" content="article">
<meta property="og:title" content="Java的对象序列化和反序列化">
<meta property="og:url" content="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/index.html">
<meta property="og:site_name" content="赵圈儿的博客">
<meta property="og:description" content="序列化的含义和意义 对象序列化的目标就是将对象保存到磁盘中，或者直接在网络传输对象，对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许永久保存在磁盘上。程序一旦获得了这种二进制流，都可以将这种二进制流恢复成原来的Java对象,即反序列化。 对象的序列化(Serialize)指将一个Java对象写入IO流，与此对应，对象的反序列化，指从IO流中恢复该Java对象。 Ja">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-05-11T01:11:39.000Z">
<meta property="article:modified_time" content="2022-05-11T08:54:04.108Z">
<meta property="article:author" content="ZhaoXin">
<meta property="article:tag" content="Java基础">
<meta property="article:tag" content="输入输出">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","path":"2022/05/11/Java/输入输出/Java的对象序列化和反序列化/","title":"Java的对象序列化和反序列化"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java的对象序列化和反序列化 | 赵圈儿的博客</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><!-- hexo injector body_begin start --><style>code {font-weight:400;}.post-content {font-weight:600;} #board {border-radius: 1.5rem;} #board-ctn {width:110%;margin-left:-5%;}</style><!-- hexo injector body_begin end -->
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">赵圈儿的博客</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">23</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">18</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">169</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%90%AB%E4%B9%89%E5%92%8C%E6%84%8F%E4%B9%89"><span class="nav-number">1.</span> <span class="nav-text">序列化的含义和意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">使用对象流实现序列化和反序列化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%A6%E4%B8%80%E7%A7%8D%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="nav-number">3.</span> <span class="nav-text">另一种自定义序列化机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="nav-number">4.</span> <span class="nav-text">两种序列化机制对比</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">ZhaoXin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">169</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://zhaoquaner.github.io/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="ZhaoXin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java的对象序列化和反序列化 | 赵圈儿的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java的对象序列化和反序列化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2022-05-11 09:11:39 / 修改时间：16:54:04" itemprop="dateCreated datePublished" datetime="2022-05-11T09:11:39+08:00">2022-05-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/" itemprop="url" rel="index"><span itemprop="name">编程学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/programming/java/" itemprop="url" rel="index"><span itemprop="name">Java基础</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="序列化的含义和意义">序列化的含义和意义</h2>
<p>对象序列化的目标就是将对象保存到磁盘中，或者直接在网络传输对象，对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许永久保存在磁盘上。程序一旦获得了这种二进制流，都可以将这种二进制流恢复成原来的Java对象,即反序列化。</p>
<p>对象的序列化(Serialize)指将一个Java对象写入IO流，与此对应，对象的反序列化，指从IO流中恢复该Java对象。</p>
<p>Java
9增强了对象序列化机制，它允许对读入的序列化数据进行过滤，这种过滤在反序列化之前对数据进行校验，从而提高了安全性和健壮性。</p>
<p>如果需要让某个对象支持序列化机制，则必须让它的类是可序列化的，该类必须实现两个接口之一：</p>
<ul>
<li>Serializable</li>
<li>Externalizable</li>
</ul>
<p>Java很多类实现了Serializable，该接口为标记接口，无需实现任何方法，只是表明该类的实例是可以序列化的。</p>
<p>所有在网络上传输的对象的类都应该是实例化的。</p>
<h2
id="使用对象流实现序列化和反序列化">使用对象流实现序列化和反序列化</h2>
<p>实现序列化应该实现Serializable接口或者Externalizable接口之一，这两接口区别和联系，后面会有介绍，暂时不用理会Externalizable接口。</p>
<p>使用Serializable接口实现序列化很简单，只要让对应的类实现该接口即可。然后程序可以通过两个步骤序列化对象</p>
<ol type="1">
<li><p>创建一个ObjectOutputStream，这个输出流是一个处理流，必须建立在其他节点流的基础上</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.txt&quot;</span>));</span><br></pre></td></tr></table></figure></p></li>
<li><p>调用ObjectOutputStream对象的writeObject()方法输出该可序列化对象</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oos.writeObject(per);</span><br></pre></td></tr></table></figure></p>
<p>下面程序定义了一个可序列化的类：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span>&#123;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>然后使用ObjectOutputStream将Person对象写入磁盘文件</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> (<span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> 									<span class="title class_">FileOutputStream</span>(<span class="string">&quot;transient.txt&quot;</span>)))</span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">                        oos.writeObject(per);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e)</span><br><span class="line">                &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<p>从IO流中恢复该Java对象，即反序列化，也需两步：</p>
<ol type="1">
<li><p>创建ObjectInputStream处理流：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.txt&quot;</span>));</span><br></pre></td></tr></table></figure></p></li>
<li><p>调用ObjectInputStream对象的readObject()方法读取流中的对象，该方法返回一个Object对象，如果程序知道该Java对象类型，应强制转换，代码：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br></pre></td></tr></table></figure></p>
<p>完整的从object文件读取Java对象：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadObject</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(object.txt)))</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">            </span><br><span class="line">            System.out.println(<span class="string">&quot;名字为&quot;</span> + p.getName() + <span class="string">&quot;年龄为&quot;</span> + p.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong></p>
<ol type="1">
<li>反序列化读取的仅仅是Java对象的数据，不是Java类，因此采用反序列化恢复Java对象时，必须提供Java对象所属类的class文件，否则将会引发ClassNotFoundException异常。</li>
<li>Person类只有一个有参数的构造器，没有无参数的构造器，而且该构造器有打印语句，但反序列化java对象时，没有看到程序调用该构造器，说明反序列化机制不需要通过构造器来初始化Java对象。</li>
<li><strong>当使用序列化机制向文件写入多个Java对象，使用反序列化机制时必须按写入的顺序来读取</strong>。</li>
<li>当一个可序列化类有多个父类时(包括直接父类和间接父类)，这些父类要么有无参数的构造器，要么也是可序列化的，否则反序列化时会抛出InvalidClassException异常，如果父类是不可序列化的，只是带有无参数的构造器，则该父类定义的成员变量值不会序列化到二进制流中。</li>
</ol>
<p>## 对象引用的序列化</p>
<p>之前介绍的序列化对象对应的类Person，两个成员变量分别是String和int类型，如果某个类的成员变量不是基本类型或者String类型，而是另一种引用类型，那么这个引用类型必须是可序列化的，否则拥有该变量的类也是不可序列化的。<strong>换句话说，只有一个类的所有成员变量对应的类都是可序列化的，这个类才是可序列化的，基本类型和String已经实现了可序列化。</strong></p>
<p>比如Teacher类里有一个成员变量是Person类，只有Person是可序列化的，Teacher才是可序列化的。</p>
<p>那么现在假设有一种特殊的情形，程序有两个Teacher对象，它们的student实例变量都引用同一个Person对象，而且该Person对象还有一个引用变量引用它，代码如下：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;唐僧&quot;</span>, per);</span><br><span class="line"><span class="type">Teacher</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;菩提祖师&quot;</span>, per);</span><br></pre></td></tr></table></figure></p>
<p>上面代码创建了两个Teacher对象和一个Person对象，这里产生了一个问题，如果先序列化t1对象，则系统会将t1对象引用的Person对象一起序列化，如果程序再序列化t2对象，系统会序列化t2对象，如果再序列化per对象，系统会再次序列化该Person对象，整个过程似乎会序列化三个Person对象。</p>
<p>那么当输入流反序列化这些对象时，将会得到三个Person对象，从而引起t1和t2对象引用的不是同一个Person对象，这违背了Java序列化机制的初衷。</p>
<p>所以Java序列化机制采用特殊序列化算法如下：</p>
<ul>
<li>所有保存到磁盘中的对象都有一个序列化编号</li>
<li>当程序试图序列化一个对象，程序先检查该对象是否已经被序列化过，只有该对象从未(在本次虚拟机中)被序列化过，系统才会将该对象转换成字节序列输出</li>
<li>如果某个对象已经被序列化，程序将只输出一个序列化编号，而不是重新序列化该对象</li>
</ul>
<p>根据上述序列化算法，可以知道当第二次第三次序列化Person对象时，程序将只会输出一个序列化编号。</p>
<p><strong>注意</strong></p>
<p>这种序列化算法也会引起潜在问题，当多次序列化一个对象时，只有第一次会序列化该对象，那么当第一次序列化该对象时，如果修改了该对象成员变量的值，再次序列化，也只会输出一个序列化编号，即第一次序列化的对象，因此改变的成员变量值不会被输出。</p>
<p><strong>所以在序列化Java对象时，一定要注意，只有第一次序列化才会将对象转换成字节序列，在后面程序中，即使该对象实例变量发生改变，再次调用writeObject方法时，改变的实例变量也不会被输出。</strong></p>
<p>## Java 9增加的过滤功能</p>
<p>Java
9为ObjectInputStream增加了setObjectFilter(),getObjectFilter()两个方法，其中一个方法为对象输入流设置过滤器，当程序通过ObjectInputStream反序列化对象时，过滤器的checkInput()方法会被自动激发，用于检查序列化数据是否有效。</p>
<p>使用checkInput()方法检查序列化数据有三种返回值：</p>
<ul>
<li>Status.REJECTED:拒绝恢复</li>
<li>Status.ALLOWED:允许恢复</li>
<li>Status.UNDECIDED:未决定状态，程序将继续执行检查</li>
</ul>
<p>ObjectInputStream会根据ObjectInputFilter检查结果来决定是否执行反序列化，如果返回Status.REJECTED，反序列化将会被阻止，返回ALLOWED，反序列化会被执行。</p>
<p>例子：该程序会在反序列化之前对数据执行检查：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			ois.setObjectInputFilter((info) -&gt; &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;===执行数据过滤===&quot;</span>);</span><br><span class="line">				<span class="type">ObjectInputFilter</span> <span class="variable">serialFilter</span> <span class="operator">=</span> ObjectInputFilter.Config.getSerialFilter();</span><br><span class="line">					<span class="keyword">if</span> (serialFilter != <span class="literal">null</span>) &#123;</span><br><span class="line">						<span class="comment">// 首先使用ObjectInputFilter执行默认的检查</span></span><br><span class="line">						ObjectInputFilter.<span class="type">Status</span> <span class="variable">status</span> <span class="operator">=</span> serialFilter.checkInput(info);</span><br><span class="line">						<span class="comment">// 如果默认检查的结果不是Status.UNDECIDED</span></span><br><span class="line">						<span class="keyword">if</span> (status != ObjectInputFilter.Status.UNDECIDED) &#123;</span><br><span class="line">							<span class="comment">// 直接返回检查结果</span></span><br><span class="line">							<span class="keyword">return</span> status;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 如果要恢复的对象不是1个</span></span><br><span class="line">					<span class="keyword">if</span> (info.references() != <span class="number">1</span>)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// 不允许恢复对象</span></span><br><span class="line">						<span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (info.serialClass() != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">						<span class="comment">// 如果恢复的不是Person类</span></span><br><span class="line">						info.serialClass() != Person.class)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// 不允许恢复对象</span></span><br><span class="line">						<span class="keyword">return</span> ObjectInputFilter.Status.REJECTED;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> ObjectInputFilter.Status.UNDECIDED;</span><br><span class="line">				&#125;);</span><br><span class="line">			<span class="comment">// 从输入流中读取一个Java对象，并将其强制类型转换为Person类</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">			System.out.println(<span class="string">&quot;名字为：&quot;</span> + p.getName()</span><br><span class="line">				+ <span class="string">&quot;\n年龄为：&quot;</span> + p.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码重写了checkInput方法，先使用默认的ObjectInputFilter执行检查，如果检查结果不是Status.UNDECIDED，程序直接返回检查结果，接下来通过FilterInfo检查序列化数据，如果序列化数据不唯一，拒绝执行，如果不是Person对象，拒绝执行，通过这种检查，程序可以保证反序列化出来的是唯一的Person对象。</p>
<p>## 自定义序列化</p>
<p>在一些特殊的情景，如果一个类的某些实例变量是敏感信息，这时不希望程序将该实例变量进行实例化，或者某个实例变量类型是不可序列化的，因此不希望对该实例变量进行递归序列化。</p>
<p><strong>递归序列化</strong>：</p>
<p>当对某个对象进行序列化时，系统会自动把该对象的所有实例变量依次进行序列化，如果某个实例变量引用到另一个对象，则该引用的对象也会被序列化，这样一层一层的递归的进行对象序列化，就是递归序列化。</p>
<p>通过在实例变量前面使用transient关键词修饰，可以指定Java序列化时无需理会该实例变量。</p>
<p>例子：</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">transient</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// name的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// age的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong></p>
<p>transient关键词只能用于修饰实例变量，不可修饰Java程序其他成分。</p>
<p>下面先序列化一个Person对象，然后反序列化读取，再输出age变量</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransientTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;transient.txt&quot;</span>));</span><br><span class="line">			<span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;transient.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">			<span class="comment">// 系统会per对象转换字节序列并输出</span></span><br><span class="line">			oos.writeObject(per);</span><br><span class="line">			<span class="type">var</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">			System.out.println(p.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>age使用transient关键词修饰，所以输出age的值为0.</p>
<p>使用transient关键词修饰实例变量虽然简单，方便，但是所修饰的实例变量将被完成隔离在序列化机制之外，这样导致反序列化时无法取得该实例变量值，Java提供了一种自定义序列化机制，可以让程序控制如何序列化各实例变量。</p>
<p>需要特殊处理的类应该提供如下特殊签名的方法，这些方法用于实现自定义序列化。</p>
<p><strong>private void writeObject(java.io.ObjectOutputStream out)
throws IOException</strong></p>
<p>功能：负责写入特定类的实例状态，以便readObject()如何恢复它</p>
<p>参数:out:特定对象输出流</p>
<p>返回值：无</p>
<p><strong>注：</strong></p>
<p>默认情况，该方法会调用out.defaultWriteObject来保存Java对象实例变量。</p>
<hr />
<p><strong>private void writeObject(java.io.ObjectOutputStream out)
throws IOException</strong></p>
<p>功能：负责从流中读取并恢复实例变量</p>
<p>参数:in:特定对象输入流</p>
<p>返回值：无</p>
<p><strong>注：</strong></p>
<p>默认情况，该方法会调用in.defaultReadObject来恢复Java对象的非瞬态实例变量，通常情况，readObject和writeObject方法相对应。</p>
<hr />
<p><strong>private void readObjectNoData() throws
ObjectStreamException</strong></p>
<p>功能：如果序列化流不完整，此方法可以正确初始化反序列化的对象，例如，接收方使用的反序列化类版本不同于发送方，或者序列化流被篡改时，系统调用此方法初始化反序列化的对象。</p>
<hr />
<p>下面Person类重写了writeObject方法和readObject方法，其中写入时先将name变量包装成SringBuffer，然后反转进行写入，读取时，先将读取的数据强制类型转换为StringBuffer，再将其反转后赋给name变量。</p>
<p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// name的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// age的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream out)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将name实例变量的值反转后写入二进制流</span></span><br><span class="line">		out.writeObject(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(name).reverse());</span><br><span class="line">		out.writeInt(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(java.io.ObjectInputStream in)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">		<span class="built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse()</span><br><span class="line">			.toString();</span><br><span class="line">		<span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于这个Person类而言，序列化和反序列化Person实例与不重写两个方法效果一样，区别在于序列化后的处理流，即使有Cracker截获到Person对象流，它看到的也是加密后的name，提高了序列化的安全性。</p></li>
</ol>
<p><strong>注意：</strong></p>
<p>writeObject方法存储实例变量的顺序应该和readObject方法恢复实例变量的顺序一致。</p>
<p>还有一种更彻底的自定义机制，它甚至可以在序列化对象之前，将该对象替换成其他对象，如果需要，则应该为序列化类提供如下特殊方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ANY_ACCESS_MODIFIER Object <span class="title function_">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span><br></pre></td></tr></table></figure>
<p>此序列化方法由序列化机制调用，只要该方法存在。因为该方法可以拥有private、protected和包私有权限，所以子类可能获得该方法。</p>
<p>下面例子提供了writeReplace方法，可以在写入Person对象是将该对象替换成ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 注意此处没有提供无参数的构造器!</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// name的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// age的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//	重写writeReplace方法，程序在序列化该对象之前，先调用该方法</span></span><br><span class="line">	<span class="keyword">private</span> Object <span class="title function_">writeReplace</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span><br><span class="line">	&#123;</span><br><span class="line">		ArrayList&lt;Object&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		list.add(name);</span><br><span class="line">		list.add(age);</span><br><span class="line">		<span class="keyword">return</span> list;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java序列化机制保证在序列化某个对象之前，先调用该对象的writePeplace方法，如果该对象返回另一个Java对象，则需系统转为序列化另一个对象。如下程序表明序列化Person对象，实际序列化的是ArrayList对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReplaceTest</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">try</span> (</span><br><span class="line">			<span class="comment">// 创建一个ObjectOutputStream输出流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;replace.txt&quot;</span>));</span><br><span class="line">			<span class="comment">// 创建一个ObjectInputStream输入流</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;replace.txt&quot;</span>)))</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">var</span> <span class="variable">per</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">500</span>);</span><br><span class="line">			<span class="comment">// 系统将per对象转换字节序列并输出</span></span><br><span class="line">			oos.writeObject(per);</span><br><span class="line">			<span class="comment">// 反序列化读取得到的是ArrayList</span></span><br><span class="line">			<span class="type">var</span> <span class="variable">list</span> <span class="operator">=</span> (ArrayList) ois.readObject();</span><br><span class="line">			System.out.println(list);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex)</span><br><span class="line">		&#123;</span><br><span class="line">			ex.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>综上所述，系统在序列化某个对象之前，首先调用该对象的writeReplcae方法，如果该方法返回另一个对象，系统将再次调用另一个对象的writeReplace方法，直到该方法不再返回另一个对象为止。然后程序最后调用该对象的writeObject方法保存对象状态。</p>
<p>与writeReplace方法相对应的是，序列化机制还有一个特殊的方法，它可以实现保护性复制整个对象，该方法是：</p>
<p><code>ANY_ACCESS_MODIFIER Object readResolve() throws
ObjectStreamException</code></p>
<p>这个方法会在readObject方法调用后被调用，该方法的返回值会替代原来反序列化的对象，而原来使用readObject方法反序列化的对象会被丢弃。</p>
<p>readResolve方法在序列化单例类。枚举类时尤其有用。</p>
<p>例如下面一个枚举类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Orientation</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Orientation</span> <span class="variable">HORIZONTAL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Orientation</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Orientation</span> <span class="variable">VERTICAL</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Orientation</span>(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Orientation</span><span class="params">(<span class="type">int</span> value)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.value = value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>该枚举类构造器私有，程序有两个Orientation对象，但如果让该类实现Serializable接口，会引发一个问题，如果将Orientation.HORIZONTAL值序列化后再读入，如果立即拿读入后的对象与Orientation.HORIZONTAL进行比较，返回false，也就是说读入的对象是一个新的Orientation对象，而不等于Orientation类中的任何枚举类，虽然Orientation的构造器是私有的，但反序列化依然可以创建新的Orientation对象。</p>
<p><strong>提示</strong>：</p>
<p>反序列化机制在恢复Java对象时无序调用构造器来初始化对象，从这个意义上看，序列化对象可以“克隆”对象。</p>
<p>在这种情况下，可以为Orientation类提供一个readResolve方法来解决，readResolve方法返回值会代替原反序列化对象，也就是让反序列化得到的Orientation对象直接被丢弃。</p>
<p>如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 为枚举类增加readResolve()方法</span></span><br><span class="line">	<span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> HORIZONTAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (value == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> VERTICAL;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过重写readResolve方法可以保证反序列化得到的依然是Orientation的两个枚举对象之一。</p>
<p><strong>注意</strong>：所有单例类、枚举类序列化时都应该提供readResolve方法，这样才能保证反序列化的对象依然正常。</p>
<p>与writeReplace方法类似，readResolve方法一可以用任意访问控制符，因此父类readResolve方法可能被子类继承，这样使用该方法就会存在明显的缺点：当父类已经实现readResolve方法，子类将变得无从下手，如果父类包含protected或public的readResolve方法，而且子类没有重写该方法，会使得子类反序列化时得到一个父类的对象。总是让子类重写readResolve方法无疑是个负担。因此对于要作为父类继承的类而言，实现readResolve方法可能会有潜在危险。
<strong>通常建议时，对于final类重写readResolve方法不会有任何问题，因为该类不可以被继承，否则重写readResolve尽量使用private修饰。</strong></p>
<h2 id="另一种自定义序列化机制">另一种自定义序列化机制</h2>
<p>Java提供了另一种序列化机制，即Externalizable接口，这种序列化方式完全由程序员决定存储和恢复对象数据，该接口定义了两个方法。</p>
<p><strong>void readExternal(ObjectInput in)</strong></p>
<p>功能：实现反序列化，从输入流中读取对象</p>
<p>参数：in:输入流</p>
<p>返回值：无</p>
<p><strong>注</strong></p>
<p>该方法调用DataInput的方法来恢复<strong>基本类型</strong>的实例变量值，调用ObjectOutput的writeObject()方法来保存<strong>引用类型</strong>的实例变量。</p>
<hr />
<p><strong>void writeExternal(ObjectOutput out)</strong></p>
<p>功能：实现序列化</p>
<p>参数：out：输出流</p>
<p>返回值：无</p>
<p><strong>注</strong></p>
<p>该方法调用DataOutput的方法来保存<strong>基本类型</strong>的实例变量值，使用ObjectOutput的writeObject方法保存<strong>引用类型</strong>的实例变量值。</p>
<hr />
<p>实际上，采用Externalizable接口序列化和前面的Serializable序列化很相似，只是Externalizable强制自定义序列化，必须要实现上述两个方法，下面的Person类实现了Externalizable接口，并且实现了该接口的两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">	<span class="keyword">implements</span> <span class="title class_">java</span>.io.Externalizable</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	<span class="comment">// 注意必须提供无参数的构造器，否则反序列化时会失败。</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;有参数的构造器&quot;</span>);</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 省略name与age的setter和getter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// name的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// age的setter和getter方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(java.io.ObjectOutput out)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将name实例变量的值反转后写入二进制流</span></span><br><span class="line">		out.writeObject(<span class="keyword">new</span> <span class="title class_">StringBuffer</span>(name).reverse());</span><br><span class="line">		out.writeInt(age);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(java.io.ObjectInput in)</span></span><br><span class="line">		<span class="keyword">throws</span> IOException, ClassNotFoundException</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 将读取的字符串反转后赋给name实例变量</span></span><br><span class="line">		<span class="built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();</span><br><span class="line">		<span class="built_in">this</span>.age = in.readInt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果程序需要序列化实现Externalizable接口对象，一样调用writeObject方法，反序列化则调用readObject方法，和之前用法一样。</p>
<p><strong>注意</strong>：</p>
<p>当时用Externalizable机制反序列化对象时，程序会首先使用public的无参数构造器创建实例，然后才执行readExternal方法进行反序列化，因此<strong>实现Externalizable的序列化类必须提供public的无参数构造器</strong>。</p>
<h2 id="两种序列化机制对比">两种序列化机制对比</h2>
<table>
<colgroup>
<col style="width: 54%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="header">
<th>实现Serializable接口</th>
<th>实现Externalizable接口</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>系统自动存储必要信息</td>
<td>程序员决定存储哪些信息</td>
</tr>
<tr class="even">
<td>Java内建支持，易于实现，只需实现该接口即可，无需任何代码支持</td>
<td>仅提供两个空方法，实现该接口要为两个空方法提供实现</td>
</tr>
<tr class="odd">
<td>性能略差</td>
<td>性能略好</td>
</tr>
</tbody>
</table>
<p>虽然Externalizable接口性能较好，但是实现Externalizable接口导致编程复杂，所以但部分时候还是使用Serializable接口。</p>
<p>关于对象序列化，以下几点需要注意：</p>
<ul>
<li>对象的类名、实例变量(包括基本类型、数组、对其他对象的引用)，都会被序列化，但是方法，类变量，transient实例变量(也被称为瞬态实例变量)不会被序列化</li>
<li>实现Serializable接口的类如果需要让某个实例变量不被序列化，应该添加transient关键词，而不应该用static修饰，虽然也可达到这个效果，但这个关键词不是这么用的，而且也会出现其他问题。</li>
<li>保证序列化对象的实例变量类型也是可序列化的。</li>
<li>反序列化对象必须有序列化对象的class文件</li>
<li>当通过文件、网络读取序列化后的对象时，必须按实际写入的顺序读取。</li>
</ul>
<p>##　版本</p>
<p>反序列化对象时必须提供该对象对应类的class文件，现在问题是，随着项目升级，系统的class文件也会升级，Java如何保证class文件的兼容性。</p>
<p>Java序列化机制允许为序列化类提供一个private static
final的serialVersionUID值，该类变量的值用于标识该Java类的序列化版本，也就是说，如果一个类升级以后，只要它的serialVersionUID值不变，序列化机制会把它们当成同一个序列化版本。</p>
<p>分配serialVersionUID值很简单，</p>
<p><code>private static final long serialVersionUID = 512L;</code></p>
<p>为了在反序列化时确保序列化版本的兼容性，最好在每个序列化类中加入这个类变量，具体数值可以自己定义，这样即使在某个对象被序列化后，它所对应的类被修改了，该对象也容易被正确反序列化。</p>
<p>每个类的serialVersionUID值都是唯一的，也就是说不同类的serialVersionUID值不应该相同。</p>
<p>如果不显式指定这个类变量的值，该类变量的值由JVM根据类的相关信息计算，而修改后的类的计算结果和之前的计算结果往往不同，造成对象反序列化因为类版本不兼容而失败。</p>
<p>不显式指定这个serialVersionUID值的另一个坏处是，不利于程序在不同JVM之间移植，因为不同编译器对该类变量的计算策略可能不同，从而造成类可能没有改变，但是serialVersionUID值不同。</p>
<p>那么对类的哪些修改可能会导致改变serialVersionUID值呢？</p>
<p>分三种情况讨论：</p>
<ul>
<li><p>如果修改类时仅仅修改了静态变量或者瞬态实例变量，则反序列化不受任何影响，serialVersionUID值不会改变</p></li>
<li><p>如果修改类时，仅仅修改了方法，则反序列化不受任何影响，serialVersionUID值不改变</p></li>
<li><p>如果修改类时修改了非瞬态的实例变量，则可能导致序列化版本不兼容。</p>
<ol type="1">
<li>如果对象流中的对象与新类中包含同名的实例变量，而实例变量类型不同，则反序列化失败，serialVersionUID值会改变</li>
<li>如果对象流的对象比新类中包含更多的实例变量，即新类删除了部分实例变量，则多出的实例变量值被忽略，序列化版本可以兼容，serialVersionUID值不会改变</li>
<li>如果新类比对象流中的对象包含更多的实例变量，即新类增加了一些实例变量，那么序列化版本也可以兼容，serialVersionUID值不会更新，但是反序列化中的对象得到的新对象多出来的实例变量值都是null(引用类型变量)或者0(基本类型变量)。</li>
</ol></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># Java基础</a>
              <a href="/tags/io/" rel="tag"># 输入输出</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/" rel="prev" title="重定向输入输出">
                  <i class="fa fa-chevron-left"></i> 重定向输入输出
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84IO%E6%B5%81/" rel="next" title="Java的IO流">
                  Java的IO流 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ZhaoXin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
