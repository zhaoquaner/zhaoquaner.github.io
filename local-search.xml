<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>73-N叉树的层序遍历</title>
    <link href="/2022/05/11/leetcode/%E6%A0%91/73-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <url>/2022/05/11/leetcode/%E6%A0%91/73-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20220128141450375.png" alt="image-20220128141450375" style="zoom:57%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用层次遍历算法，用到数据结构队列queue。</p><p>遍历每一层时，需要确定该层是否遍历结束。则需要设置一个标志变量<code>last</code>，初始指向根节点， 遍历节点时，判断该节点与<code>last</code>是否相等。</p><p>若相等，则代表该层已遍历完毕，若queue不为空，则队尾元素为下一层的末尾节点，将last指向该节点；</p><p>若不相等，则正常执行。</p><p>把每一层节点值存入数组中即可。</p><p>注：此题childen类型是数组，因此可直接使用数组长度来判断是否到末尾节点。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> val;<br>    vector&lt;Node*&gt; children;<br>    <span class="hljs-built_in">Node</span>() &#123;&#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _val) &#123;<br>        val = _val;<br>    &#125;<br>    <span class="hljs-built_in">Node</span>(<span class="hljs-type">int</span> _val, vector&lt;Node*&gt; _children) &#123;<br>        val = _val;<br>        children = _children;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(Node* root) &#123;<br><br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;<br>        <span class="hljs-comment">// 指向每一层末尾节点</span><br>        Node * last = root;<br>        <span class="hljs-comment">// 遍历树</span><br>        Node * p = <span class="hljs-literal">nullptr</span>;<br>        queue&lt;Node *&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br><br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; tmp;<br>            <span class="hljs-comment">// 判断遍历节点与末尾节点是否相等</span><br>            <span class="hljs-keyword">while</span>(p != last) &#123;<br>                p = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                tmp.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; p-&gt;children.<span class="hljs-built_in">size</span>(); i++) &#123;<br>                    q.<span class="hljs-built_in">push</span>(p-&gt;children[i]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 修改末尾节点指向</span><br>            last = q.<span class="hljs-built_in">back</span>();<br>            res.<span class="hljs-built_in">push_back</span>(tmp);<br>        &#125;<br>        <br><span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>72-笨阶乘</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/72-%E7%AC%A8%E9%98%B6%E4%B9%98/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/72-%E7%AC%A8%E9%98%B6%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210627214441012.png" alt="image-20210627214441012" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>四次运算为1个轮回，求n的笨阶乘，则需要n - 1次运算。</p><p>使用一个栈，乘除直接算，加减先入栈。最后将栈中元素累加即可。</p><p>使用i作为循环变量，初始为0，共循环n- 1次，所以条件为i &lt; n - 1。计算 i % 4。</p><p>共有四种情况：0 乘， 1 除， 2 加，3 减。</p><p>对于乘除：取出栈顶元素，进行相应运算后入栈。</p><p>对于加减：加运算将原数入栈，减运算将相反数入栈。</p><p>最后将栈中元素累加。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clumsy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> num = n - <span class="hljs-number">1</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        s.<span class="hljs-built_in">push</span>(n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> num1 = s.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">switch</span> (i % <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    s.<span class="hljs-built_in">pop</span>();<br>                    s.<span class="hljs-built_in">push</span>(num1 * num);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    s.<span class="hljs-built_in">pop</span>();<br>                    s.<span class="hljs-built_in">push</span>(num1 / num);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    s.<span class="hljs-built_in">push</span>(num);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    s.<span class="hljs-built_in">push</span>(-num);<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            num--;<br>        &#125;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            sum += s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><p>​            </p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>71-检查替换后的词是否有效</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/71-%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/71-%E6%A3%80%E6%9F%A5%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E8%AF%8D%E6%98%AF%E5%90%A6%E6%9C%89%E6%95%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210627210049673.png" alt="image-20210627210049673" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>类似于消消乐，当遇到一个连续的abc就去掉，遍历完，看是否为空串。如果为空串，证明有效，否则无效。</p><p>使用一个栈用来存放字符。</p><p>遍历字符串，当栈的元素个数大于2并且当前字符为c并且栈顶元素为b时，查看栈中第二个元素是否为a，如果为a，则证明遇到了一个连续的abc，去掉；否则将当前字符入栈。</p><p>遍历完成，查看栈是否为空。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-number">2</span> &amp;&amp; ch == <span class="hljs-string">&#x27;c&#x27;</span> &amp;&amp; stack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;b&#x27;</span>) &#123;<br>                <span class="hljs-type">char</span> top = stack.<span class="hljs-built_in">top</span>();<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    stack.<span class="hljs-built_in">push</span>(top);<br>                    stack.<span class="hljs-built_in">push</span>(ch);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p><h3 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>其实也不算新的思路。只是做了一些优化。平均的时间复杂度更好一些。</p><p>上一个思路使用的是栈，只能访问栈顶元素。可以使用数组，这样所有元素就都可以访问。</p><p>并且只要能够判定该字符串一定无效，就直接返回false，而不再继续遍历。</p><p>对于访问的字符，有三种情况：</p><ol><li><code>a</code>：直接添加到数组中</li><li><code>b</code>：查看数组是否为空，如果为空，证明一定无效，返回false</li><li><code>c</code>：查看数组长度是否小于2，如果小于2，证明一定无效，返回false。如果大于等于2，判断当前数组末尾元素时是否为b和当前末尾的前一个元素是否为a，只要有一个判断为false，就证明该字符串无效，返回false。如果都正确，就证明这是一个连续的abc，去掉，然后继续遍历。</li></ol><p>可以使用top变量表示当前数组末尾的索引。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">char</span> array[s.<span class="hljs-built_in">size</span>()];<br>        <span class="hljs-type">int</span> top = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">switch</span> (ch) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>                    array[++top] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;b&#x27;</span>:<br>                    <span class="hljs-keyword">if</span>(top == <span class="hljs-number">-1</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    array[++top] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>                    <span class="hljs-keyword">if</span>(top &lt; <span class="hljs-number">1</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(array[top] != <span class="hljs-string">&#x27;b&#x27;</span> || array[top - <span class="hljs-number">1</span>] != <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    top -= <span class="hljs-number">2</span>;<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> top == <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。也可以直接将数组的大小设为字符串长度最大值，这样空间复杂度变为$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>70-二叉树展开为链表</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/70-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/70-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210626203748424.png" alt="image-20210626203748424" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用递归。</p><p>递归函数：flattenTree。</p><p>函数功能：将给定树按先序遍历展开为单链表</p><p>函数参数：根节点root</p><p>函数返回值：展开为单链表的头节点</p><p>递归终止条件：传入的树根节点为空</p><p>具体实现：</p><p>首先要将root的左子树展开为单链表，root的右指针指向展开后的链表头节点。</p><p>因此首先保存root的右子树的根节点right_tree。</p><p>然后递归调用flattenTree，参数为root-&gt;left，root的右指针指向返回值。</p><p>然后从root遍历该链表，找到该链表的最后一个节点用来连接右子树展开后的单链表头节点。</p><p>最后展开右子树，连接起来即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">flattenTree</span>(root);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode * <span class="hljs-title">flattenTree</span><span class="hljs-params">(TreeNode * root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        TreeNode * right_tree = root-&gt;right;<br>        root-&gt;right = <span class="hljs-built_in">flattenTree</span>(root-&gt;left);<br>        root-&gt;left = <span class="hljs-literal">nullptr</span>;<br>        TreeNode * left_head = root;<br>        <span class="hljs-keyword">while</span> (left_head-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>            left_head = left_head-&gt;right;<br>        &#125;<br>        left_head-&gt;right = <span class="hljs-built_in">flattenTree</span>(right_tree);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>设节点数为n。</p><p>时间复杂度：$O(n^2)$。共调用递归函数n次。遍历节点最好情况是每个节点都只有右子树，共遍历n次，最坏情况为每个节点都只有左子树，共遍历$\frac{n*(n - 1)}{2}$次。</p><p>空间复杂度：$O(n)$。最坏情况二叉树只有左子树或右子树，那么深度是n。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>寻找前驱结点。</p><p>按先序遍历的顺序，对于以root为根的树来说，root左子树的最右节点的下一个节点就是root的右子节点。</p><p>所以可以找到root的左子树的最右节点right_node，也就是先序遍历root左子树的序列的最后一个节点。</p><p>然后让该节点的右指针指向root的左子树的根节点，然后root的右指针指向root的左子树的根节点，最后root左指针置为空。</p><p>这样就完成了左子树与右子树的连接。使用cur指向当前要处理的树的根节点，依次遍历cur的右指针，直到cur为空。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        TreeNode * cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;left != <span class="hljs-literal">nullptr</span>) &#123;<br>                TreeNode * right_node = cur-&gt;left;<br>                <span class="hljs-keyword">while</span> (right_node-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>                    right_node = right_node-&gt;right;<br>                &#125;<br>                right_node-&gt;right = cur-&gt;right;<br>                cur-&gt;right = cur-&gt;left;<br>                cur-&gt;left = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            cur = cur-&gt;right;<br>        &#125;<br>    &#125;<br>    <br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。展开为单链表时，每个节点访问了一次。寻找前驱结点时，每个节点最多被访问一次。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>69-最大二叉树</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/69-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/69-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210625200406778.png" alt="image-20210625200406778" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>写一个递归函数：constructTree。</p><p>功能：将输入的数组转化成一个最大二叉树</p><p>参数：数组nums，左边界left，右边界right</p><p>返回值：该二叉树的根节点</p><p>递归终止条件：left &gt; right。</p><p>递归函数具体实现：</p><p>找到该数组中最大元素，以该元素的值建立根节点，然后递归，传入该元素的左边数组和右边数组。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> Solution &#123;<br>public:<br>    TreeNode* construct<span class="hljs-constructor">MaximumBinaryTree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>)</span> &#123;<br>        return construct<span class="hljs-constructor">Tree(<span class="hljs-params">nums</span>, 0, <span class="hljs-params">nums</span>.<span class="hljs-params">size</span>()</span> - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    TreeNode<span class="hljs-operator"> * </span>construct<span class="hljs-constructor">Tree(<span class="hljs-params">vector</span>&lt;<span class="hljs-params">int</span>&gt;&amp; <span class="hljs-params">nums</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(left &gt; right) &#123;<br>            return nullptr;<br>        &#125;<br>        <span class="hljs-built_in">int</span> max_index = left;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = left + <span class="hljs-number">1</span>; i &lt;= right; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums<span class="hljs-literal">[<span class="hljs-identifier">max_index</span>]</span> &lt; nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) &#123;<br>                max_index = i;<br>            &#125;<br>        &#125;<br>        TreeNode<span class="hljs-operator"> * </span>node = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TreeNode(<span class="hljs-params">nums</span>[<span class="hljs-params">max_index</span>])</span>;<br>        node-&gt;left = construct<span class="hljs-constructor">Tree(<span class="hljs-params">nums</span>, <span class="hljs-params">left</span>, <span class="hljs-params">max_index</span> - 1)</span>;<br>        node-&gt;right = construct<span class="hljs-constructor">Tree(<span class="hljs-params">nums</span>, <span class="hljs-params">max_index</span> + 1, <span class="hljs-params">right</span>)</span>;<br>        return node;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n^2)$。一共被调用n次，每次找根节点时，都需要遍历当前索引范围内所有元素。总复杂度$O(nlogn)$。最坏情况是，nums有序，每次都要遍历到最后一个结点，总复杂度为$O(n^2)$。</p><p>空间复杂度：$O(n)$。平均情况，长度为n的数组递归调用深度为$O(logn)$。最坏情况为$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>68-支持增量操作的栈</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/68-%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/68-%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210622210650182.png" alt="image-20210622210650182" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>因为要有增量操作，所以所有的元素应该都是可见的。所以肯定不能用栈，可以使用数组。</p><p>并用一个index变量，来表示数组最后一个元素的索引，相当于指向栈顶元素。</p><p>inc操作，就直接比较k - 1和index的大小，较小值为min，从0到min的每个元素都加上val即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomStack</span>(<span class="hljs-type">int</span> maxSize) &#123;<br>        nums.<span class="hljs-built_in">resize</span>(maxSize);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index != nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            nums[++index] = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> nums[index--];<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-type">int</span> min = k &lt; index ? k : index;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; min; i++) &#123;<br>            nums[i] += val;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：push和pop操作为$O(1)$，increment操作为$O(n)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><p>有两种，第一种和我的相同。</p><p>只说第二种。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>同样使用数组来做。</p><p>push和pop操作时间复杂度都是<script type="math/tex">O(1)</script>，所以要优化inc操作，使它的时间复杂度降为<script type="math/tex">O(1)</script>。</p><p>可以添加一个数组add，add[i]就是nums[i]应该要增加的值。</p><p>并且如果k个元素加1，将k - 1和index比较，较小值为min，我们知道从0 到 min的元素都要加1，所以我们可以只给第 min个元素加1，即add[min] = 1。</p><p>当要弹出栈顶元素时，就返回<code>nums[index] + add[index]</code>，即它原来的值和应该增加的值。</p><p>并且将add[index]加到add[index - 1]上。 </p><p>也就是说，每个元素只有在弹出的时候，才会知道它实际的值。</p><p>例如：maxSize是3。</p><p>首先插入三个数字 1 2 3。这时栈为 1 2 3。add数组为 0 0 0。</p><p>然后执行<code>inc(3, 1)</code>, <code>inc(2, 1)</code>, <code>inc(1, 1)</code>。即栈底3个元素、2个元素、1个元素分别加1。三个元素值都应为4</p><p>这时add数组变为：1 1 1。当弹出栈顶元素3时，弹出<code>3 + 1 = 4</code>。并将add[index]加到add[index - 1]上，然后add[index]置为0。这时候add数组变为 1 2 0。</p><p>再弹出2，应该是 <code>2 + 2= 4</code>。add数组变为3 0 0。最后弹出<code>1 + 3 = 4</code>。 </p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>    vector&lt;<span class="hljs-type">int</span>&gt; add;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CustomStack</span>(<span class="hljs-type">int</span> maxSize) &#123;<br>        nums.<span class="hljs-built_in">resize</span>(maxSize);<br>        add.<span class="hljs-built_in">resize</span>(maxSize);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index != nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            nums[++index] = x;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> res = nums[index] + add[index];<br>        <span class="hljs-keyword">if</span>(index != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 将待弹出的元素要增加的值加到下一个栈顶元素的add数组对应位置</span><br>            add[index - <span class="hljs-number">1</span>] += add[index];<br>        &#125;<br>        add[index] = <span class="hljs-number">0</span>;<br>        index--;<br>        <span class="hljs-keyword">return</span> res;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">increment</span><span class="hljs-params">(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 取 k - 1和index的较小值</span><br>        <span class="hljs-type">int</span> min = k - <span class="hljs-number">1</span> &lt; index ? k - <span class="hljs-number">1</span> : index;<br>        <span class="hljs-keyword">if</span>(min &gt;= <span class="hljs-number">0</span>) &#123;<br>            add[min] += val;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：三个操作都是$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>67-验证栈序列</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/67-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/67-%E9%AA%8C%E8%AF%81%E6%A0%88%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210620211818472.png" alt="image-20210620211818472" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用一个栈nums，遍历pushed队列，将元素入栈，使用一个指针指向popped序列的第一个待验证元素，并判断栈顶元素是否和该待验证元素相等，如果相等，就出栈，并将待验证指针后移一个，继续判断，直到栈为空，或待验证指针为空，或两元素不相等。</p><p>最后判断nums栈是否 为空，如果为空，证明栈序列正确，否则错误。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">validateStackSequences</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; pushed, vector&lt;<span class="hljs-type">int</span>&gt;&amp; popped)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>        <span class="hljs-type">int</span> n = popped.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">//待验证元素指针</span><br>        <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; pushed.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            nums.<span class="hljs-built_in">push</span>(pushed[i]);<br>            <span class="hljs-keyword">while</span> (!nums.<span class="hljs-built_in">empty</span>() &amp;&amp; j &lt; n &amp;&amp; nums.<span class="hljs-built_in">top</span>() == popped[j]) &#123;<br>                nums.<span class="hljs-built_in">pop</span>();<br>                j++;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p><p>参考做法相同。</p><p>只不过在返回值处的语句是<code>j == n</code>。意思一样。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>66-字符串解码</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/66-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/66-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210618123204329.png" alt="image-20210618123204329" style="zoom:57%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用两个栈，count栈一个放数字，chars放字符。</p><p>遍历字符串，有以下几种可能情况：</p><ul><li>是数字，因为有可能是大于9的。那么就从当前字符开始，往后遍历，将遍历到的数字字符转换为数字加到num上，直到遇到第一个不是数字的字符，将num添加到count栈中</li><li><code>[</code>：直接入栈</li><li><code>]</code>：遇到<code>]</code>代表需要将该括号内的字符，循环counr.top()遍，所以chars依次出栈，并添加到temp字符串中，直到遇到<code>[</code>(一定会遇到)。此时temp就是中括号内的字符串。这时有两种情况：<ul><li>栈不为空：说明该字符串序列嵌套在另一个中括号内，如”3[a2[b]]”，那么就应该将temp字符串的字符循环count.top()遍，放入chars栈中</li><li>栈为空：说明该字符串序列并没有嵌套在其他中括号内，可以直接循环count.top()遍添加到结果字符串res中</li></ul></li><li>字符：分两种情况：<ul><li>chars不为空：说明该字符在一个中括号内，直接入栈chars</li><li>chars为空：说明该字符串是单独出现的，不需要循环。添加到res中</li></ul></li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">decodeString</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; chars;<br>        stack&lt;<span class="hljs-type">int</span>&gt; count;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; s.<span class="hljs-built_in">size</span>(); index++) &#123;<br>            <span class="hljs-type">char</span> ch = s[index];<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isdigit</span>(ch)) &#123;<br>                <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-built_in">isdigit</span>(s[index])) &#123;<br>                    num = num * <span class="hljs-number">10</span> + (s[index++] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>                &#125;<br>                <span class="hljs-comment">//因为index在循环处要加1，所以这里要减1</span><br>                index--;<br>                count.<span class="hljs-built_in">push</span>(num);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                chars.<span class="hljs-built_in">push</span>(ch);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;]&#x27;</span>) &#123;<br>                string temp = <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-keyword">while</span> (chars.<span class="hljs-built_in">top</span>() != <span class="hljs-string">&#x27;[&#x27;</span>) &#123;<br>                    temp = chars.<span class="hljs-built_in">top</span>() + temp;<br>                    chars.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                <span class="hljs-comment">//弹出`[`</span><br>                chars.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(!chars.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count.<span class="hljs-built_in">top</span>(); i++) &#123;<br>                        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; temp.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                            chars.<span class="hljs-built_in">push</span>(temp[j]);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; count.<span class="hljs-built_in">top</span>(); i++) &#123;<br>                        res += temp;<br>                    &#125;<br>                &#125;<br>                count.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(chars.<span class="hljs-built_in">empty</span>()) &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(ch);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    chars.<span class="hljs-built_in">push</span>(ch);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><p>参考给了两种做法，一种和我的类似，只不过它把数字和字母都放到同一个栈，数字紧挨着<code>[</code>。</p><p>第二种用到了编译原理的知识。给出了一个LL(1)文法，根据FOLLOW集和FIRST集构造预测分析表。</p><p>学过编译原理，但只看懂了一部分。</p><p>留个坑。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>65-使括号有效的最少添加</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/65-%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/65-%E4%BD%BF%E6%8B%AC%E5%8F%B7%E6%9C%89%E6%95%88%E7%9A%84%E6%9C%80%E5%B0%91%E6%B7%BB%E5%8A%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210618113533711.png" alt="image-20210618113533711" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这都不像是中等难度的题目。Easy~</p><p>使用栈，遍历当前字符串，如果当前字符是<code>)</code>且栈顶元素为<code>(</code>，就弹出栈，否则就入栈。</p><p>遍历结束后，栈中的元素就是需要添加的最少括号数。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; !stack.<span class="hljs-built_in">empty</span>() &amp;&amp; stack.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> stack.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>平衡法。</p><p>要使括号有效，就要保证左括号和右括号同样多。即保证左右括号数量的平衡。</p><p>计算<code>(</code>出现的次数减去<code>)</code>出现的次数，如果为0，则表示平衡，括号有效，如果小于0，那么就需要在前面补上<code>(</code>。</p><p>所以可以计算给定字符串s的每个前缀子数组的平衡度，如果该子数组平衡度值为负数，说明前面得加上个<code>(</code>；但如果是个正数，说明该子数组的<code>(</code>多于<code>)</code>，那就无法判定，可能后面还有对应的<code>)</code>。</p><p>所以可以设定两个变量ans和bal，ans表示需要添加的<code>(</code>的个数，bal表示<code>)</code>需要添加的个数。</p><p>遍历字符串，当字符为<code>(</code>，bal加1，否则bal减1。如果bal等于-1，说明从头字符到当前字符的子数组需要添加一个<code>(</code>，那么ans就加1，同时将bal置0，重新开始计数。</p><p>最后ans + bal即为答案。</p><p>举个例子：例如A = “())”，B = “(()”，A字符串缺<code>(</code>，B字符串缺<code>)</code>。那么当给定字符串为AB时，当遍历到A字符串最后一个字符，即<code>)</code>时，bal为-1，那么ans加1，bal置为0。说明该子字符串需要添加一个<code>(</code>。这时候继续向后遍历，bal代表的就是B的首字符到当前字符的子字符串的平衡度，而不是从整个字符串的首字符开始了。当遍历到B字符串末尾，bal为1，说明需要在后面添加一个<code>)</code>。</p><p>所以最后，ans = 1， bal = 1。总共需要添加 ans + bal =  2 个括号。</p><p>所以，只有当bal为-1时，ans才加1。即确定没法补救了，必须得添加一个<code>(</code>才会有效。而bal大于0时，因为不知道后面会不会遇到<code>)</code>，所以无法判断，只能继续向后遍历。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minAddToMakeValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, bal = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s) &#123;<br>            bal += ch == <span class="hljs-string">&#x27;(&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">if</span>(bal == <span class="hljs-number">-1</span>) &#123;<br>                ans++;<br>                <span class="hljs-comment">//写成bal = 0 可以更好表达算法思想</span><br>                bal++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans + bal;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>64-下一个更大元素Ⅱ</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/64-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A1/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/64-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210616203302473.png" alt="image-20210616203302473" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>同 [下一个更大元素]一样，使用单调栈。从栈顶到栈底对应元素依次增大。</p><p>不过因为最后一个元素的下一个元素是数组的第一个元素，<strong>所以要循环两遍数组，才能确定所有元素的下一个更大元素。</strong></p><p>因为数组最后一个元素的下一个更大元素有可能就是紧挨着它左边的元素。所以需要遍历两遍数组。</p><p>并且在第二遍循环数组时，不应该再往栈中添加元素，只是单纯的比较大小。</p><p>这样，解决该题的思路是：使用一个栈indexs来存放元素索引，先获取数组长度n，创建结果列表res，初始化为n个元素，初始值为-1。 当前遍历元素的索引为index，当栈不为空且index对应元素大于栈顶元素时，就循环出栈并添加到结果列表，直到栈为空，或index对应元素小于等于栈顶元素。</p><p>然后判断是否第一次遍历，如果是，则将index入栈；否则不入栈。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; indexs;<br>        <span class="hljs-comment">//遍历两次</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-type">int</span> index = i % n;<br>            <span class="hljs-keyword">while</span> (!indexs.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[indexs.<span class="hljs-built_in">top</span>()] &lt; nums[index]) &#123;<br>                res[indexs.<span class="hljs-built_in">top</span>()] = nums[index];<br>                indexs.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            <span class="hljs-comment">//判断是否是第一次遍历</span><br>            <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>                indexs.<span class="hljs-built_in">push</span>(index);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$，遍历了两遍列表。</p><p>空间复杂度：$O(n)$，使用了栈来存放索引。</p><p>参考做法完全一样。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>63-扁平化嵌套列表迭代器</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/63-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/63-%E6%89%81%E5%B9%B3%E5%8C%96%E5%B5%8C%E5%A5%97%E5%88%97%E8%A1%A8%E8%BF%AD%E4%BB%A3%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210614201429659.png" alt="image-20210614201429659" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>写一个递归函数store。</p><p>将给定的嵌套整型列表扁平化，存到res列表中。</p><p>递归参数：一个待扁平化的嵌套整形列表</p><p>返回值：无。</p><p>循环该嵌套列表，对于每个列表元素，有两种情况：</p><ol><li>该元素是一个整型值，存到res列表中</li><li>该元素是一个嵌套列表，递归</li></ol><p>该函数执行结束后，就完成了扁平化。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">NestedInteger</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Return true if this NestedInteger holds a single integer, rather than a nested list.</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isInteger</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// Return the single integer that this NestedInteger holds, if it holds a single integer</span><br>    <span class="hljs-comment">// The result is undefined if this NestedInteger holds a nested list</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getInteger</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// Return the nested list that this NestedInteger holds, if it holds a nested list</span><br>    <span class="hljs-comment">// The result is undefined if this NestedInteger holds a single integer</span><br>    <span class="hljs-function"><span class="hljs-type">const</span> vector&lt;NestedInteger&gt; &amp;<span class="hljs-title">getList</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NestedIterator</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">NestedIterator</span>(vector&lt;NestedInteger&gt; &amp;nestedList) &#123;<br>        <span class="hljs-built_in">store</span>(nestedList);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">store</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;NestedInteger&gt; &amp;nestedList)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nestedList.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(nestedList[i].<span class="hljs-built_in">isInteger</span>()) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(nestedList[i].<span class="hljs-built_in">getInteger</span>());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">store</span>(nestedList[i].<span class="hljs-built_in">getList</span>());<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> res[index++];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index &lt; res.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$，n为res的列表长度，即给定嵌套整型列表的元素个数</p><p>空间复杂度：$O(k)$，k为嵌套整型数组的嵌套深度。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>62-每日温度</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/62-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/62-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210611205210681.png" alt="image-20210611205210681" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用单调栈，栈中存放温度及相应的索引，从栈底到栈顶，温度依次递减。</p><p>栈中的元素代表都还没有找到下一个更高的温度。</p><p>遍历数组：</p><ol><li>如果栈为空，则直接进栈</li><li>如果栈不为空，则比较栈顶元素和当前温度大小<ul><li>如果当前温度更大，循环弹栈，直到当前温度小于等于栈顶元素温度。并添加到哈希表，key为索引，值为等待的天数。即当前温度的索引 - 栈顶元素的索引。</li><li>如果当前温度小于栈顶元素，则直接入栈</li></ul></li></ol><p>遍历完后，将所有还在栈中的元素也添加到哈希表中，value为0，即没有找到更高的温度。</p><p>然后根据索引从哈希表中依次添加到结果列表res中。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-comment">//第一个是索引，第二个是温度</span><br>        stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; s;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>() || temperatures[i] &lt;= s.<span class="hljs-built_in">top</span>().second) &#123;<br>                s.<span class="hljs-built_in">push</span>(&#123;i, temperatures[i]&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; s.<span class="hljs-built_in">top</span>().second) &#123;<br>                    map.<span class="hljs-built_in">insert</span>(&#123;s.<span class="hljs-built_in">top</span>().first, i - s.<span class="hljs-built_in">top</span>().first&#125;);<br>                    s.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>                s.<span class="hljs-built_in">push</span>(&#123;i, temperatures[i]&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            map.<span class="hljs-built_in">insert</span>(&#123;s.<span class="hljs-built_in">top</span>().first, <span class="hljs-number">0</span>&#125;);<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(map[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历一遍列表，又依次访问一遍哈希表，为$O(n)$。n为列表长度。</p><p>空间复杂度：一个栈，一个哈希表。$O(n)$。</p><h2 id="参考解法"><a href="#参考解法" class="headerlink" title="参考解法"></a>参考解法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>还是使用单调栈，思想差不多。但是比我那个要简单，我那个做法想复杂了。</p><p>栈中只放索引，不需要放对应温度。也不需要哈希表。可以提前申请好结果列表res的内存，res的大小和给定的温度列表大小是相同的。</p><p>然后根据索引去比较温度。</p><p>申请内存后，元素初始为0。所以可以只需修改那些能够观测到更高温度的对应元素，无法观测到更高温度的，就应该是0。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-type">int</span> n = temperatures.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="hljs-built_in">top</span>()]) &#123;<br>                <span class="hljs-type">int</span> preIndex = s.<span class="hljs-built_in">top</span>();<br>                res[preIndex] = i - preIndex;<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(i);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p><h3 id="另一个解法"><a href="#另一个解法" class="headerlink" title="另一个解法"></a>另一个解法</h3><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>留个坑。</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; temperatures)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = temperatures.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j += res[j]) &#123;<br>                <span class="hljs-keyword">if</span>(temperatures[i] &lt; temperatures[j]) &#123;<br>                    res[i] = j - i;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(res[j] == <span class="hljs-number">0</span>) &#123;<br>                    res[i] = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>60-逆波兰表达式求值</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/60-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/60-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210609220432059.png" alt="image-20210609220432059" style="zoom:50%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210609220448410.png" alt="image-20210609220448410" style="zoom:50%;" /></p><p>逆波兰表达式就是后缀表达式的洋气叫法。</p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这题的做法，已经写在上面逆波兰表达式的优点里了。</p><p>使用栈，碰到运算符，则从栈中取两个数，将运算得到的数再入栈。</p><p>要注意的是：数的运算顺序，先弹栈的数放后面，再弹栈的数放前面。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(string str : tokens) &#123;<br>            <span class="hljs-keyword">if</span>(str == <span class="hljs-string">&quot;+&quot;</span> || str == <span class="hljs-string">&quot;-&quot;</span> || str == <span class="hljs-string">&quot;*&quot;</span> || str == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                <span class="hljs-type">int</span> num1 = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> num2 = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(str == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>                    s.<span class="hljs-built_in">push</span>(num2 + num1);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>                    s.<span class="hljs-built_in">push</span>(num2 - num1);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str == <span class="hljs-string">&quot;*&quot;</span>) &#123;<br>                    s.<span class="hljs-built_in">push</span>(num2 * num1);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    s.<span class="hljs-built_in">push</span>(num1 / num1);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//使用stoi函数，将字符串转为数字</span><br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(str));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>59-简化路径</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/59-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/59-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210608210335351.png" alt="image-20210608210335351" style="zoom:50%;" /></p><p>​                        同时保证，path是一个有效的Unix路径。</p><p>自己的做法，太太太繁琐了。</p><p>思路也不对，一直再处理各种特殊情况。就不贴这了。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用一个栈来存放有效路径。</p><p>遍历path字符串，</p><p>可以发现，当遇到一个 <code>/</code>时，说明前面是一个路径。这个路径有三种情况：<code>..</code>、<code>.</code>和有效路径。</p><p>使用一个字符串dir来存放碰到这个<code>/</code>之前的路径。</p><p>如果是<code>..</code>，那么就弹出栈顶元素(需判断栈是否为空)，如果是<code>.</code>，则直接跳过，如果是有效元素，就将dir添加到栈中。</p><p>然后清空dir字符串。</p><p>当遇到其他字符时，就添加到dir末尾。</p><p>需要注意的是：因为给定路径path的末尾有可能没有<code>/</code>，所以例如<code>/a/..</code>这种就会出现错误，所以可以手动在path后添加       一个<code>/</code>，来避免这种情况。</p><p>遍历结束后，如果栈为空，则直接返回<code>/</code>，否则依次弹栈连接到结果字符串res。</p><p>在连接时注意：栈顶元素应该在末尾，也就是从栈底到栈顶，目录是主次递进的。所以每次连接都需要添加到res开头。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">simplifyPath</span><span class="hljs-params">(string path)</span> </span>&#123;<br>        stack&lt;string&gt; s;<br>        string dir = <span class="hljs-string">&quot;&quot;</span>;<br>        path  = path + <span class="hljs-string">&quot;/&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : path) &#123;<br>            <span class="hljs-keyword">if</span>(ch == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(dir == <span class="hljs-string">&quot;..&quot;</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>()) s.<span class="hljs-built_in">pop</span>();<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dir != <span class="hljs-string">&quot;.&quot;</span> &amp;&amp; !dir.<span class="hljs-built_in">empty</span>()) &#123;<br>                    s.<span class="hljs-built_in">push</span>(dir);<br>                &#125;<br>                dir.<span class="hljs-built_in">clear</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dir += ch;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/&quot;</span>;<br>        &#125;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            res = <span class="hljs-string">&quot;/&quot;</span> + s.<span class="hljs-built_in">top</span>() + res;<br>            s.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历一遍字符串，又依次弹出栈顶元素，为$O(n)$，n为path字符串长度。</p><p>空间复杂度：$O(n)$。使用栈来存放字符。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>58-二叉树的后序遍历</title>
    <link href="/2022/05/11/leetcode/%E6%A0%91/58-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/05/11/leetcode/%E6%A0%91/58-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorder</span><span class="hljs-params">(TreeNode * root, vector&lt;<span class="hljs-type">int</span>&gt; &amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-built_in">postorder</span>(root-&gt;left, res);<br>            <span class="hljs-built_in">postorder</span>(root-&gt;right, res);<br>            res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">postorder</span>(root,res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="颜色标记法"><a href="#颜色标记法" class="headerlink" title="颜色标记法"></a>颜色标记法</h2><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;pair&lt;TreeNode *, <span class="hljs-type">int</span>&gt;&gt; s;<br>        s.<span class="hljs-built_in">push</span>(&#123;root, <span class="hljs-number">0</span>&#125;);<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;TreeNode *, <span class="hljs-type">int</span>&gt; node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node.first == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!node.second) &#123;<br>                s.<span class="hljs-built_in">push</span>(&#123;node.first, <span class="hljs-number">1</span>&#125;);<br>                s.<span class="hljs-built_in">push</span>(&#123;node.first-&gt;right, <span class="hljs-number">0</span>&#125;);<br>                s.<span class="hljs-built_in">push</span>(&#123;node.first-&gt;left, <span class="hljs-number">0</span>&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(node.first-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>57-下一个更大元素Ⅰ</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/57-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A0/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/57-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A0%E2%85%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210606204743332.png" alt="image-20210606204743332" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>将nums2的所有元素添加到一个map集合中，key为各元素的值，value为该元素的索引。</p><p>然后遍历nums1数组，对于每一个元素，从map中找到与该元素的值相等的key对应的value，即当前元素对应nums2的元素的索引。然后从该索引开始遍历，如果存在比该元素大的，就加到res数组，否则就添加-1。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; index;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            index[nums2[i]] = i;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-type">int</span> j;<br>            <span class="hljs-keyword">for</span>(j = index[nums1[i]] + <span class="hljs-number">1</span>; j &lt; nums2.<span class="hljs-built_in">size</span>(); j++) &#123;<br>                <span class="hljs-keyword">if</span>(nums2[j] &gt; nums1[i]) &#123;<br>                    res.<span class="hljs-built_in">push_back</span>(nums2[j]);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(j == nums2.<span class="hljs-built_in">size</span>()) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：最坏情况，nums2是一个由大到小排列的数组，那么对于在num1中的每个元素，都会从nums2中的对应位置遍历到末尾。时间复杂度为$O(mn)$，m为nums1的长度，n为nums2的长度。</p><p>空间复杂度：$O(n)$。使用了一个map集合来存放nums2中元素，结果数组res不计入空间复杂度。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用单调栈来做。</p><p>使用哈希表来存放nums2中每个元素和它的下一个更大元素。</p><p>单调栈：</p><p>依次遍历数组，设当前元素为t，如果栈顶元素大于t，那么就将t入栈；如果栈顶元素小于t，那么栈顶元素的下一个更大元素就是t，出栈，并添加到哈希表中，继续判断当前栈顶元素是否小于t，如是，则执行上一步，循环执行，直到当前栈顶元素大于t。然后添加t到栈中，继续判断。直到遍历结束。</p><p>可以发现，维护的栈保证了单调性，栈中的元素从栈顶到栈底是递增的。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年06月06日21时35分26秒.gif" alt="21年06月06日21时35分26秒" style="zoom:25%;" /></p><p>注：最后一步，7大于4和6，应该是依次出栈。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; map;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums2.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() &amp;&amp; s.<span class="hljs-built_in">top</span>() &lt; nums2[i]) &#123;<br>                    map[s.<span class="hljs-built_in">top</span>()] = nums2[i];<br>                    s.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>            s.<span class="hljs-built_in">push</span>(nums2[i]);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums1.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            res.<span class="hljs-built_in">push_back</span>(map.<span class="hljs-built_in">count</span>(nums1[i]) ? map[nums1[i]]: <span class="hljs-number">-1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：两个数组各遍历了一遍，$O(m + n)$。</p><p>空间复杂度：$O(n)$，遍历数组2需要使用栈和哈希表。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>56-文件夹操作日志搜集器</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/56-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86%E5%99%A8/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/56-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C%E6%97%A5%E5%BF%97%E6%90%9C%E9%9B%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210604191822268.png" alt="image-20210604191822268" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>对于每一个<code>x/</code>记录，都代表进入了当前文件夹下的一个子文件夹。<code>../</code>代表返回上一个文件夹。</p><p>所以使用栈来存所有有效的记录，有效的记录是指<code>x/</code>型记录。</p><p>首先遍历logs数组，如果当前遍历字符串时<code>x/</code>，则入栈；如果是<code>../</code>则弹出栈顶元素；如果是<code>./</code>，则什么都不做。</p><p>最后栈中元素个数就是返回主文件夹所需的最小步数。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minOperations</span><span class="hljs-params">(vector&lt;string&gt;&amp; logs)</span> </span>&#123;<br>        stack&lt;string&gt; s;<br>        <span class="hljs-keyword">for</span>(string str : logs) &#123;<br>            <span class="hljs-keyword">if</span>(str == <span class="hljs-string">&quot;../&quot;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(!s.<span class="hljs-built_in">empty</span>()) &#123;<br>                    s.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(str == <span class="hljs-string">&quot;./&quot;</span>) &#123;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                s.<span class="hljs-built_in">push</span>(str);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">size</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。n为logs数组元素个数。</p><p>空间复杂度：$O(n)$。</p><p>无参考做法。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>55-整理字符串</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/55-%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/55-%E6%95%B4%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210604190613717.png" alt="image-20210604190613717" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>C++ std:string类有<code>pop_back</code>和<code>push_back</code>方法。分别代表弹出末尾字符和向末尾插入一个字符。</p><p>定义结果字符串res，初始为空字符串。</p><p>对于相邻的两个字符，无论大写字母在前，对应的小写字母在后，还是反过来。这两个字符都需要被删除。</p><p>所以不管顺序，将两个字符都化成小写，同时这两个字母本身不能相同，那么就符合删除的条件。</p><p>如果不符合，那么就将当前字符添加到res后。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">makeGood</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">empty</span>() &amp;&amp; <span class="hljs-built_in">tolower</span>(ch) == <span class="hljs-built_in">tolower</span>(res.<span class="hljs-built_in">back</span>()) &amp;&amp; ch != res.<span class="hljs-built_in">back</span>()) &#123;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><p>和参考做法的代码一模一样！</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>54-用栈操作构建数组</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/54-%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/54-%E7%94%A8%E6%A0%88%E6%93%8D%E4%BD%9C%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210604185315763.png" alt="image-20210604185315763" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>i从1到n循环。同时维持target的索引index，index初始为0。res结果数组初始为空</p><p>当i == target[i]时，res添加字符串”Push”，同时index 加1，判断index是否等于target长度size，如果等于，    结束循环。</p><p>如果i != target[i],即i这个值，在target数组中不存在，那么就应该先入栈再出栈，向res中依次添                 加”Push”和”Pop”。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">buildArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; target, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = target.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> index = <span class="hljs-number">0</span>;<br>        vector&lt;string&gt; res;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>            <span class="hljs-keyword">if</span>(target[index] == i) &#123;<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Push&quot;</span>);<br>                index++;<br>                <span class="hljs-keyword">if</span>(index == size) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Push&quot;</span>);<br>                res.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;Pop&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$，n就是参数n。</p><p>空间复杂度：$O(1)$。结果数组不计入空间复杂度。</p><p>无参考做法。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>53-删除字符串中的所有相邻重复项</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/53-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/53-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210604183311423.png" alt="image-20210604183311423" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>遍历字符串，将字符依次入栈，对于当前遍历到的字符，如果栈顶字符和该字符相同，则弹出栈顶元素。</p><p>遍历结束后，将字符依次出栈，连接成字符串。</p><p>需要注意一个问题：如果从头到尾遍历字符串，那么栈顶到栈底是结果字符串的尾到头。也就是正好反过来。</p><p>所以出栈时，应该将出栈的字符连接到字符串前面。</p><p>也可以从尾到头遍历字符串，那么出栈的字符就应连接到字符串末尾。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-comment">//从尾到头遍历字符串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>;i--) &#123;<br>            <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">empty</span>() &amp;&amp; stack.<span class="hljs-built_in">top</span>() == s[i]) &#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>        &#125;<br>        s = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            s.<span class="hljs-built_in">push_back</span>(stack.<span class="hljs-built_in">top</span>());<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>C++ 的std:string类本身就带有类似栈的pop和push操作。所以可以把结果字符串res本身作为一个栈。</p><p>即当res的尾字符和当前遍历到的字符相等时，就从res中去掉该字符，使用<code>pop_back()</code>。</p><p>否则将该字符添加到末尾,使用<code>push_back()</code>。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : s) &#123;<br>            <span class="hljs-keyword">if</span>(!res.<span class="hljs-built_in">empty</span>() &amp;&amp; res.<span class="hljs-built_in">back</span>() == ch) &#123;<br>                res.<span class="hljs-built_in">pop_back</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(ch);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。注意，结果字符串本身不计入空间复杂度。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>52-删除最外层的括号</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/52-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/52-%E5%88%A0%E9%99%A4%E6%9C%80%E5%A4%96%E5%B1%82%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210602214255121.png" alt="image-20210602214255121" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>一个原语就表示一个不可再拆分的合法的括号序列。例如<code>(())</code>就是合法的，<code>(()</code>不合法。</p><p><code>()()</code>也是合法的，但是它可拆分为<code>()</code>和<code>()</code>，所以不符合。</p><p>所以可以遍历序列，如果字符为<code>(</code>，就入栈；为<code>)</code>则出栈。</p><p>出栈后，如果栈为空，就代表该段序列是不可再拆分的合法的括号序列。</p><p>同时使用start来表示这段序列开始字符的索引。</p><p>然后将该段序列去掉最外层括号添加到res结果字符串末尾，同时start置为当前索引加1。</p><p>遍历结束，返回res。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeOuterParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;&quot;</span>) &#123;<span class="hljs-keyword">return</span> s;&#125;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                stack.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span>(stack.<span class="hljs-built_in">empty</span>()) &#123;<br>                    <span class="hljs-comment">//start + 1，表示去掉外面括号的`(`,i - start - 1表示去掉外面括号的 &#x27;)&#x27;</span><br>                    res.<span class="hljs-built_in">append</span>(s.<span class="hljs-built_in">substr</span>(start + <span class="hljs-number">1</span>, i - start - <span class="hljs-number">1</span>));<br>                    start = i + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(N)$。</p><p>空间复杂度：$O(N)$。</p><h3 id="另一种做法"><a href="#另一种做法" class="headerlink" title="另一种做法"></a>另一种做法</h3><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>一种优化的解法。</p><p>因为一个合法序列的<code>(</code>的数量和<code>)</code>的数量一定相同。</p><p>所以使用一个count遍历来计数，当遍历到的字符为<code>(</code>，则加1；为<code>)</code>，则减1。</p><p>当count为零时，代表找到了一段不可拆分的合法序列。</p><p>同样使用start变量表示这段序列的开始字符。</p><p>然后去掉该段字符的最外层括号添加到结果res字符串末尾。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeOuterParentheses</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s == <span class="hljs-string">&quot;&quot;</span>) &#123;<span class="hljs-keyword">return</span> s;&#125;<br>        string res = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;)&#x27;</span>) &#123;<br>                count--;<br>                <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) &#123;<br>                    res.<span class="hljs-built_in">append</span>(s.<span class="hljs-built_in">substr</span>(start + <span class="hljs-number">1</span>, i - start - <span class="hljs-number">1</span>));<br>                    start = i + <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><p>无参考做法。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>51-比较含退格的字符串</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/51-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/51-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210602203957803.png" alt="image-20210602203957803" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用栈，将字符串的每个字符依次入栈，如果遇到<code>#</code>，那么就弹栈。即去掉栈顶元素，结束遍历后。依次弹栈连接成新的字符串，不含退格符。</p><p>两个字符串都做如上操作，然后进行比较即可。</p><p>需要注意：对空文本进行退格，还是空文本。所以在遇到退格符时，需要判断栈是否为空，不为空，才弹栈。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; stack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(s[i]);<br>            &#125;<br>        &#125;<br>        s = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            s = s + stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-comment">//再做一遍</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; t.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(t[i] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span>(!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>                    stack.<span class="hljs-built_in">pop</span>();<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stack.<span class="hljs-built_in">push</span>(t[i]);<br>            &#125;<br>        &#125;<br>        t = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            t = t + stack.<span class="hljs-built_in">top</span>();<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s == t;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(m + n)$。m为s的长度，n为t的长度。</p><p>空间复杂度：$O(max(m, n))$。较长的字符串的长度。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><p>第一种和我的相同。</p><p>只说第二种。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用双指针。</p><p>在遍历字符串时，当遇到<code>#</code>退格符时，就代表该退格符的前一个字符应被删去，是无效字符。</p><p>所以当从头到尾遍历时，要去掉的是它的前一个字符。</p><p>所以可以从尾到头遍历，每当遇到一个<code>#</code>时，就知道下次遍历到的字符如果不是<code>#</code>，是正常字符就应该被删去。</p><p>所以定义两个变量skip_s和skip_t。代表当前应被删去的字符数量。</p><p>即：如果当前遍历的字符为正常字符，且skip不为0，那么该字符就是无效字符，如果为0，就代表当前字符是有效字符。</p><p>当遇到<code>#</code>时，就加 1。</p><p>所以思路就有了。</p><p>定义两个变量i和j初始值，分别为s和t的最后一个字符的索引。</p><p>skip_s和skip_t初始为0。</p><p>首先找到s的一个有效字符，然后再找t的一个有效字符。比较这两个字符，如果不相同，直接返回false。</p><p>当然有一种情况是：其中一个字符串遍历完了，而另一个还没有，这种情况两个字符串肯定不相同，返回false。</p><p>如果两个字符串全部遍历完毕，代表这两个字符串相等，返回true。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">backspaceCompare</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> skip_s = <span class="hljs-number">0</span>, <span class="hljs-type">skip_t</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i = s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, j = t.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//当两个字符串全都遍历完成结束循环</span><br>        <span class="hljs-keyword">while</span> ( i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//找到s的有效字符</span><br>            <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span>(s[i] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    skip_s++;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(skip_s &gt; <span class="hljs-number">0</span>) &#123;<br>                    skip_s--;<br>                    i--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//当s[i]为正常字符，且skip_s 为0时，该字符就是有效字符</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//找到t的有效字符</span><br>            <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span>(t[j] == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    <span class="hljs-type">skip_t</span>++;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-type">skip_t</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">skip_t</span>--;<br>                    j--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果两个指针都有效，比较对应的字符</span><br>            <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span>(s[i] != t[j]) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-comment">//有一个指针有效，而另一个无效(即已经遍历完成)，就返回false</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span> || j &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            i--, j--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(m +n)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>50-棒球比赛</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/50-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/50-%E6%A3%92%E7%90%83%E6%AF%94%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210601183717165.png" alt="image-20210601183717165" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>超简单。</p><p>使用栈。point初始为0.</p><p>一共有四种情况：</p><ol><li>整数x，直接入栈。需要进行字符串到int类型的转换。使用C++ atoi函数</li><li><code>+</code>：获得栈中前两个元素的值，加到point上。同时将结果入栈</li><li><code>D</code>：point加上栈顶元素的二倍，同时该值入栈</li><li><code>C</code>：point减去栈顶元素，同时栈顶元素出栈</li></ol><p>遍历数组结束后，直接返回point即可。</p><p>当然也可以遍历数组时只对栈操作，不进行分数加减。第二遍栈依次出栈，加到point上。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calPoints</span><span class="hljs-params">(vector&lt;string&gt;&amp; ops)</span> </span>&#123;<br>        <span class="hljs-type">int</span> point = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ops.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(ops[i].<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;+&quot;</span>)) &#123;<br>                <span class="hljs-type">int</span> point1 = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-type">int</span> point2 = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">push</span>(point1);<br>                s.<span class="hljs-built_in">push</span>(point1 + point2);<br>                point = point + point1 + point2;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops[i].<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;D&quot;</span>)) &#123;<br>                point = point + s.<span class="hljs-built_in">top</span>() * <span class="hljs-number">2</span>;<br>                s.<span class="hljs-built_in">push</span>(s.<span class="hljs-built_in">top</span>() * <span class="hljs-number">2</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ops[i].<span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;C&quot;</span>)) &#123;<br>                point = point - s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">int</span> x = <span class="hljs-built_in">atoi</span>(ops[i].<span class="hljs-built_in">c_str</span>());<br>                s.<span class="hljs-built_in">push</span>(x);<br>                point = point + x;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> point;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>compare</code>用<code>==</code>也可以。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$，n为数字长度。</p><p>空间复杂度：$O(n)$。</p><p>参考答案做法相同。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>49-分割链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/49-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/49-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="49-二叉树中的列表"><a href="#49-二叉树中的列表" class="headerlink" title="49-二叉树中的列表"></a>49-二叉树中的列表</h1><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210531182807980.png" alt="image-20210531182807980" style="zoom:53%;" /></p><p>不会做。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>迭代，就是挨个试二叉树的节点，看从此结点开始是否有与head相一致的路径。</p><p>一个递归函数 isSub。</p><p>参数：当前匹配到的二叉树节点tn,当前匹配到的链表节点ln。</p><p>返回值：该节点是否匹配，匹配为true，否则为false。</p><p>有四种情况：</p><ol><li>ln为空，即链表节点为空，说明全部匹配完了，返回true</li><li>tn为空，说明二叉树节点为空，但链表节点不为空，返回false</li><li>tn-&gt;val != ln-&gt;val，返回false</li><li>如果上述三种情况都不满足，说明当前待匹配二叉树节点和链表节点是匹配的，那么就看该二叉树节点的左子节点和链表下一个节点是否匹配，或右子结点和链表下一个节点是否匹配。只要有一个匹配即可，所有用或符号<code>||</code>连接。</li></ol><p>在主函数中，不断迭代二叉树节点，即尝试以每个二叉树节点为根的树是否有这样一条路径。且只要有一个子树有就可以。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSub</span><span class="hljs-params">(TreeNode * tn, ListNode * ln)</span> </span>&#123;<br>        <span class="hljs-comment">//链表为空，说明匹配完了，返回ture</span><br>        <span class="hljs-keyword">if</span>(ln == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//二叉树为空，返回false</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tn == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tn-&gt;val != ln-&gt;val) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSub</span>(tn-&gt;left, ln-&gt;next) || <span class="hljs-built_in">isSub</span>(tn-&gt;right, ln-&gt;next);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isSubPath</span><span class="hljs-params">(ListNode* head, TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//分别尝试以当前二叉树节点为根的树、以该节点的左子结点和右子结点为根的树是否有这样一条路径。</span><br>        <span class="hljs-comment">// 只要有一个子树有就可以，所以使用或符号</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isSub</span>(root, head) || <span class="hljs-built_in">isSubPath</span>(head, root-&gt;left)<br>        || <span class="hljs-built_in">isSubPath</span>(head, root-&gt;right);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：每个子树最多匹配<em>min($2^{len + 1}$, n)</em>次，len是链表长度。若该二叉树共有n个节点，则最坏情况需要：</p><p>​            $O(n * min(2^{len + 1}, n))$。</p><p>空间复杂度：$O(height)$，height为二叉树高度。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>48-分割链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/48-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/48-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210530201524820.png" alt="image-20210530201524820" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>创建两个节点，less_head, greater_head。代表比x小的节点链表和大于等于x的节点链表。</p><p>两个指针less和greater始终指向上述两个链表的尾节点。</p><p>使用cur指针遍历链表，如果小于x则添加到less_head中，否则添加到greater_head中。</p><p>添加后，将next指针置为空。</p><p>最后将两个链表连接起来即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        ListNode * less_head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * greater_head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * less = less_head;<br>        ListNode * great = greater_head;<br>        ListNode * cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode * next = cur-&gt;next;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val &lt; x) &#123;<br>                less-&gt;next = cur;<br>                less = less-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                great-&gt;next = cur;<br>                great = great-&gt;next;<br>            &#125;<br>            cur-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            cur = next;<br>        &#125;<br>        less-&gt;next = greater_head-&gt;next;<br>        <span class="hljs-keyword">return</span> less_head-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度: $O(n)$。</p><p>空间复杂度: $O(1)$。</p><h3 id="另一种做法"><a href="#另一种做法" class="headerlink" title="另一种做法"></a>另一种做法</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>创建哑节点dummy，less指向所以小于x节点链表的尾节点，使用cur指针遍历链表，当cur的值小于x时，就将它添加到less后面，然后cur向后走一步。并且因为待添加节点要和后面节点断开，所以需要保持一个pre指针时时指向cur的上一个节点。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode * less = dummy;<br>        ListNode * cur = head;<br>        ListNode * pre = dummy;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val &lt; x &amp;&amp; less-&gt;next != cur) &#123;<br>                pre-&gt;next = cur-&gt;next;<br>                cur-&gt;next = less-&gt;next;<br>                less-&gt;next = cur;<br>                less = less-&gt;next;<br>                cur = pre;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = cur;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>同上。</p><p>参考解法是第一种解法。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>47-分隔链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/47-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/47-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210530194451074.png" alt="image-20210530194451074" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先求得链表长度size。size / k = n。如果size不是k的整数倍，那么n * k 小于size。</p><p>设size - n * k = remain。即最后剩余的节点数为remain。remain一定小于n。因为要求每部分应该尽可能相等。</p><p>并且前面的要大于等于后面的长度。所以应该把最后剩余的节点均摊到前面。</p><p>即每次找到一个长度为n的链表后，按理说应该把这段链表放入结果数组中。但需要先看以下remain是否为0，如果不为0，那么将这段链表延长一个长度，即尾节点向后走一个，同时remain 减1。</p><p>并且应该添加哑节点dummy。因为最后有可能出现添加空指针的情况。</p><p>每次找到一段待添加链表后，dummy就指向下一个未添加链表的头部。所以哑节点一直指向未添加链表的头部。所以把该结点叫做pre。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;ListNode*&gt; <span class="hljs-title">splitListToParts</span><span class="hljs-params">(ListNode* root, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        vector&lt;ListNode *&gt; res;<br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>        ListNode * node = root;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            size++;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> n = size / k;<br>        <span class="hljs-type">int</span> remain = size - n * k;<br>        ListNode * pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        pre-&gt;next = root;<br>        node = pre;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                node = node-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(remain != <span class="hljs-number">0</span>) &#123;<br>                node = node-&gt;next;<br>                remain--;<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(pre-&gt;next);<br>            pre-&gt;next = node-&gt;next;<br>            node-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            node = pre;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：不算答案数组。只用了常数级空间。$O(1)$。算上的话，那就是$O(max(n + k))$。n为链表节点数。</p><p>参考答案类似。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>46-K个一组翻转链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/46-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/46-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210529204220010.png" alt="image-20210529204220010" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先遍历链表获得链表长度size。size / k = n，n就是需要翻转的链表的个数。</p><p>因为如果size不是k的整数倍，那么最后剩余的节点不需要翻转。</p><p>所以只需要关注前面n个链表即可。</p><p>首先要写一个反转函数。</p><p>参数：链表头节点。</p><p>返回值：包含两个节点指针，第一个是反转后的链表头指针，第二个是反转后的链表尾指针。</p><p>因为反转后的链表需要拼接回原链表，所以需要两个指针。当然也可以只返回 反转后的链表头节点，然后遍历该链表找到链表尾指针，但会增加程序执行次数，增加时间复杂度。</p><p>添加哑节点dummy，设置pre指针为待反转的链表头节点的前一个节点，初始pre指向dummy。</p><p>cur指针初始指向pre，向后走k步，刚好到达待反转链表的尾部，记录下尾节点的下一个节点next，以便于反转后拼接。</p><p>然后断开，即<code>cur-&gt;next = nullptr</code>。</p><p>反转后链表为reversed,进行拼接，pre指向reversed头节点，reversed尾节点指向next。</p><p>然后将pre指向reversed尾节点。</p><p>循环n次，即可完成反转。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>        ListNode * node = head;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            size++;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> n = size / k;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode * pre = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            ListNode * cur = pre;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; k; j++) &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>            ListNode * next = cur-&gt;next;<br>            cur-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            pair&lt;ListNode *, ListNode *&gt; reversed = <span class="hljs-built_in">reverse</span>(pre-&gt;next);<br>            pre-&gt;next = reversed.first;<br>            reversed.second-&gt;next = next;<br>            pre = reversed.second;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br>     <span class="hljs-function">pair&lt;ListNode *, ListNode *&gt; <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode * head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(head, head);<br>        &#125;<br>        ListNode * pre = <span class="hljs-literal">nullptr</span>, * cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode * next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(pre, head);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：一共进行了 size / k次反转，每次反转的链表长度都为k。先找到待反转链表的尾节点，k次操作，再进行反转，还是k次操作。所以共执行了 2 * size次操作。开头遍历链表获取长度。所以时间复杂度为$O(n)$，n为链表长度。</p><p>空间复杂度：$O(1)$。</p><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>可以不获得链表长度，而是每次走k步，如果当前指向节点为空，代表这段链表长度小于k，即为最后一段剩余链表，直接返回即可。</p><p>使用head当做遍历指针。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode * pre = dummy;<br>        <span class="hljs-keyword">while</span>(head) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; k; j++) &#123;<br>                head = head-&gt;next;<br>                <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) &#123;<br>                    <span class="hljs-keyword">return</span> dummy-&gt;next;<br>                &#125;<br>            &#125;<br>            ListNode * next = head-&gt;next;<br>            head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            pair&lt;ListNode *, ListNode *&gt; reversed = <span class="hljs-built_in">reverse</span>(pre-&gt;next);<br>            pre-&gt;next = reversed.first;<br>            reversed.second-&gt;next = next;<br>            pre = reversed.second;<br>            head = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br>     <span class="hljs-function">pair&lt;ListNode *, ListNode *&gt; <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode * head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(head, head);<br>        &#125;<br>        ListNode * pre = <span class="hljs-literal">nullptr</span>, * cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode * next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_pair</span>(pre, head);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>同上。</p><p>参考做法相同。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>45-合并K个升序链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/45-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/45-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210528191843266.png" alt="image-20210528191843266" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用队列，将每个链表头指针依次入队。每两个有序链表进行一次合并，然后将他们合并后的链表头指针放入队尾。</p><p>循环进行，直到队列中只剩一个元素，就是最终全部合并后的链表头指针。</p><p>特殊情况：当链表数组为空，则返回空；链表数组长度为1，则返回该元素。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];<br>        &#125;<br>        queue&lt;ListNode *&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            q.<span class="hljs-built_in">push</span>(lists[i]);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>() != <span class="hljs-number">1</span>) &#123;<br>            ListNode * list1 = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            ListNode * list2 = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            ListNode * merged = <span class="hljs-built_in">merge</span>(list1, list2);<br>            q.<span class="hljs-built_in">push</span>(merged);<br>        &#125;<br>        <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">front</span>();<br>    &#125;<br><br><br>    <span class="hljs-function">ListNode * <span class="hljs-title">merge</span><span class="hljs-params">(ListNode * l1, ListNode * l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l1;<br><br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * node = dummy, * node1 = l1, * node2 = l2;<br>        <span class="hljs-keyword">while</span> (node1 != <span class="hljs-literal">nullptr</span> &amp;&amp; node2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(node1-&gt;val &lt; node2-&gt;val) &#123;<br>                node-&gt;next = node1;<br>                node1 = node1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node-&gt;next = node2;<br>                node2 = node2-&gt;next;<br>            &#125;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node1 != <span class="hljs-literal">nullptr</span>) &#123;<br>            node-&gt;next = node1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            node-&gt;next = node2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>设有k个链表，每个链表最长长度为n。</p><p>时间复杂度：第一轮合并$\frac{k}{2}$组链表，每一组时间代价是$O(2n)$；第二轮合并$\frac{k}{4}$，时间代价为$O(4n)$</p><p>总时间复杂度为$O(kn × logk)$。</p><p>空间复杂度：$O(k)$。</p><h3 id="另一种做法"><a href="#另一种做法" class="headerlink" title="另一种做法"></a>另一种做法</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>每次都从所有链表的当前节点中找出一个最小节点，然后链接该节点。然后该链表遍历指针指向下一个节点。一直到所有链表遍历指针都为空，即所有结点都被连接到有序链表上。循环结束。</p><p>类似于合并两个有序链表的做法。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(lists.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> lists[<span class="hljs-number">0</span>];<br>        &#125;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        ListNode * pre = dummy;<br>        <span class="hljs-type">int</span> size = lists.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (pre != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-type">int</span> minNumber = INT_MAX;<br>            <span class="hljs-type">int</span> index = <span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-keyword">if</span>(lists[i] != <span class="hljs-literal">nullptr</span> &amp;&amp; lists[i]-&gt;val &lt; minNumber) &#123;<br>                    minNumber = lists[i]-&gt;val;<br>                    index = i;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果初始 链表数组所有指针都为空，那么就不会给index赋值</span><br>            <span class="hljs-keyword">if</span>(index != <span class="hljs-number">-1</span>) &#123;<br>                pre-&gt;next = lists[index];<br>                pre = pre-&gt;next;<br>                lists[index] = lists[index]-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//也可以直接写成break，结束循环</span><br>                pre-&gt;next = <span class="hljs-literal">nullptr</span>;<br>                pre = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度：$O(mn)$，m为总的节点个数，n为链表个数。</p><p>空间复杂度：$O(1)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用优先队列。</p><p>优先队列：普通队列是元素在队列尾添加，在队列头删除。在优先队列中，元素被赋予优先级。当从队列弹出时，会首先弹出具有最高优先级的元素。即优先队列具有最高级先出的行为特征。</p><p>初始将每个链表头节点依次(判空后)加入优先队列，优先级就是每个节点的值。最高优先级是最小值。</p><p>然后从队列中删除最高优先级节点，并添加到已排序链表末尾。判断该节点是否有下一个节点，如果有那么将下一个节点添加到优先队列。</p><p>当队列为空，证明所有结点排序完成。</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><p>C++中，优先队列默认会从大到小排列元素。所以如果要改变默认优先级的话。需要重载operator运算符 <code>&lt;</code>。</p><p>因为C++优先队列在比较优先级时，会使用该符号比较两个元素大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Status</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        ListNode *ptr;<br>        <span class="hljs-comment">// 对 &lt; 重载，默认是该元素是否小于rhs元素。返回值改成比较大于、就可以将顺序颠倒</span><br>        <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> Status &amp;rhs) <span class="hljs-type">const</span> &#123;<br>            <span class="hljs-keyword">return</span> val &gt; rhs.val;<br>        &#125;<br>    &#125;;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>        priority_queue&lt;Status&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (lists[i]) &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;lists[i]-&gt;val, lists[i]&#125;);<br>            &#125;<br>        &#125;<br>        ListNode * head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * pre = head;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            ListNode * node = q.<span class="hljs-built_in">top</span>().ptr;<br>            q.<span class="hljs-built_in">pop</span>();<br>            pre-&gt;next = node;<br>            pre = pre-&gt;next;<br>            <span class="hljs-keyword">if</span>(node-&gt;next) &#123;<br>                q.<span class="hljs-built_in">push</span>(&#123;node-&gt;next-&gt;val, node-&gt;next&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><p>设有k个链表，每个链表最长长度为n。</p><p>时间复杂度：优先队列中元素不超过k个，插入和删除的时间代价为$O(logk)$。最多有kn个点，每个节点都被插入删除依次，所有时间复杂度为$O(kn × logk)$。</p><p>空间复杂度：$O(k)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>44-排序链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/44-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/44-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210527201116821.png" alt="image-20210527201116821" style="zoom:50%;" /></p><p>最优解法没做出来，插入排序前面做过了。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><p>使用归并排序，有两种方法：一种是自顶向下，另一种是自底向上。</p><p>如果要达到常数级空间复杂度，那么就需要使用自底向上的解法。</p><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><p>递归地从中间拆分链表，然后进行排序，再合并两个有序链表。</p><p>找链表中间节点可以使用快慢指针，快指针走两步，慢指针走一步，当快指针到达末尾，慢指针指向链表中间节点。</p><p>设中间节点为mid，记下mid的下一个节点，然后将mid-&gt;next设为null。</p><p>分别排序前后两个链表，然后进行合并。</p><p>注意：有一种特殊情况就是：当链表有两个节点时，mid最终会指向第二个结点，会发生错误，因为递归排序前后两个链表时，前面链表还是原链表，后面链表是空。那么它会一直卡在两个节点的链表这里，陷入死循环。</p><p>所以本来递归地终止条件是当传入链表为空，或只有一个节点。</p><p>为了避免上述特殊情况，再加上一个条件就是当链表只有两个节点时：比较前后两个节点的值，升序，则直接返回；否则，交换两个节点，返回头节点。</p><h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sort</span>(head);<br>    &#125;<br><br>    <span class="hljs-function">ListNode * <span class="hljs-title">sort</span><span class="hljs-params">(ListNode * head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-comment">//链表只有两个节点的特殊情况</span><br>        <span class="hljs-keyword">if</span>(head-&gt;next-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val &lt; head-&gt;next-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ListNode * node = head-&gt;next;<br>                head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>                node-&gt;next = head;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        ListNode * slow = head;<br>        ListNode * fast = head;<br>        <span class="hljs-keyword">while</span> (fast &amp;&amp; fast-&gt;next) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        ListNode * mid = slow;<br>        ListNode * next_mid = mid-&gt;next;<br>        mid-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(next_mid));<br><br>    &#125;<br><br>    <span class="hljs-function">ListNode * <span class="hljs-title">merge</span><span class="hljs-params">(ListNode * l1, ListNode * l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l1;<br><br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * node = dummy, * node1 = l1, * node2 = l2;<br>        <span class="hljs-keyword">while</span> (node1 != <span class="hljs-literal">nullptr</span> &amp;&amp; node2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(node1-&gt;val &lt; node2-&gt;val) &#123;<br>                node-&gt;next = node1;<br>                node1 = node1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node-&gt;next = node2;<br>                node2 = node2-&gt;next;<br>            &#125;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node1 != <span class="hljs-literal">nullptr</span>) &#123;<br>            node-&gt;next = node1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            node-&gt;next = node2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以在找中间节点的时候避免这种情况，就是将上述的while条件<code>fast &amp;&amp; fast-&gt;next</code>改成<code>fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next</code>。然后删掉处理 链表只有两个节点的特殊情况的代码即可。</p><p>那么sort函数写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode * <span class="hljs-title">sort</span><span class="hljs-params">(ListNode * head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode * slow = head;<br>    ListNode * fast = head;<br>    <span class="hljs-keyword">while</span> (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123;<br>        slow = slow-&gt;next;<br>        fast = fast-&gt;next-&gt;next;<br>    &#125;<br>    ListNode * mid = slow;<br>    ListNode * next_mid = mid-&gt;next;<br>    mid-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head), <span class="hljs-built_in">sortList</span>(next_mid));<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度：$O(NlogN)$。</p><p>空间复杂度：递归栈存了<script type="math/tex">logN</script>个节点。时间复杂度为$O(logN)$。</p><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>首先求得链表的长度length。然后将链表拆分成子链表，进行合并。</p><ol><li>使用subLength代表每次需要排序的子链表的长度，初始subLength = 1</li><li>每次将链表拆分成若干个长度为subLength的子链表(最后一个子链表有可能小于subLength，如果除不尽)按照每两个子链表一组进行合并，合并后可以得到若干个长度为 subLength <em> 2 的有序子链表(最后一个子链表长度有可能小于subLength </em> 2)。</li><li>将subLength值加倍，重复第二步，直到subLength的值大于或等于length。</li></ol><p>整个链表排序完成。</p><p>简单说就是：两个链表一组进行合并。初始每个链表长度为1，合并后是若干个长度为2的有序子链表；然后再两个一组，这时，每个子链表长度为2，合并后是若干个长度为4的有序子链表。一直合并下去，直到合并后的有序子链表长度大于等于链表总长度。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">int</span> length = <span class="hljs-number">0</span>;<br>        ListNode * node = head;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            length++;<br>            node = node-&gt;next;<br>        &#125;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> subLength = <span class="hljs-number">1</span>; subLength &lt; length; subLength *= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-comment">//每次合并都从头开始</span><br>            ListNode * pre = dummy, * cur = dummy-&gt;next;<br>            <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-comment">//确定待合并的第一个链表的头节点</span><br>                ListNode * head1 = cur;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; cur-&gt;next != <span class="hljs-literal">nullptr</span>; i++) &#123;<br>                    cur = cur-&gt;next;<br>                &#125;<br>                <span class="hljs-comment">//待合并的第二个链表的头节点</span><br>                ListNode *head2 = cur-&gt;next;<br>                cur-&gt;next = <span class="hljs-literal">nullptr</span>;<br>                cur = head2;<br>                <span class="hljs-comment">//head2有可能为空，所以这个循环要判断cur是否为空</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; subLength &amp;&amp; cur != <span class="hljs-literal">nullptr</span> &amp;&amp; cur-&gt;next != <span class="hljs-literal">nullptr</span>; i++) &#123;<br>                    cur = cur-&gt;next;<br>                &#125;<br>                <span class="hljs-comment">//记录下一组待合并链表的头节点，cur有可能为空，需要判断</span><br>                ListNode *next = <span class="hljs-literal">nullptr</span>;<br>                <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>                    next = cur-&gt;next;<br>                    cur-&gt;next = <span class="hljs-literal">nullptr</span>;<br>                &#125;<br>                ListNode *merged = <span class="hljs-built_in">merge</span>(head1, head2);<br>                <span class="hljs-comment">//连接有序子链表</span><br>                pre-&gt;next = merged;<br>                <span class="hljs-keyword">while</span> (pre-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>                    pre = pre-&gt;next;<br>                &#125;<br>                <span class="hljs-comment">//指向下一组待合并链表头节点</span><br>                cur = next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><br>    <span class="hljs-function">ListNode * <span class="hljs-title">merge</span><span class="hljs-params">(ListNode * l1, ListNode * l2)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l2;<br>        <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> l1;<br><br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * node = dummy, * node1 = l1, * node2 = l2;<br>        <span class="hljs-keyword">while</span> (node1 != <span class="hljs-literal">nullptr</span> &amp;&amp; node2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(node1-&gt;val &lt; node2-&gt;val) &#123;<br>                node-&gt;next = node1;<br>                node1 = node1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node-&gt;next = node2;<br>                node2 = node2-&gt;next;<br>            &#125;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node1 != <span class="hljs-literal">nullptr</span>) &#123;<br>            node-&gt;next = node1;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(node2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            node-&gt;next = node2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br><br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(NlogN)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>43-从链表中删去总和值为零的连续节点</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/43-%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E5%8E%BB%E6%80%BB%E5%92%8C%E5%80%BC%E4%B8%BA%E9%9B%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/43-%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E5%8E%BB%E6%80%BB%E5%92%8C%E5%80%BC%E4%B8%BA%E9%9B%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210526212657769.png" alt="image-20210526212657769" style="zoom:50%;" /></p><p>这道题我不会。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>设链表节点值依次为 a、b、c、d、e、f、g。</p><p>若a + b = m,且a + b + c + d = m。那么就可确定c + d = 0。</p><p>这样就找到了一组和为0的连续节点。</p><p>依据这样的思路，使用一个map集合，将每个节点和<strong>它以及之前节点的值</strong>的和一一对应起来。</p><p>也就是说，key为int，value为节点指针。</p><p>每个节点指针对应着：该节点及其之前所有结点的值的总和。</p><p><strong>注意：key为int，也就是说，如果值相同，那么后面的节点指针会覆盖前面的节点指针。</strong></p><p>并且头节点也可能被删除，所以需要添加哑节点。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210526213910594.png" alt="image-20210526213910594" style="zoom:53%;" /></p><p>链表和对应的map集合元素。</p><p>然后遍历链表，同时累加对应节点值，用sum表示。</p><p>设当前节点为node，那么<code>node-&gt;next = map[sum]-&gt;next</code>。</p><p>即：node对应的sum在map中只有两种情况：一是map中sum对应的节点是它自己，也就是node；二是对应的节点是它后面的某个节点(因为后面会覆盖前面的)，这说明：node的下一个节点一直到map中对应的节点，这段连续节点的值的总和是零。那么就应该删除掉这段节点。</p><p>这两种情况都能用上面这句代码表示。</p><p>对于第一种情况：这是个恒等式。</p><p>对于第二种情况：可以删除掉这段和为0的连续节点。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeZeroSumSublists</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummy-&gt;next = head;<br>        unordered_map&lt;<span class="hljs-type">int</span>, ListNode *&gt; map;<br>        ListNode * node = dummy;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            sum = sum + node-&gt;val;<br>            map[sum] = node;<br>            node = node-&gt;next;<br>        &#125;<br>        node = dummy;<br>        sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            sum = sum + node-&gt;val;<br>            node-&gt;next = map[sum]-&gt;next;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历了两遍链表，$O(n)$。</p><p>空间复杂度：$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>42-设计前中后队列</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/42-%E8%AE%BE%E8%AE%A1%E5%89%8D%E4%B8%AD%E5%90%8E%E9%98%9F%E5%88%97/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/42-%E8%AE%BE%E8%AE%A1%E5%89%8D%E4%B8%AD%E5%90%8E%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210525205254946.png" alt="image-20210525205254946" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用链表来设计队列，两个指针front和tail分别指向队列头部和尾部，size表示队列长度。</p><p>并且front指向的也是链表的头节点。</p><p>初始队列为空时，front和tail都指向同一个节点，该节点不是队列元素。</p><p>则各操作实现：</p><p>添加到队列前面：直接添加即可，特殊情况：当队列为空时，设置tail指向新添加的节点。</p><p>添加到队列尾部：直接添加，然后tail向后走一步。</p><p>添加到队列中间：需要找到待添加位置的前一个节点，从front节点向后走 (size) / 2 步，即可找到该节点，添加即                可。同样注意特殊情况：即队列为空时，修改tail指针。</p><p>从队头弹出：直接弹出，同样注意特殊情况：当弹出后队列为空时，修改tail指针指向front</p><p>从队尾弹出：从front开始遍历，直到找到tail的前一个节点，弹出即可。</p><p>从队中间弹出：要找到待弹出节点的前一个节点，从front节点开始走 (size - 1) / 2 步，就是该节点。然后弹出。</p><p>注意弹出后队列为空的情况。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FrontMiddleBackQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    ListNode * tail = <span class="hljs-literal">nullptr</span>;<br>    ListNode * front = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-function">ListNode * <span class="hljs-title">getInsertNode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> step = size / <span class="hljs-number">2</span>;<br>        ListNode * node = front;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; step; i++) &#123;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br>    <span class="hljs-function">ListNode * <span class="hljs-title">getDeleteNode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> step = (size - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        ListNode * node = front;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; step; i++) &#123;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">FrontMiddleBackQueue</span>() &#123;<br>        ListNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        tail = node;<br>        front = node;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushFront</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>        node-&gt;next = front-&gt;next;<br>        front-&gt;next = node;<br>        size++;<br>        <span class="hljs-keyword">if</span>(front == tail) &#123;<br>            tail = node;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushMiddle</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br><br>        ListNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>        ListNode * pre = <span class="hljs-built_in">getInsertNode</span>();<br>        node-&gt;next = pre-&gt;next;<br>        pre-&gt;next = node;<br>        <span class="hljs-keyword">if</span>(front == tail) &#123;<br>            tail = node;<br>        &#125;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pushBack</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>        tail-&gt;next = node;<br>        tail = node;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popFront</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(front == tail) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ListNode * node = front-&gt;next;<br>        front-&gt;next = node-&gt;next;<br>        size--;<br>        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) &#123;<br>            tail = front;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popMiddle</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(front == tail) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ListNode * pre = <span class="hljs-built_in">getDeleteNode</span>();<br>        ListNode * node = pre-&gt;next;<br>        pre-&gt;next = node-&gt;next;<br>        size--;<br>        <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) &#123;<br>            tail = front;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">popBack</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(front == tail) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ListNode * pre = front;<br>        <span class="hljs-keyword">while</span> (pre-&gt;next != tail) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        tail = pre;<br>        pre = pre-&gt;next;<br>        tail-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        size--;<br>        <span class="hljs-keyword">return</span> pre-&gt;val;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：</p><p>​    队头添加、队尾添加、队头删除都是$O(1)$。</p><p>​    队中添加和删除、队尾删除时$O(n)$。</p><p>空间复杂度：都为$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>41-设计链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/41-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/41-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210524185349312.png" alt="image-20210524185349312" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>初始化链表时添加哑节点，使用两个指针dummy和end分别指向链表哑节点和链表尾节点，并使用size变量表示链表长度。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x, ListNode *next) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    ListNode * dummy = <span class="hljs-literal">nullptr</span>, * end = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">int</span> size;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyLinkedList</span>() &#123;<br>        dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        end = dummy;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        ListNode * cur = dummy;<br>        <span class="hljs-comment">//走 index + 1 步</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= index; i++) &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;val;<br>    &#125;<br><br>    <span class="hljs-comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtHead</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>        <span class="hljs-comment">//如果是链表为空，则修改end指针</span><br>        <span class="hljs-keyword">if</span>(dummy == end) &#123;<br>            end = node;<br>        &#125;<br>        node-&gt;next = dummy-&gt;next;<br>        dummy-&gt;next = node;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/** Append a node of value val to the last element of the linked list. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtTail</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        ListNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>        end-&gt;next = node;<br>        end = end-&gt;next;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &gt; size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//索引小于等于0，添加到头部</span><br>            <span class="hljs-built_in">addAtHead</span>(val);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(index == size) &#123;<br>            <span class="hljs-comment">//index == size，则添加到最后</span><br>            <span class="hljs-built_in">addAtTail</span>(val);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ListNode * pre = dummy;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>                pre = pre-&gt;next;<br>            &#125;<br>            ListNode * node = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(val);<br>            node-&gt;next = pre-&gt;next;<br>            pre-&gt;next = node;<br>            size++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** Delete the index-th node in the linked list, if the index is valid. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtIndex</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= size) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ListNode * pre = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 如果要删除节点为尾节点，则要修改end指针</span><br>        <span class="hljs-keyword">if</span>(index == size - <span class="hljs-number">1</span>) &#123;<br>            end = pre;<br>        &#125;<br>        pre-&gt;next = pre-&gt;next-&gt;next;<br>        size--;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>链表长度为N。</p><p>时间复杂度：</p><p>​    get:$O(k)$，k为索引。</p><p>​    addAtHead：$O(1)$。</p><p>​    addAtTail:$O(1)$。</p><p>​    addAtIndex：$O(k)$。</p><p>​    deleteAtIndex：$O(k)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>40-扁平化多级双向链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/40-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/40-%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210523200059117.png" alt="image-20210523200059117" style="zoom:50%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210523200124048.png" alt="image-20210523200124048" style="zoom:80%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210523200143996.png" alt="image-20210523200143996" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>每一级链表中都只会有一个节点有下一级链表。也就是只有一个节点的child指针不为空。</p><p>使用递归思想。只需要考虑两级的链表。</p><p>递归参数：链表头节点； 输出：扁平化后的链表头节点，没有下一级链表。</p><p>递归终止条件：输入的链表的所有结点都没有子节点，即所有结点child指针都为空。这时直接返回头节点即可。</p><p>递归过程：</p><p>首先遍历链表，如果某一个节点的child节点不为空，即有下一级链表，设该节点为cur。</p><p>则递归调用，传入参数为cur-&gt;child，设child_head为递归调用的返回值。</p><p>child_head对应的链表已经扁平化。应将其插入cur和cur-&gt;next之间。</p><p>首先遍历child_head链表，找到尾节点child_node。然后进行插入，插入步骤：</p><ol><li>判断cur节点是否有下一个节点，如有，将cur的下一个节点的prev指针指向child_node</li><li>将child_node的next指针指向cur-&gt;next。这时尾部插入结束。</li><li>将child_head的prev指针指向cur</li><li>cur的next指针指向child_head</li><li>最后，将cur的child指针置为空</li></ol><p>子链表插入完成。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年05月23日21时05分34秒.gif" alt="21年05月23日21时05分34秒"></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">flatten</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        Node * cur = head;<br>        <span class="hljs-keyword">while</span> (cur &amp;&amp; cur-&gt;child == <span class="hljs-literal">nullptr</span>) &#123;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cur == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        Node * child_head = <span class="hljs-built_in">flatten</span>(cur-&gt;child);<br>        Node * child_node = child_head;<br>        <span class="hljs-keyword">while</span> (child_node-&gt;next) &#123;<br>            child_node = child_node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cur-&gt;next) &#123;<br>            cur-&gt;next-&gt;prev = child_node;<br>        &#125;<br>        child_node-&gt;next = cur-&gt;next;<br>        child_head-&gt;prev = cur;<br>        cur-&gt;next = child_head;<br>        cur-&gt;child = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> head;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210523210806529.png" alt="image-20210523210806529" style="zoom:50%;" /></p><p>这是我能做到的吗，我感觉匪夷所思啊。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$，n为节点数。</p><p>空间复杂度：$O(n)$，n为节点数，因为可能每级链表都只有一个节点，那么每个节点都会有child节点。递归栈需要都保存</p><p>参考答案，笑死，根本看不懂。</p><p>用到了深度优先搜索，等我复习了再来看。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>39-链表组件</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/39-%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/39-%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210522182653276.png" alt="image-20210522182653276" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先遍历列表G，将整型值放入set集合中。</p><p>设置结果变量res，初始为0。然后遍历链表，设置一个标记值flag，用来标记当前节点之前一段的节点是否都在集合中。</p><p>即如果当前节点值在集合中，判断flag，如果flag = false，则res + 1，并将flag 设为true；如果flag = true，则不做任何操作。</p><p>如果当前节点不在集合中，则将flag 设为false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numComponents</span><span class="hljs-params">(ListNode* head, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br>        ListNode * cur = head;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(cur-&gt;val)) &#123;<br>                <span class="hljs-keyword">if</span>(!flag) &#123;<br>                    res++;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                flag = <span class="hljs-literal">false</span>;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>列表G的长度为a，链表长度为b</p><p>时间复杂度：为$O(a + b)$。</p><p>空间复杂度：$O(a)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>同样是先讲列表G中元素添加到set集合中。</p><p>然后对链表进行依次扫描(就是遍历)，一个组件在链表中对应一段连续节点，那么如果当前节点在列表G中，且下一个节点不在列表G中，那么就找到了一个组件的尾节点，res加1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numComponents</span><span class="hljs-params">(ListNode* head, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; s;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            s.<span class="hljs-built_in">insert</span>(nums[i]);<br>        &#125;<br>        ListNode * cur = head;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">count</span>(cur-&gt;val) &amp;&amp; (cur-&gt;next == <span class="hljs-literal">nullptr</span> || s.<span class="hljs-built_in">count</span>(cur-&gt;next-&gt;val))) &#123;<br>                res++;<br>            &#125;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>同上。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>38-二叉树的前序遍历</title>
    <link href="/2022/05/11/leetcode/%E6%A0%91/38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/05/11/leetcode/%E6%A0%91/38-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>前序</strong> 遍历。</p><h2 id="颜色标记法"><a href="#颜色标记法" class="headerlink" title="颜色标记法"></a>颜色标记法</h2><p>算法思想在中序遍历那篇 。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;pair&lt;TreeNode *, <span class="hljs-type">int</span>&gt;&gt; s;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(root, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;TreeNode *, <span class="hljs-type">int</span>&gt; node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node.first == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!node.second) &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(node.first-&gt;right, <span class="hljs-number">0</span>));<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(node.first-&gt;left, <span class="hljs-number">0</span>));<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(node.first, <span class="hljs-number">1</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(node.first-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preOrder</span><span class="hljs-params">(TreeNode * node, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        res.<span class="hljs-built_in">emplace_back</span>(node-&gt;val);<br>        <span class="hljs-built_in">preOrder</span>(node-&gt;left, res);<br>        <span class="hljs-built_in">preOrder</span>(node-&gt;right, res);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">preOrder</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="非递归实现"><a href="#非递归实现" class="headerlink" title="非递归实现"></a>非递归实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;TreeNode *&gt; s;<br>        TreeNode * p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">while</span> (p) &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(p-&gt;val);<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125;<br>            p = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            p = p-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>37-对链表进行插入排序</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/37-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/37-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210519183240458.png" alt="image-20210519183240458" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>就是插入排序。</p><p>首先添加哑节点dummy到链表头部。</p><p>使用两个指针end和cur。end用来指向已排序好的链表的尾节点，cur指向待排序节点。</p><p>每当排序一个节点时，执行以下步骤：</p><ol><li>设置pre指针指向dummy，判断pre的next是否为cur，并且pre的下一个节点的值是否小于cur的值</li><li>如果为true，则pre向后走一步</li><li>如果false，则判断pre的next是否为cur，如果是，则cur应在已排序链表的末尾，即end节点的下一个节点，它已经在正确位置了，执行<code>end = end-&gt;next</code>，将end向后走一步</li><li>如果pre的next不是cur，那么就应该将cur插入到pre后面，首先end节点的next节点应该指向cur的next，然后将cur的next指向pre的next，最后将pre的next指向cur，即执行：<code>end-&gt;next = cur-&gt;next;cur-&gt;next = pre-&gt;next; pre-&gt;next =cur</code>。</li><li>结束上一步后，将cur指向end节点的下一个节点，即下一个待排序节点。</li></ol><p>当cur为空时，循环结束，插入排序完成。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode * end = head;<br>        ListNode * cur = end-&gt;next;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            ListNode * pre = dummy;<br>            <span class="hljs-keyword">while</span> (pre-&gt;next != cur &amp;&amp; pre-&gt;next-&gt;val &lt; cur-&gt;val) &#123;<br>                pre = pre-&gt;next;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(pre-&gt;next == cur) &#123;<br>                end = end-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                end-&gt;next = cur-&gt;next;<br>                cur-&gt;next = pre-&gt;next;<br>                pre-&gt;next = cur;<br>            &#125;<br>            cur = end-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>优化后的代码：即先判断end的值和cur的值，如果end的值小于等于cur的值，end向后走一步，而不需要循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ListNode* <span class="hljs-title">insertionSortList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode * end = head;<br>        ListNode * cur = end-&gt;next;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span>(end-&gt;val &lt;= cur-&gt;val) &#123;<br>                end = end-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ListNode * pre = dummy;<br>                <span class="hljs-keyword">while</span> (pre-&gt;next-&gt;val &lt; cur-&gt;val) &#123;<br>                    pre = pre-&gt;next;<br>                &#125;<br>                    end-&gt;next = cur-&gt;next;<br>                    cur-&gt;next = pre-&gt;next;<br>                    pre-&gt;next = cur;<br>            &#125;<br>            cur = end-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：每排序一个节点，都需要从头遍历，找到大于该节点的第一个节点，所以平均时间复杂度应为：$O(n^2)$。</p><p>空间复杂度：$O(1)$。</p><p>参考方法相同。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>36-二叉树的中序遍历</title>
    <link href="/2022/05/11/leetcode/%E6%A0%91/36-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <url>/2022/05/11/leetcode/%E6%A0%91/36-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p><p>递归遍历和非递归遍历应该牢牢背熟。</p><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorder</span><span class="hljs-params">(TreeNode * root, vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-built_in">inorder</span>(root-&gt;left, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>        <span class="hljs-built_in">inorder</span>(root-&gt;right, res);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-built_in">inorder</span>(root, res);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode *&gt; s;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        TreeNode * p = root;<br>        <span class="hljs-keyword">while</span> (p || !s.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span>(p) &#123;<br>                s.<span class="hljs-built_in">push</span>(p);<br>                p = p-&gt;left;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p = s.<span class="hljs-built_in">top</span>();<br>                res.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>                s.<span class="hljs-built_in">pop</span>();<br>                p = p-&gt;right;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="Morris-中序遍历"><a href="#Morris-中序遍历" class="headerlink" title="Morris 中序遍历"></a>Morris 中序遍历</h2><p>Morris 遍历算法可以将非递归的中序遍历空间复杂度降为$O(1)$。</p><p>假设当前遍历节点为x，步骤为：</p><ol><li>如果 x 无左孩子，加入答案数组，接着访问x右孩子</li><li>如果 x 有左孩子，就找到 x 左子树上最右的节点(<strong>即 左子树中序遍历的最后一个节点</strong>，<strong>x在中序遍历中的前驱节点</strong>)，记为 predecessor。根据predecessor的右孩子是否为空，进行操作：<ul><li>如果predecessor的右孩子为空，则将右孩子指向x，然后访问x的左孩子</li><li>如果右孩子不为空，则该右孩子一定指向x(<strong>因为predecessor一定是x的左子树的最右节点，所以若右孩子不为空则一定是指向x</strong>)，这是说明已遍历完x的左子树，那么就将predecessor的右孩子置空，将x加入答案数组，然后访问x的右孩子</li></ul></li></ol><p>重复操作，直至遍历完整棵树。</p><p>在整个过程，其实多做了一步：假设当前遍历到节点为x，将x的左子树的最右节点指向x，这样当左子树遍历完后就通过这个指向走回x，且通过这个指向可以知道已经遍历完了左子树，不需要栈来维护。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        TreeNode * p = root;<br>        <span class="hljs-keyword">while</span> (p) &#123;<br>            <span class="hljs-keyword">if</span>(p-&gt;left) &#123;<br>                TreeNode * predecessor = p-&gt;left;<br>                <span class="hljs-keyword">while</span> (predecessor-&gt;right &amp;&amp; predecessor-&gt;right != p) &#123;<br>                    predecessor = predecessor-&gt;right;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(predecessor-&gt;right == <span class="hljs-literal">nullptr</span>) &#123;<br>                    predecessor-&gt;right = p;<br>                    p = p-&gt;left;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    predecessor-&gt;right = <span class="hljs-literal">nullptr</span>;<br>                    res.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>                    p = p-&gt;right;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">push_back</span>(p-&gt;val);<br>                p = p-&gt;right;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：每个节点都访问了两个，所以为$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="颜色标记法"><a href="#颜色标记法" class="headerlink" title="颜色标记法"></a>颜色标记法</h2><p>来自评论。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>中序遍历，即每个节点在第二次访问的时候会被输出。因此可以使用任何东西来记录节点的访问次数，当第二次被访问的时候就输出。</p><p>因此可以使用颜色，或者使用哈希表来记录。</p><p>用白色表示从未被访问过的节点，用灰色表示已被访问过一次。</p><p>则：</p><ol><li>当访问到的节点为白色时，则标记为灰色，然后依次将它的右子结点，它自己，左子结点 进栈</li><li>如果访问到的节点为灰色时，则添加到答案数组中，即输出</li></ol><p>初始时，将根节点标记为白色，然后进栈。</p><p>然后循环出栈即可。</p><p>这种方式可以对于前序、后序、中序写出一致的代码。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>因为前序遍历顺序为：中 左 右</p><p>中序遍历顺序为：左 中 右</p><p>后序遍历顺序为：左 右  中</p><p>而栈是先进后出，所以中序遍历时，反过来，加入栈的顺序是：右子结点、自己、左子结点。</p><p>同样，如果是    前序遍历那么加入栈的顺序应为：右子结点、左子结点、自己。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        stack&lt;pair&lt;TreeNode *, <span class="hljs-type">int</span>&gt;&gt; s;<br>        s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(root, <span class="hljs-number">0</span>)); <span class="hljs-comment">//0代表白色节点，1代表灰色节点</span><br>        <span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>()) &#123;<br>            pair&lt;TreeNode *, <span class="hljs-type">int</span>&gt; node = s.<span class="hljs-built_in">top</span>();<br>            s.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(node.first == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(node.second == <span class="hljs-number">0</span>) &#123;<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(node.first-&gt;right, <span class="hljs-number">0</span>));<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(node.first,<span class="hljs-number">1</span>));<br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(node.first-&gt;left, <span class="hljs-number">0</span>));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                res.<span class="hljs-built_in">emplace_back</span>(node.first-&gt;val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>35-合并两个链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/35-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/35-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210516172454125.png" alt="image-20210516172454125" style="zoom:50%;" /></p><p>​                                                          a &lt;= b</p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>找到list1 第a个节点的前一个节点，和第b个节点。注意节点是从0开始计数的，但是给定的a和b也是从0开始的。</p><p>添加一个哑节点dummy，因为头节点有可能被删除。</p><p>然后找到list2的尾节点，连接起来即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">mergeInBetween</span><span class="hljs-params">(ListNode* list1, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, ListNode* list2)</span> </span>&#123;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = list1;<br>        ListNode * a_pre = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a; i++) &#123;<br>            a_pre = a_pre-&gt;next;<br>        &#125;<br>        ListNode * b_node = a_pre;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; b - a + <span class="hljs-number">1</span>; i++) &#123;<br>            b_node = b_node-&gt;next;<br>        &#125;<br>        ListNode * end = list2;<br>        <span class="hljs-keyword">while</span> (end-&gt;next) &#123;<br>            end = end-&gt;next;<br>        &#125;<br>        a_pre-&gt;next = list2;<br>        end-&gt;next = b_node-&gt;next;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="算法性能"><a href="#算法性能" class="headerlink" title="算法性能"></a>算法性能</h3><p>时间复杂度：$O(b + m)$。</p><p>空间复杂度：$O(1)$。</p><p>无参考做法。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>34-交换链表中的节点</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/34-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/34-%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210512220827244.png" alt="image-20210512220827244" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这题贼简单。</p><p>要交换正数第k个节点和倒数第k个节点的值。</p><p>只要找到这俩节点即可。</p><p>正数第k个节点很好找，只要从头节点向后走k - 1步即可。</p><p>找倒数第k个节点，可参考 链表中倒数第k个节点那道题。</p><p>使用快慢指针法。两个指针，former和rear，初始都指向头节点，rear向后走k步，然后两个指针同时向后走，当rear为空时，former指向的就是倒数第k个节点。</p><p>然后交换值即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapNodes</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode * node = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k - <span class="hljs-number">1</span>; i++) &#123;<br>            node = node-&gt;next;<br>        &#125;<br>        ListNode * former = node;<br>        ListNode * rear = head;<br>        node = node-&gt;next;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            node = node-&gt;next;<br>            rear = rear-&gt;next;<br>        &#125;<br>        <span class="hljs-type">int</span> temp = former-&gt;val;<br>        former-&gt;val = rear-&gt;val;<br>        rear-&gt;val = temp;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><p>无参考做法。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>33-奇偶链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/33-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/33-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210511152514002.png" alt="image-20210511152514002" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>维护两个虚链表，一个是奇数项组成的链表，一个是偶数项组成的链表。</p><p>之所以叫虚链表，是因为并没有创建新的节点，是在原来的链表上虚拟出来的。</p><p>使用指针cur遍历链表，但是cur每次走两步，也就是cur只会指向奇数项节点。</p><p>然后将该奇数项节点和其后的偶数项节点分别插入到两个虚链表的尾部。</p><p>因为奇数项链表一定在偶数项链表之前。</p><p>所以对于奇数项链表，只需要维护一个指向尾节点的指针odd即可；</p><p>对于偶数项链表，因为每次插入一个奇数项节点，都需要连接到后面的偶数项节点的头部，所以需要维护两个指针：</p><p>even_head和even_tail，即链表头部和尾部。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode * odd = head;              <span class="hljs-comment">//奇数链表尾部</span><br>        ListNode * even_head = head-&gt;next;  <span class="hljs-comment">//偶数链表头部</span><br>        ListNode * even_tail = head-&gt;next;  <span class="hljs-comment">//偶数链表尾部</span><br><br>        ListNode * cur = head-&gt;next-&gt;next;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            ListNode * temp = cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next ? cur-&gt;next-&gt;next : <span class="hljs-literal">nullptr</span>;<br>            even_tail-&gt;next = cur-&gt;next;<br>            cur-&gt;next =even_head;<br>            odd-&gt;next = cur;<br><br>            odd = odd-&gt;next;<br>            even_tail = even_tail-&gt;next;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注：第13行temp赋值，也可以去掉对<code>cur-&gt;next-&gt;next</code>的判空。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历链表，$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>物理分成两个链表，一个奇数链表，一个偶数链表，然后再将两个链表连接起来。</p><p>整个链表头节点就是奇数链表头节点，oddHead指针指向该节点；</p><p>链表头节点的下一个节点就是偶数链表头节点，evenHead指针指向该节点。</p><p>然后使用odd和even两个指针分别进行迭代，初始，odd指向oddHead，even指向evenHead。</p><p>然后：</p><ol><li>首先连接奇数节点，even的下一个节点就是奇数链表的下一个要连接的节点，即<code>odd-&gt;next = even-&gt;next</code>，然后<code>odd = odd-&gt;next</code></li><li>然后链接偶数节点，此时odd的下一个节点就是偶数链表要连接的下一个节点，即<code>even-&gt;next = odd-&gt;next</code>，然后<code>even-&gt;next</code></li></ol><p>迭代结束的条件是：<code>even == null || even-&gt;next == null</code>。</p><p>因为：</p><p>如果总节点数为2n，则奇偶节点各n个，且偶节点是尾节点，所以当even指向尾节点时，迭代结束，此时odd指向最后一个奇数节点；</p><p>总节点为2n + 1时，偶节点有n个，奇数节点有n + 1个，且奇数节点是尾节点，所以当even为空时，迭代结束，此时odd同样指向最后一个奇数节点。</p><p>最后将两个链表连接起来即可。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">oddEvenList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode * oddHead = head;              <span class="hljs-comment">//奇数链表</span><br>        ListNode * evenHead = head-&gt;next;  <span class="hljs-comment">//偶数链表</span><br>        ListNode * odd = oddHead;<br>        ListNode * even = evenHead;<br><br>        <span class="hljs-keyword">while</span> (even &amp;&amp; even-&gt;next) &#123;<br>            odd-&gt;next = even-&gt;next;<br>            odd = odd-&gt;next;<br><br>            even-&gt;next = odd-&gt;next;<br>            even = even-&gt;next;<br>        &#125;<br>        odd-&gt;next = evenHead;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>31-环形链表 II</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/31-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/31-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%20II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210509194713023.png" alt="image-20210509194713023" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>哈希表法。</p><p>使用已访问集合，即一个set集合来保存已访问过的节点指针。</p><p>遍历链表，每访问一个节点，检查它的next节点是否在集合中。</p><p>如果不存在，则将它的next节点存到字典中，并访问下一个节点；如果存在则当前节点就是链表尾节点，入环的第一个节点就是当前节点的next节点。</p><p>同时，注意判断当前节点的next节点是否为空。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        unordered_set&lt;ListNode *&gt; nodes;<br>        nodes.<span class="hljs-built_in">insert</span>(head);<br>        ListNode * cur = head;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; !nodes.<span class="hljs-built_in">count</span>(cur-&gt;next)) &#123;<br>            nodes.<span class="hljs-built_in">insert</span>(cur-&gt;next);<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cur-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历链表，$O(n)$。</p><p>空间复杂度：使用set集合，$O(n)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>快慢指针法。</p><p>使用两个指针fast和slow，开始两指针都指向头节点，然后fast每次走两步，slow每次走一步。如果链表有环，则fast指针和slow指针一定会在环内某个节点相遇。</p><p>如图，设从链表头节点到入环第一个节点距离为a,入环第一个节点到相遇点距离为b，相遇点走到入环第一个节点距离为c。</p><p>那么当两指针相遇时，设fast指针在环中走了n圈。</p><p>则fast指针所走的距离为：<script type="math/tex">a + n(b +c) + b</script>。，又 fast指针走的距离一定是slow走的距离的两倍。</p><p>即：<script type="math/tex">a + n(b + c) + b = 2(a + b)</script>。</p><p>化简得：<script type="math/tex">a = c + (n - 1)(b + c)</script>。即，从相遇点走到入环第一个节点，再走n - 1圈的距离和头节点到入环第一个节点的距离a相等。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210509200935026.png" alt="image-20210509200935026" style="zoom:50%;" /></p><p>因此，当fast指针和slow指针相遇时，再设一个指针node指向头节点，slow和node指针同时向后走，它们会在入环第一个节点相遇。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode * fast = head;<br>        ListNode * slow = head;<br>        <span class="hljs-keyword">while</span> (fast) &#123;<br>            <span class="hljs-keyword">if</span>(fast-&gt;next == <span class="hljs-literal">nullptr</span> || fast-&gt;next-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br><br>            <span class="hljs-keyword">if</span>(slow == fast) &#123;<br>                ListNode * node = head;<br>                <span class="hljs-keyword">while</span> (slow != node) &#123;<br>                    slow = slow-&gt;next;<br>                    node = node-&gt;next;<br>                &#125;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>30-复制带随机指针的链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/30-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/30-%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210508210155323.png" alt="image-20210508210155323" style="zoom:50%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210508210231779.png" alt="image-20210508210231779" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>其实就是根据给定链表复制一个新链表，只不过多了random指针。它指向链表任意一个节点或者null。</p><p>因为链表中节点值有可能重复，所以不能以节点值为依据来判断该指向哪个节点。</p><p>而链表中索引是一定的，所以我是用索引来决定random指针该指向哪个节点。</p><p>设给定链表为head，复制的新链表为newHead。</p><p>所以首先创建index数组，来存放head链表每个节点的random指针指向的节点 在head链表中的索引，以0开始。如果指向null，则为-1。</p><p>因为random任意指，所以每访问一个节点，都需要遍历一遍链表。</p><p>然后按照head链表，创建newHead链表，先不管random指针。</p><p>然后将newHead链表每个节点的指针依次放入数组中，来建立索引。</p><p>然后依据索引数组，设置newHead链表每个节点的random指针应指向的节点。</p><p>如果索引为-1，则指向null。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<br><br>        <span class="hljs-comment">//生成所有节点的random指针所指向的节点在链表中的索引数组</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; index;<br>        Node * cur = head;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;random == <span class="hljs-literal">nullptr</span>) &#123;<br>                index.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">-1</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Node * temp = cur-&gt;random;<br>                Node * node = head;<br>                <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (node) &#123;<br>                    <span class="hljs-keyword">if</span>(temp != node) &#123;<br>                        count++;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        index.<span class="hljs-built_in">push_back</span>(count);<br>                    &#125;<br>                    node = node-&gt;next;<br>                &#125;<br>            &#125;<br>            cur = cur-&gt;next;<br><br>        &#125;<br><br>        <span class="hljs-comment">//创建新链表</span><br>        Node * newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>        Node * pre = newHead;<br>        Node * node = head-&gt;next;<br>        vector&lt;Node *&gt; nodes;<br>        nodes.<span class="hljs-built_in">push_back</span>(newHead);<br>        <span class="hljs-comment">//按照给定链表创建每个节点,同时将新创建的节点放入节点指针数组中</span><br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            Node * temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>            nodes.<span class="hljs-built_in">push_back</span>(temp);<br>            pre-&gt;next = temp;<br>            pre = temp;<br>            node = node-&gt;next;<br>        &#125;<br>        <br>        node = newHead;<br>        <span class="hljs-comment">//设置新链表节点的random指针</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; index.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(index[i] == <span class="hljs-number">-1</span>) &#123;<br>                node-&gt;random = <span class="hljs-literal">nullptr</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                node-&gt;random = nodes[index[i]];<br>            &#125;<br>            node = node-&gt;next;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead;<br><br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：在建立索引数组时，每访问一个节点，都需要遍历链表，为$O(n^2)$，然后创建新链表，同时将新创建节点指针放入数组中，然后再次遍历设置random指针，时间复杂度为$O(n)$。所以总的时间复杂度为$O(n^2)$。</p><p>空间复杂度：使用了两个数组，一个用来存放索引的数组，一个放节点指针数组，因此空间复杂度为$O(n)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><p>共有三种做法：回溯，迭代，迭代的优化($O(1)$空间)。</p><p>第一种使用到了图的遍历，我没看懂，等我复习了图再更新。</p><p>说一下第二种和第三种。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>维护一个已访问字典，保持旧节点和新节点的对应。即map集合，key为旧节点，value为新节点。</p><p>首先从头开始遍历旧链表：</p><p>对于每一个random指针：</p><ul><li>如果当前节点的random指针指向一个结点j并且j已经被创建过，则直接使用已访问字典该节点的引用</li><li>如果当前节点的random指针指向的节点 j 还没有被创建，即已访问字典中没有，那么就创建该节点并将其放入字典中，然后同样使用该节点的引用</li></ul><p>对于每一个next指针：</p><ul><li>如果当前节点的next指针指向的节点在已访问字典中存在，则直接使用该节点的引用</li><li>如果不存在，则创建新节点，同时放入字典中，，并返回该节点引用</li></ul><p>当给定链表遍历完毕，复制完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    unordered_map&lt;Node *, Node *&gt;  visited;<br><br>    <span class="hljs-function">Node * <span class="hljs-title">getCloneNode</span><span class="hljs-params">(Node * node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>-&gt;visited.<span class="hljs-built_in">count</span>(node)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;visited[node];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Node * temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>                visited.<span class="hljs-built_in">insert</span>(&#123;node, temp&#125;);<br>                <span class="hljs-keyword">return</span> temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;&#125;<br>        Node * oldHead = head;<br>        Node * newHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(head-&gt;val);<br>        visited.<span class="hljs-built_in">insert</span>(&#123;oldHead, newHead&#125;);<br>        Node * cur = newHead;<br>        <span class="hljs-keyword">while</span> (oldHead) &#123;<br>            cur-&gt;random = <span class="hljs-built_in">getCloneNode</span>(oldHead-&gt;random);<br>            cur-&gt;next = <span class="hljs-built_in">getCloneNode</span>(oldHead-&gt;next);<br>            oldHead = oldHead-&gt;next;<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历链表，为$O(n)$。</p><p>空间复杂度：使用map集合，$O(n)$。</p><h3 id="迭代的优化"><a href="#迭代的优化" class="headerlink" title="迭代的优化"></a>迭代的优化</h3><h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><p>不使用map集合。而是将原链表当做一个map集合。</p><p>首先，对于原链表的每个节点，创建一个新节点放在后面。</p><p>例如，链表ABCD，则创建后的链表变为:AA BB CC DD。</p><p>就是创建一个值相等的节点放在对应结点后面。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210508215200799.png" alt="image-20210508215200799" style="zoom:50%;" /></p><p>那么令原节点的random指针指向的节点为a，则新创建的节点的random指针应指向<code>`a-&gt;next</code>。</p><p>例如图中A节点的random指针指向C，则新创建的节点的random指针指向C节点后面的新创建节点。</p><p>next指针也是这个道理。</p><p>这样就可以在不借助额外空间的情况下，以原链表作为map集合，直接创建节点并设置对应指针。</p><p>巧妙~</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        Node * node = head;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            Node * temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(node-&gt;val);<br>            temp-&gt;next = node-&gt;next;<br>            node-&gt;next = temp;<br>            node = node-&gt;next-&gt;next;<br>        &#125;<br>        Node * newHead = head-&gt;next;<br><br>        node = head;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-comment">//修改新创建节点的random指针，注意判断如果原节点random为空，则对应新节点也为空。</span><br>            node-&gt;next-&gt;random = node-&gt;random != <span class="hljs-literal">nullptr</span> ? node-&gt;random-&gt;next : <span class="hljs-literal">nullptr</span>;<br>            node = node-&gt;next-&gt;next;<br>        &#125;<br>        node = head;<br>        <span class="hljs-keyword">while</span> (node) &#123;<br>            <span class="hljs-comment">//保存node指针以原链表顺序的下一个节点</span><br>            Node * rear = node-&gt;next-&gt;next;<br>            node-&gt;next-&gt;next = rear != <span class="hljs-literal">nullptr</span> ? rear-&gt;next : <span class="hljs-literal">nullptr</span>;<br>            node-&gt;next = rear;<br>            node = rear;<br>        &#125;<br>        <span class="hljs-keyword">return</span> newHead;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>最后旧链表会恢复原状。</p><h4 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>29-反转链表II</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/29-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/29-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210507213506264.png" alt="image-20210507213506264" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>反转部分链表，那就找到该链表的头节点，并将尾节点的next置为null，变成一个独立的链表，然后使用反转链表题目中的算法。</p><p>此时，还剩前一段链表和后一段链表，分别使用两个指针来指针前一段链表的尾节点和后一段链表的头节点，用于链表反转后的拼接。</p><p>同时注意，因为链表头节点头可能会被反转，所以添加一个哑节点。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode * head)</span> </span>&#123;<br>        ListNode * pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode * cur = head;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            ListNode * temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function">ListNode * <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        <span class="hljs-comment">//前一段链表的尾节点</span><br>        ListNode * pre = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        ListNode * start = head;<br>        ListNode * end = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left <span class="hljs-number">-1</span>; i++) &#123;<br>            start = start-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right <span class="hljs-number">-1</span>; i++) &#123;<br>            end = end-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//后一段链表的头节点</span><br>        ListNode * rear = end-&gt;next;<br>        end-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-built_in">reverse</span>(start);<br><br>        pre-&gt;next = end;<br>        start-&gt;next = rear;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><p>参考给了两种做法，第一种叫穿针引线，其实就是我那种做法。</p><p>第二种做法给出了第一种做法的优化。</p><p>因为第一种做法，虽然时间复杂度是<script type="math/tex">O(n)</script>，但是当left和right差距很大时，实际是遍历了链表两次，找到待反转头尾节点试一次，进行反转又是一次。</p><p>第二种做法优化了一下。</p><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>同样还是分前一段链表和后一段链表。</p><p>遍历待反转节点，每访问一个节点，就将该节点放到前一段链表的尾节点的下一个位置处。</p><p>使用三个指针：pre，cur，next，他们的意义是：</p><ul><li>pre<strong>永远</strong>指向待反转链表的前一个节点，即前一段链表的尾节点</li><li>cur指向待反转节点，即用来遍历待反转链表</li><li>next指向cur节点的下一个节点</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210507215323155.png" alt="image-20210507215323155" style="zoom:53%;" /></p><p>然后按下面步骤来做：</p><ol><li>cur的下一个节点指向next的下一个节点，以图为例就是，节点2指向节点4</li><li>next的下一个节点指向pre的下一个节点，以图为例：节点3指向节点2</li><li>pre的下一个节点指向next，即节点1指向节点3</li></ol><p>这样就完成了一个节点的反转。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function">ListNode * <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        <span class="hljs-comment">//前一段链表的尾节点</span><br>        ListNode * pre = dummy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left - <span class="hljs-number">1</span>; i++) &#123;<br>            pre = pre-&gt;next;<br>        &#125;<br>        ListNode * cur = pre-&gt;next;<br>        ListNode * next;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br>            next = cur-&gt;next;<br>            cur-&gt;next = next-&gt;next;<br>            next-&gt;next = pre-&gt;next;<br>            pre-&gt;next = next;<br><br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：只遍历了一次链表，$O(n)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>28-分割链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/28-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/28-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210506195639051.png" alt="image-20210506195639051" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>遍历链表，将所有比x小的节点放到链表前面来。又要求相对位置不能改变，所以应将比x小的节点，放到所有比x小的节点组成的链表的末尾。</p><p>因为有可能添加的节点会放到链表头，所以添加哑节点(dummy node)。</p><p>所以设置指针less指向所有比x小的节点组成的链表的尾节点，初始指向哑节点。</p><p>设cur指针来遍历链表，初始指向头节点。</p><p>同时当将比x小的节点放到前面时，该节点的前一个节点的next也应该修改，所以添加一个指针pre指向cur的前一个节点。</p><p>同时注意，如果cur指向的节点小于x，但是该节点是less指针的下一个节点，即该节点已经在正确位置了，就不需要改动了。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode * less = dummy;<br>        ListNode * pre = dummy;<br>        ListNode * cur = head;<br><br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;val &lt; x) &#123;<br>                <span class="hljs-keyword">if</span>(less-&gt;next == cur) &#123;<br>                    less = cur;<br>                    pre = cur;<br>                    cur = cur-&gt;next;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    pre-&gt;next = cur-&gt;next;<br>                    cur-&gt;next = less-&gt;next;<br>                    less-&gt;next = cur;<br><br>                    less = cur;<br>                    cur = pre-&gt;next;<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = cur;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>模拟。</p><p>维护两个链表，一个比x小的链表small，一个比x大的链表large。最后将large链表放到small链表的后面即可。</p><p>创建两个哑节点，分别使用smallHead和largeHead指针来指向这两个节点，同时设置small和large指针来分别指向两个链表的尾节点，初始时这两个指针同样指向各自的哑节点。</p><p>然后遍历链表，如果小于x，则放到small指向的节点后面，然后small指针指向该节点；</p><p>如果大于x，则放到large指向的节点后面，然后large指针指向该节点。</p><p>便利结束后，将两个链表连接起来即可。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">partition</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125; <span class="hljs-comment">//可有可无</span><br>        ListNode * smallHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * largeHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * small = smallHead;<br>        ListNode * large = largeHead;<br><br>        <span class="hljs-keyword">while</span> (head) &#123;<br>            <span class="hljs-keyword">if</span>(head-&gt;val &lt; x) &#123;<br>                small-&gt;next = head;<br>                small = small-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                large-&gt;next = head;<br>                large = large-&gt;next;<br>            &#125;<br>            head = head-&gt;next;<br>        &#125;<br>        large-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        small-&gt;next = largeHead-&gt;next;<br>        <span class="hljs-keyword">return</span> smallHead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>27-删除升序链表中的重复元素II</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/27-%E5%88%A0%E9%99%A4%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/27-%E5%88%A0%E9%99%A4%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210506191316234.png" alt="image-20210506191316234" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>因为有可能头节点是重复节点，所以方便删除，可以添加一个哨兵节点，即在头节点前再添加一个节点。</p><p>设置计数变量count，初始为1，如果有重复节点，则count &gt;= 2。</p><p>设置pre指向访问过程中已知的最后一个不重复的节点，初始指向哨兵节点。</p><p>设置cur指针来遍历节点，初始指向头节点。</p><p>遍历链表，当当前链表的下个节点的值和当前节点的值相等时，就访问下个节点。同时计数变量count 加1。</p><p>如果不相等，有两种情况：</p><ol><li>count为1，说明不是重复节点，则将pre指向cur指向的节点，即<code>pre = cur</code>，同时cur访问下一个节点</li><li>count不为1，则说明是重复节点，应该删除。则令pre的next指向cur的next，同时计数变量重新置为1，并访问下个节点</li></ol><p>注：(pre, cur]之间的为重复的节点，不包括pre，包括cur。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br>        ListNode * sentinel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        sentinel-&gt;next = head;<br>        ListNode * pre = sentinel;<br>        ListNode * cur = head;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (cur) &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val == cur-&gt;val) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(count != <span class="hljs-number">1</span>) &#123;<br>                    pre-&gt;next = cur-&gt;next;<br>                    count = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    pre = cur;<br>                &#125;<br>            &#125;<br>            cur = cur-&gt;next;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> sentinel-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历一遍链表，$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>设置一个哑结点(dummy node，其实和哨兵节点一样，就是在头节点前加一个节点)。</p><p>设置指针cur，初始指向哑结点，然后判断cur-&gt;next和cur-&gt;next-&gt;next的值是否相等，</p><p>如果相等，那么就记录下该值x，并循环删除cur-&gt;next及其后面所有和x相等的值，直到cur-&gt;next为空或cur-&gt;next的值和x不相等；</p><p>如果不相等，那么就cur就指向下一个节点。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br>        ListNode * dummy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        dummy-&gt;next = head;<br>        ListNode * cur = dummy;<br>        <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;<br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val) &#123;<br>                <span class="hljs-type">int</span> x = cur-&gt;next-&gt;val;<br>                <span class="hljs-keyword">while</span> (cur-&gt;next || cur-&gt;next-&gt;val == x) &#123;<br>                    cur-&gt;next = cur-&gt;next-&gt;next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = cur-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><p>注：如果只是做题，可以不释放删除节点的内存，但在实际工作中，一定是要释放的。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>26-旋转链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/26-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/26-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210505191915549.png" alt="image-20210505191915549" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>链表长度为n，如果k &gt;=n的话， 则移动 k <code>mod</code> n 和移动k个位置效果是一样的。</p><p>新链表的头节点应该是原链表的第 n - (k mod n) 个节点(从0开始)。</p><p>所以可以先找到第 n - (k mod n)个节点的前一个节点 和 最后一个节点。</p><p>让新链表指针指向第 n - (k mod n)个节点。</p><p>然后修改它的前一个节点的next指针为空，最后一个节点的next指针为原链表头节点即可。</p><p>注意：k 为 0 时，或给定链表为空或只有一个节点时，直接返回即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br>        <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>        ListNode * node = head;<br>        <span class="hljs-keyword">while</span>(node) &#123;<br>            size++;<br>            node = node-&gt;next;<br>        &#125;<br>        k = k % size;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br><br>        ListNode * former = head;<br>        ListNode * latter = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            latter = latter-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(latter-&gt;next) &#123;<br>            former = former-&gt;next;<br>            latter = latter-&gt;next;<br>        &#125;<br><br>        ListNode * newHead = former-&gt;next;<br>        latter-&gt;next = head;<br>        former-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历了两遍链表，为$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>同样，先链表获得链表长度n。</p><p>那么第(n - k mod n) 个节点就是新链表的头节点。</p><p>将原链表闭合为环，即最后一个节点指向第一个节点。</p><p>然后从原链表头节点开始向后移动 (n - k mod n - 1)步，指向新链表头节点的前一个节点。</p><p>断开即可。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">rotateRight</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        ListNode * node = head;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(;node-&gt;next != <span class="hljs-literal">nullptr</span>; n++, node = node-&gt;next);<br>        k = k % n;<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br>        node-&gt;next = head;<br>        node = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - k - <span class="hljs-number">1</span>; i++) &#123;<br>            node = node-&gt;next;<br>        &#125;<br>        ListNode * newHead = node-&gt;next;<br>        node-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>25-链表求和</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/25-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/25-%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210503110129274.png" alt="image-20210503110129274" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>因为是反向存放，个位在首部。所以可以遍历，两个链表对应位置节点相加，构成一个新的节点。</p><p>如果值大于等于10，则进位 为1，否则为 0 。</p><p>最后遍历结束，如果进位为1，则在链表末尾添加一个值为1的节点。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ListNode* <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>        ListNode * head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        ListNode * node = head;<br>        <span class="hljs-type">int</span> carry = <span class="hljs-number">0</span>; <span class="hljs-comment">//进位</span><br>        <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> || l2 != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">nullptr</span>) &#123;<br>                sum = l2-&gt;val + carry;<br>                l2 = l2-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">nullptr</span>) &#123;<br>                sum = l1-&gt;val + carry;<br>                l1 = l1-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                sum = l1-&gt;val + l2-&gt;val + carry;<br>                l1 = l1-&gt;next;<br>                l2 = l2-&gt;next;<br>            &#125;<br>            ListNode * temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(sum % <span class="hljs-number">10</span>, <span class="hljs-literal">nullptr</span>);<br>            node-&gt;next = temp;<br>            node = temp;<br>            <span class="hljs-keyword">if</span>(sum &gt;= <span class="hljs-number">10</span>) &#123;<br>                carry = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                carry = <span class="hljs-number">0</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">if</span>(carry) &#123;<br>            ListNode *temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">nullptr</span>);<br>            node-&gt;next = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(max(n ,m))$，其中n和m分别为两个链表的长度。</p><p>空间复杂度：除去需要返回的链表，只用了几个变量。$O(1)$。</p><p>参考做法也差不多。</p><h3 id="进阶思路"><a href="#进阶思路" class="headerlink" title="进阶思路"></a>进阶思路</h3><p>进阶 就是如果数字是正向放的。</p><p>可以使用两个栈，先遍历一遍，将链表数字放入栈中。再同时出栈，相加。和反向思路差不多了。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>24-两两交换链表中的节点</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210502135928402.png" alt="image-20210502135928402" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>先添加一个哨兵节点sentinel，初始时 指针node指向哨兵节点。判断哨兵节点后是否有两个节点。</p><p>如果有，则使用first和second指针指向这两个节点，首先：</p><ul><li>node节点的next指向second</li><li>first节点的next指向second节点的next</li><li>second节点的next指向first</li></ul><p>两个节点交换完毕。</p><p>然后node指向当前节点的下下个节点。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * sentinel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        sentinel-&gt;next = head;<br>        ListNode * node = sentinel;<br>        <span class="hljs-keyword">while</span> (node-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; node-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode * first = node-&gt;next;<br>            ListNode * second = node-&gt;next-&gt;next;<br>            <br>            node-&gt;next = second;<br>            first-&gt;next = second-&gt;next;<br>            second-&gt;next = first;<br><br>            node = node-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sentinel-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(N)$。</p><p>空间复杂度：$O(1)$。</p><p>参考解法有两种解法。</p><p>第一种，使用递归，时间复杂度和空间复杂度都是$O(n)$。</p><p>第二种和我的方法一样。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>23-二进制链表转整数</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/23-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/23-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210501173831068.png" alt="image-20210501173831068" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这题很简单。</p><p>使用变量result代表最后结果，初始为0。 遍历链表，每次result 乘 2，再加上当前节点值。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getDecimalValue</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        ListNode * node = head;<br>        <span class="hljs-keyword">while</span> (node != <span class="hljs-literal">nullptr</span>) &#123;<br>            result = result * <span class="hljs-number">2</span> + node-&gt;val;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><p>参考答案也是这个做法。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22-链表中间节点</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210501173106938.png" alt="image-20210501173106938" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用快慢指针。两个指针初始都指向头节点，快指针每次走两步，慢指针每次走一步。</p><p>当快指针到达链表末尾时，慢指针刚好指向中间节点。</p><p>该题说：如果有两个中间节点，返回第二个。</p><p>那么循环结束条件应该是：快指针的下一个节点为空，或快指针本身为空。</p><p>如果要返回第一个：那就是快指针的下一个节点或下下个节点为空。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * fast = head;<br>        ListNode * slow = head;<br>        <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            fast = fast-&gt;next-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><p>官方给了三个解法。</p><p>第一种使用数组，时间复杂度是$O(n)$，空间复杂度也是$O(n)$。</p><p>第二种是遍历两次链表，第一个获得链表长度，第二次根据链表长度找到中间节点。</p><p>第三种和我的做法一样。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21-删除链表的倒数第N个节点</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/21-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/21-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210501163949310.png" alt="image-20210501163949310" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>和18-找到链表倒数第k个节点类似。使用两个指针right和left。right指针先向后走k步，然后两个指针同时向后走，直到right指针指向空，此时left指向的是倒数第k个节点。</p><p>但不同的是，18是找到倒数第k个节点，而该题是删除倒数第N个节点，所以需要找到倒数第N个节点的前一个节点。</p><p>还要考虑到边界问题，如删除第一个节点。</p><p>所以可以使用一个哨兵节点，即在头节点前添加一个节点，这样所有 有可能被删除的节点都是中间节点，不需要单独考虑边界问题。</p><p>不过要注意两个问题：</p><ul><li>因为多了一个节点，所以如果righ初始指向哨兵节点，则right指针要走N + 1步</li><li>最后返回值记得返回哨兵节点的next。</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年05月01日17时16分46秒.gif" alt="21年05月01日17时16分46秒" style="zoom:43%;" /></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode * temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        temp-&gt;next = head;<br>        ListNode * left = temp;<br>        ListNode * right = temp;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; ++i) &#123;<br>            right = right-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (right != <span class="hljs-literal">nullptr</span>) &#123;<br>            left = left-&gt;next;<br>            right = right-&gt;next;<br>        &#125;<br>        left-&gt;next = left-&gt;next-&gt;next;<br>        <span class="hljs-keyword">return</span> temp-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="参考做法"><a href="#参考做法" class="headerlink" title="参考做法"></a>参考做法</h2><p>给出了三个解法。第三个就是我自己的做法。</p><p>第一个做法是先遍历一遍，获得链表长度，然后删除。</p><p>第二个做法是使用栈来保存每个节点的指针，先依次将节点入栈，那么倒数第N个节点，就是弹出栈的第N个节点。</p><p>同时注意边界问题，即删除头节点。所以可以添加一个哨兵节点，再入栈。</p><p>时间复杂度是$O(n)$，空间复杂度也是$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20-回文链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/20-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/20-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210429195330695.png" alt="image-20210429195330695" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>可以遍历链表，把元素依次放入数组，然后使用两个指针一前一后来进行判断。但是该算法的时间复杂度是$O(n)$，空间复杂度也是$O(n)$。不够好。</p><p>可以将后半段链表反转，然后和前半段链表比较。然后再恢复为原来的链表(可以不恢复，但~ 恢复回来是个好的习惯)。</p><ol><li>找到前半段链表的最后一个节点。通过快慢指针方法。</li><li>反转后半段链表</li><li>进行比较</li><li>将链表恢复</li></ol><h4 id="找到前半部分链表的尾节点"><a href="#找到前半部分链表的尾节点" class="headerlink" title="找到前半部分链表的尾节点"></a>找到前半部分链表的尾节点</h4><p>使用快慢指针法。</p><p>通过两个指针slow和fast，开始都指向head。</p><p>然后slow向后走一步，fast向后走两步。当<code>fast-&gt;next == nullptr || fast-&gt;next-&gt;next == nullptr</code>时，循环结束。</p><p>此时slow指向的就是前半部分链表的尾节点。</p><h4 id="反转后半部分链表"><a href="#反转后半部分链表" class="headerlink" title="反转后半部分链表"></a>反转后半部分链表</h4><p>之前也做过反转链表的题目，直接使用该算法即可。</p><p>使用两个指针cur和pre，初始cur指向head，pre指向null。</p><p>然后开始循环：</p><ol><li>创建局部变量temp = cur-&gt;next，来保存下一个节点</li><li>cur指向的结点的next指向pre</li><li>pre = cur</li><li>cur = temp</li></ol><p>当 cur == nullptr时，循环结束。</p><p>此时pre指向的就是链表反转后的头节点。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> ListNode * <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode * head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br>        ListNode * cur = head;<br>        ListNode * pre = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            ListNode * temp = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = temp;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> ListNode * <span class="hljs-title">endOfFirstList</span><span class="hljs-params">(ListNode * head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br>        ListNode * slow = head;<br>        ListNode * fast = head;<br>        <span class="hljs-keyword">while</span> (fast-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br><br>        ListNode * endOfFirst = <span class="hljs-built_in">endOfFirstList</span>(head);<br>        ListNode * startOfSecond = endOfFirst-&gt;next;<br>        endOfFirst-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        startOfSecond = <span class="hljs-built_in">reverse</span>(startOfSecond);<br><br>        ListNode * first = head, * second = startOfSecond;<br>        <span class="hljs-type">bool</span> result = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">while</span> (result &amp;&amp; second != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(first-&gt;val != second-&gt;val) &#123;<br>                result = <span class="hljs-literal">false</span>;<br>            &#125;<br>            first = first-&gt;next;<br>            second = second-&gt;next;<br>        &#125;<br>        startOfSecond = <span class="hljs-built_in">reverse</span>(startOfSecond);<br>        endOfFirst-&gt;next = startOfSecond;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：找到前半部分链表的尾结点和反转链表的时间复杂度都是$O(n)$，依次比较时间复杂度也是$O(n)$。所以总的时间复杂度是$O(n)$。</p><p>空间复杂度：$O(1)$。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><p>官方有三个做法，第一个就是我说的数组法。第三个和我的做法相同，反转链表法。</p><p>第二个是递归法。</p><p>下面只说递归法。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>因为单链表只能向后遍历，不能往回遍历。所以可以使用递归，一直递归到尾节点，然后回溯。递归方法外的定义一个变量，初始指向头节点。依次和回溯的进行比较。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ListNode * front;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">recursion</span><span class="hljs-params">(ListNode * head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">recursion</span>(head-&gt;next)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(head-&gt;val != front-&gt;val) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            front = front-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        front = head;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">recursion</span>(head);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：在递归调用时，计算机会使用堆栈来存放调用前的数据。因此也是$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19-删除中间节点</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/19-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/19-%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210429185122232.png" alt="image-20210429185122232" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>要删除给定单链表的节点，所以无法找到该节点的前一个节点。也就无法通过改变指针来删除。</p><p>所以可以将待下一个节点的值赋给待删除节点，然后删除下一个节点即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(ListNode* node)</span> </span>&#123;<br>        node-&gt;val = node-&gt;next-&gt;val;<br>        node-&gt;next = node-&gt;next-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(1)$。</p><p>空间复杂度：$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>17-最大连续1的个数</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/17-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/17-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210427200820859.png" alt="image-20210427200820859" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用两个变量max和current，max用来存当前已访问过的元素中最大连续1的个数，current表示当前正在访问的连续1的最大个数。</p><p>如果当前元素不为1或者遍历结束，就和max比较，将较大值赋给max即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMaxConsecutiveOnes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> max = <span class="hljs-number">0</span>, current = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">1</span>) &#123;<br>                current++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                max = max &lt; current ? current : max;<br>                current = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        max = max &lt; current ? current : max;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历数组，$O(n)$。</p><p>空间复杂度：$O(1)$。</p><p>官方给出的解法一样。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>16-找到所有数组中消失的数字</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/16-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/16-%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210426192929408.png" alt="image-20210426192929408" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>因为数组满足 <script type="math/tex">1</script> &lt;= $a_i$ &lt;= n，所以可以以数组下标来作为对应数字。</p><p>返回数组为result，首先根据输入数组nums的长度length，在result中插入length个0。</p><p>然后遍历数组nums，对于每个数字，将该数字 - 1，并作为result的下标，对应元素 + 1。</p><p>遍历结束后，没有出现的数字，作为result的索引，对应数字会是0。</p><p>就找到了所有消失的数字。</p><p>然后根据 移动零 那道题的算法，稍微改一下，将所有0对应的索引挪到数组最前面来。然后删除其他元素即可。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            result.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            result[nums[i] - <span class="hljs-number">1</span>]++;<br>        &#125;<br><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>, count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; length) &#123;<br>            <span class="hljs-keyword">if</span>(result[right] == <span class="hljs-number">0</span>) &#123;<br>                result[left] = right + <span class="hljs-number">1</span>;<br>                count++;<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length - count; i++) &#123;<br>            result.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：以为使用返回数组就不算额外空间。但是要添加n个元素。其实还是用了$O(n)$。</p><p>并不是在返回数组操作就不算额外空间。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>可以把输入数组本身作为一个哈希表。</p><p>遍历数组，对于数组每一个元素x，令<code>num[x - 1] += length</code>，其中length是数组长度。</p><p>因为1 &lt;= $a_i$ &lt;= n，所以遍历完成后，消失的数字作为下标，对应元素一定满足该关系。而出现的数字作为下标，对应元素一定大于n。</p><p>注意：因为访问到的元素有可能增加过，因此要取模来获得下标。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">findDisappearedNumbers</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-type">int</span> x = (nums[i] - <span class="hljs-number">1</span>) % length;<br>            nums[x] += length;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] &lt;= length) &#123;<br>                result.<span class="hljs-built_in">push_back</span>(i + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$</p><p>空间复杂度：$O(1)$</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15-第三大的数</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/15-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/15-%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210425204330039.png" alt="image-20210425204330039" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>定义三个变量：max、second_max、third_max，首先遍历数组，找出最大的数。</p><p>然后再次遍历数组，但注意：<strong>只有当该数不等于max时，才进行下一步操作</strong>，找出第二大的数second_max。</p><p>然后再次遍历数组，同样：<strong>只有当该数不等于max和second_max时，才进行下一步操作</strong>，找出第三大的数third_max。</p><p>返回即可。</p><p><strong>注：</strong></p><ul><li><strong>定义一个标志变量<code>init_status</code>来标识  表示second_max和third_max是否被改变了初始值。</strong></li><li><strong>在找到最大值之后，second_max 和 third_max应被初始为最大值max。</strong></li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">thirdMax</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] &gt; nums[<span class="hljs-number">1</span>] ? nums[<span class="hljs-number">0</span>] : nums[<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> max = nums[<span class="hljs-number">0</span>], second_max = <span class="hljs-number">0</span>, third_max = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">bool</span> init_status = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(max &lt; nums[i]) &#123;<br>                max = nums[i];<br>            &#125;<br>        &#125;<br>        second_max = max;<br>        third_max = max;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != max) &#123;<br>                <span class="hljs-keyword">if</span>(init_status) &#123;<br>                    second_max = nums[i];<br>                    init_status = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(second_max &lt; nums[i]) &#123;<br>                    second_max = nums[i];<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        init_status = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] != max &amp;&amp; nums[i] != second_max) &#123;<br>                <span class="hljs-keyword">if</span>(init_status) &#123;<br>                    third_max = nums[i];<br>                    init_status = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span>(nums[i] &gt; third_max) &#123;<br>                    third_max = nums[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> third_max;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>注：代码很垃圾，又丑又长，但我实在没啥子好方法。</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：一共遍历了五遍数组，为$O(n)$。</p><p>空间复杂度：使用了四个变量，$O(1)$。</p><p>没有官方题解。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14-移动零</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/14-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/14-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210423205219002.png" alt="image-20210423205219002" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用哈希表，首先遍历一遍数组，将所有为0 的索引存入到哈希表中，然后再遍历数组，分为两个循环，前一个从数组开头循环到(数组长度 - 哈希表长度 - 1)位置，依次将不在哈希表中的索引对应的数字，按顺序存到数组中；后一个循环从(数组长度 - 哈希表长度)位置 循环到数组末尾，全部赋值为 0 。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        set&lt;<span class="hljs-type">int</span>&gt; indexs;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>) &#123;<br>                indexs.<span class="hljs-built_in">insert</span>(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; nums.<span class="hljs-built_in">size</span>() - indexs.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">if</span>(indexs.<span class="hljs-built_in">count</span>(count) == <span class="hljs-number">0</span>) &#123;<br>                nums[i] = nums[count];<br>                i++;<br>            &#125;<br>            count++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(i = nums.<span class="hljs-built_in">size</span>() - indexs.<span class="hljs-built_in">size</span>(); i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            nums[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历了两遍数组，为$O(n)$。</p><p>空间复杂度：使用了哈希表，为$O(n)$。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>双指针法。</p><p>左指针指向已处理好的序列的尾部；右指针指向待处理序列的头部。当右指针指向的是非零数时，交换左右指针对应的数字，左右指针分别向后走一步；如果右指针指向的为零，则右指针向后走一步。初始时，左右指针都指向数组第一个元素。</p><p>则：        </p><ol><li><strong>左指针左边是已经处理好的序列，全部为非零数</strong></li><li><strong>右指针左边和左指针及其右边之间的数全部是零</strong></li></ol><p>也就是说，左指针指向下一个需要交换的元素。右指针一直向右移动直到遇到一个不为零的数。然后交换左右指针对应的数。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月23日21时27分20秒.gif" alt="21年04月23日21时27分20秒" style="zoom:50%;" /></p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> length = nums.<span class="hljs-built_in">size</span>(), left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; length) &#123;<br>            <span class="hljs-keyword">if</span>(nums[right] != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">swap</span>(nums[left], nums[right]);<br>                left++;<br>            &#125;<br>            right++;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历了一遍数组，为$O(n)$。</p><p>空间复杂度：使用了两个指针，为$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13-丢失的数字</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/13-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/13-%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210423200434292.png" alt="image-20210423200434292" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>因为数组的长度是 n，而数字的范围是<code>[0, n]</code>。所以只差一个数字。</p><p>想到使用数列来做。具体操作是：</p><ul><li>获得数组长度n，并根据长度算出 0 ~ n 项等差数列的和。</li><li>遍历数组，求出数组每项总和</li><li>使用两项相减，即为缺失的数字</li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> ideal_sum = (size + <span class="hljs-number">1</span>) * size / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            sum = sum + nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> ideal_sum - sum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历数组，为$O(n)$。</p><p>空间复杂度：使用三个变量，为$O(1)$。</p><h3 id="其他解法"><a href="#其他解法" class="headerlink" title="其他解法"></a>其他解法</h3><p>该题还可以使用哈希表和排序来做，不过排序时间复杂度为$O(n * logn)$，哈希表空间复杂度为$O(n)$。</p><p>都不是最优解。</p><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用异或运算(即相同为0，不同为1)。首先要知道：</p><ol><li>0 和 任何数进行异或运算的结果仍为该数，即<code>0 ^ a = a</code>。</li><li>一个数和它自己进行异或结果为0 ，即<code>a ^ a = 0</code>。</li><li>异或运算满足结合律。</li></ol><p>根据这两条，可以解出该题。</p><p>因为数组有n个数，范围为<code>[0,n]</code>，所以除了缺失的数组，剩下的数字在数组中和取值范围中都有一个。</p><p>因此将<code>[0, n]</code>个数字和数组中每个元素进行异或运算，由于满足结合律且除了缺失数字其他都是两两一对，最后会变成：</p><p><code>0 ^ 缺失的数字</code> ，结果就是缺失的数字，即为答案。</p><p>可以使用数组索引和该索引对应数字依次进行异或运算，但这样只是<code>[0, n - 1]</code>和数组每个数字进行了异或运算，因此可以将结果变量初始值设为<code>n</code>，然后进行异或操作即可。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> result = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            result ^= i ^ nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历一个数组，$O(n)$。</p><p>空间复杂度：只使用了一个变量，$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12-用栈实现队列</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/12-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/12-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210423144716538.png" alt="image-20210423144716538" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>和 用队列实现栈的思想类似。</p><p>两个栈，一个为主栈，一个为辅助栈。</p><p>插入数据时，依次执行以下操作：</p><ol><li>将主栈所有元素依次弹栈并添加到辅助栈中</li><li>将待插入数据添加到辅助栈</li><li>将辅助栈元素依次弹栈添加到辅助栈</li></ol><p>插入操作完成。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月23日15时07分25秒.gif" alt="21年04月23日15时07分25秒" style="zoom:50%;" /></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; main_stack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stack;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (!main_stack.<span class="hljs-built_in">empty</span>()) &#123;<br>            stack.<span class="hljs-built_in">push</span>(main_stack.<span class="hljs-built_in">top</span>());<br>            main_stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        stack.<span class="hljs-built_in">push</span>(x);<br><br>        <span class="hljs-keyword">while</span> (!stack.<span class="hljs-built_in">empty</span>())&#123;<br>            main_stack.<span class="hljs-built_in">push</span>(stack.<span class="hljs-built_in">top</span>());<br>            stack.<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br><br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> top = main_stack.<span class="hljs-built_in">top</span>();<br>        main_stack.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> main_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> main_stack.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度</p><p>插入操作为$O(n)$，其余操作都为$O(1)$。</p><p>空间复杂度：除了要求的两个栈，没有使用其他空间，$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11-汇总区间</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/11-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/11-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210423142344594.png" alt="image-20210423142344594" style="zoom:57%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>定义一个<code>begin</code>变量，表示每一段区间的开始索引。一次访问数组每个元素，如果该元素 + 1不等于 下一个元素，表示应开始一段新区间。首先将<code>begin</code>到当前元素插入到区间数组中，然后<code>begin</code>置为下个元素的索引，继续遍历。</p><p>需要注意的是数组的末尾边界。因为要比较当前元素和下一个元素的值，所以当 访问到最后一个元素时，没有下一个元素，这时候应直接插入区间数组。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> vector&lt;string&gt; <span class="hljs-title">summaryRanges</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        vector&lt;string&gt; ranges;<br><br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>) &#123;<br>                begin = nums[<span class="hljs-number">0</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i == nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> || nums[i] + <span class="hljs-number">1</span> != nums[i + <span class="hljs-number">1</span>]) &#123;<br>                ranges.<span class="hljs-built_in">push_back</span>(begin == nums[i] ?<br>                <span class="hljs-built_in">to_string</span>(begin) : <span class="hljs-built_in">to_string</span>(begin) + <span class="hljs-string">&quot;-&gt;&quot;</span> + <span class="hljs-built_in">to_string</span>(nums[i]));<br>                <span class="hljs-keyword">if</span>(i != nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>                    begin = nums[i + <span class="hljs-number">1</span>];<br>                &#125;<br><br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> ranges;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历了一遍数组，$O(n)$。</p><p>空间复杂度：除了用于输出的区间数组，剩下只有一个<code>begin</code>变量，$O(1)$。</p><p>官方解法和我这个基本思想一样。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-用队列实现栈</title>
    <link href="/2022/05/11/leetcode/%E9%98%9F%E5%88%97/10-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <url>/2022/05/11/leetcode/%E9%98%9F%E5%88%97/10-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210422200135721.png" alt="image-20210422200135721" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>两个队列，相互交替作为数据栈。每次移除栈顶元素或返回栈顶元素时，就将当前队列数据从队列头部依次弹出，并插入到另一个队列尾部，剩下最后一个元素，如果是移除栈顶元素，则直接返回该元素；如果是返回栈顶元素，则先插入到另一个队列尾部，再返回。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue1;<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue2;<br><br>    queue&lt;<span class="hljs-type">int</span>&gt; * stack;<br>    queue&lt;<span class="hljs-type">int</span>&gt; * queue;<br>    <br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br>        stack = &amp;queue1;<br>        queue = &amp;queue2;<br><br>    &#125;<br><br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stack-&gt;<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = stack-&gt;<span class="hljs-built_in">size</span>();<br><br>        std::queue&lt;<span class="hljs-type">int</span>&gt; *temp = stack;<br>        stack = queue;<br>        queue = temp;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++) &#123;<br>            stack-&gt;<span class="hljs-built_in">push</span>(queue-&gt;<span class="hljs-built_in">front</span>());<br>            queue-&gt;<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-type">int</span> top = queue-&gt;<span class="hljs-built_in">front</span>();<br>        queue-&gt;<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> top;<br><br>    &#125;<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = stack-&gt;<span class="hljs-built_in">size</span>();<br><br>        std::queue&lt;<span class="hljs-type">int</span>&gt; *temp = stack;<br>        stack = queue;<br>        queue = temp;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size - <span class="hljs-number">1</span>; i++) &#123;<br>            stack-&gt;<span class="hljs-built_in">push</span>(queue-&gt;<span class="hljs-built_in">front</span>());<br>            queue-&gt;<span class="hljs-built_in">pop</span>();<br>        &#125;<br><br>        <span class="hljs-type">int</span> top = queue-&gt;<span class="hljs-built_in">front</span>();<br>        stack-&gt;<span class="hljs-built_in">push</span>(top);<br>        queue-&gt;<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stack-&gt;<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li><code>push</code>：直接插入到队列尾部，$O(1)$。</li><li><code>pop</code>：需要把数据挪到另一个队列中，为$O(n)$。</li><li><code>top</code>：和<code>pop</code>一样，同样要移动数据，也为$O(n)$。</li><li><code>empty</code>：$O(1)$。</li></ul><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>栈顶元素应在队列头部。</p><p>两个队列，一个是主队列，另一个是辅助队列。当入栈时，执行以下操作：</p><ul><li>将待入栈元素插入到辅助队列中</li><li>将主队列元素依次移除并插入到辅助队列中</li><li>再将辅助队列元素依次移除并插入到主队列中</li></ul><p>入栈操作完成。</p><p>这样就能始终保持队列头部和栈顶元素一致。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月22日20时41分47秒.gif" alt="21年04月22日20时41分47秒" style="zoom:50%;" /></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; main_queue;<br>    queue&lt;<span class="hljs-type">int</span>&gt; queue;<br><br><br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        queue.<span class="hljs-built_in">push</span>(x);<br>        <span class="hljs-keyword">while</span> (!main_queue.<span class="hljs-built_in">empty</span>()) &#123;<br>            queue.<span class="hljs-built_in">push</span>(main_queue.<span class="hljs-built_in">front</span>());<br>            main_queue.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(main_queue, queue);<br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> top = main_queue.<span class="hljs-built_in">front</span>();<br>        main_queue.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> top;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> main_queue.<span class="hljs-built_in">front</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> main_queue.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p><code>push</code>：需要将主队列数据依次插入辅助队列，再重新插入主队列。为$O(n)$。</p><p>其他操作都为$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-重复元素II</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/9-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/9-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210421204213945.png" alt="image-20210421204213945" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用map集合，数组的值作为key，数组索引作为value。</p><p>遍历数组，在map中查找是否有key相等的元素，如果没有，则将当前数组值和索引插入map集合；</p><p>如果有，则用当前索引 - map集合相等的索引，如果小于等于k，则直接返回true；</p><p>如果大于，则将map集合值相等的对应索引改为当前索引。</p><p>注：因为如果当前索引 - map集合中索引已经大于k，那么数组后面的元素一定更大于K，所以应将map集合索引改为当前索引。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月21日21时05分22秒.gif" alt="21年04月21日21时05分22秒" style="zoom:67%;" /></p><p>注：动画有个错误，第一个索引差 应该是 3 - 0 &gt; k = 2。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; numbers;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(numbers.<span class="hljs-built_in">count</span>(nums[i]) == <span class="hljs-number">0</span>) &#123;<br>                numbers.<span class="hljs-built_in">insert</span>(&#123;nums[i], i&#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span>(i - numbers.<span class="hljs-built_in">at</span>(nums[i]) &lt;= k) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;  <span class="hljs-keyword">else</span> &#123;<br>                    numbers.<span class="hljs-built_in">at</span>(nums[i]) = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历数组，$O(n)$。</p><p>空间复杂度：$O(n)$。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>使用哈希表来存储数组值，遍历数组，查找哈希表是否存在相等的元素，如果没有，则存入当前元素，并判断哈希表长度是否大于k，如果大于，则删除最旧的元素(即最先加入来的元素)；</p><p>如果存在相等元素，返回true。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br><br>        set&lt;<span class="hljs-type">int</span>&gt; number;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(number.<span class="hljs-built_in">count</span>(nums[i]) == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            number.<span class="hljs-built_in">insert</span>(nums[i]);<br>            <span class="hljs-keyword">if</span>(number.<span class="hljs-built_in">size</span>() &gt; k) &#123;<br>                number.<span class="hljs-built_in">erase</span>(nums[i - k]);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-重复元素</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/8-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/8-%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210421201032222.png" alt="image-20210421201032222" style="zoom:50%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用哈希表，遍历数组，先查看哈希表是否有相同元素，如果有，则停止遍历，返回true；直到遍历结束，返回false。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        set&lt;<span class="hljs-type">int</span>&gt; numbers;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(numbers.<span class="hljs-built_in">count</span>(nums[i]) == <span class="hljs-number">0</span>) &#123;<br>                numbers.<span class="hljs-built_in">insert</span>(nums[i]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历数组，$O(n)$。</p><p>空间复杂度：使用了哈希表，$O(n)$。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>把数组排序，然后依次比较相邻元素。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">containsDuplicate</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[i + <span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：就是排序时间复杂度：$O(n*logn)$。</p><p>空间复杂度：自己实现排序算法，空间复杂度为$O(1)$，使用默认排序算法，为$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-反转链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/7-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/7-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210420195746281.png" alt="image-20210420195746281" style="zoom:67%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用三个指针<code>cur</code>、<code>pre</code>和<code>next</code>，遍历链表。<code>cur</code>代表当前指向的结点，<code>pre</code>代表当前<code>cur</code>的前一个结点，<code>next</code>代表<code>cur</code>的后一个结点。</p><p>初始时，<code>cur</code>指向<code>head-&gt;next</code>即链表第二个结点，<code>pre</code>指向<code>head</code>，即头结点。<code>next</code>为空指针。</p><p>然后依次执行以下步骤：</p><ul><li><p><code>next</code>结点指向<code>cur</code>的下一个节点</p></li><li><p><code>cur</code>结点的<code>next</code>指向<code>pre</code>结点</p></li><li><code>pre</code>结点指向<code>cur</code>结点</li><li><code>cur</code>指向<code>next</code>节点</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月20日20时23分50秒.gif" alt="21年04月20日20时23分50秒" style="zoom:50%;" /></p><p>这样就将<code>pre</code>和<code>cur</code>指向的结点进行了反转，并指向了下一个要反转的结点。</p><p>直到<code>cur</code>指向了空，此时循环结束，链表反转完成。</p><p><strong>注：</strong></p><ul><li><p><strong>要注意，当反转链表第一个结点和第二个结点时，第一个结点的next应置为空</strong></p></li><li><p><strong>初始时，<code>cur</code>指向了链表第二个结点，说明这种方法只适用于链表结点数大于等于2的情况，所以需要先加一个判断，保证链表结点数大于等于2。</strong></p></li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>() : <span class="hljs-built_in">val</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x, ListNode *next) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(next) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br><br>        ListNode * pre = head;<br>        ListNode * cur = head-&gt;next;<br>        ListNode * next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(pre == head) &#123;<br>                pre-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> pre;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>还有一种更简单的写法，省去了判断链表结点数是否大于等于2和<code>pre == head</code>的情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode * pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode * cur = head;<br>        ListNode * next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(pre == head) &#123;<br>                pre-&gt;next = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>            next = cur-&gt;next;<br>            cur-&gt;next = pre;<br>            pre = cur;<br>            cur = next;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> pre;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度为$O(n)$。</p><p>空间复杂度：用了三个指针，$O(1)$。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>从链表头结点递归到最后一个结点，然后进行回溯，当<code>head</code>指向一个结点时，要让它的下一个结点指向它，则需要执行<code>head-&gt;next-&gt;next = head</code>， 并让<code>head</code>结点的<code>next</code>指向空。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/21年04月20日21时03分26秒.gif" alt="21年04月20日21时03分26秒" style="zoom:50%;" /></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<span class="hljs-keyword">return</span> head;&#125;<br><br>        ListNode * newHead = <span class="hljs-built_in">reverseList</span>(head-&gt;next);<br>        head-&gt;next-&gt;next = head;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span> newHead;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>时间复杂度：$O(n)$。</p><p>空间复杂度：每次递归都需要将当前变量压栈，为$O(n)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-移除链表元素</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/6-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/6-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210417202241271.png" alt="image-20210417202241271" style="zoom:67%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>这题很简单，考的就是链表的基本操作。</p><p>设置两个指针：<code>current</code>和<code>pre</code>，分别代表当前节点和当前节点的前一个节点。初始时，<code>current = head</code>, <code>pre = nullptr</code>。</p><p>当<code>current</code>节点和val相等时，则<code>pre</code>节点指向<code>current-&gt;next</code>，即为删除了<code>current</code>。然后<code>current</code>指向<code>pre-&gt;next</code>，继续遍历。</p><p>但是需要考虑一种特殊情况，即头结点等于val，此时，令<code>head = head-&gt;next</code>，<code>current = head</code>。继续循环。</p><p>遍历结束，返回<code>head</code>。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br><br>        ListNode *pre = <span class="hljs-literal">nullptr</span>, *current = head;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == val) &#123;<br>                <span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">nullptr</span>) &#123;<br>                    head = head-&gt;next;<br>                    current = head;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    pre-&gt;next = current-&gt;next;<br>                    current = pre-&gt;next;<br>                &#125;<br><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = current;<br>                current = current-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> head;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历链表，为$O(n)$。</p><p>空间复杂度：使用两个指针，为$O(1)$。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><h3 id="哨兵结点"><a href="#哨兵结点" class="headerlink" title="哨兵结点"></a>哨兵结点</h3><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>这道题目，唯一可能稍微难一点的就是边界问题。</p><p>如果链表中间节点和给定val相等，问题很简单，令 该节点前一个节点的<code>next</code>等于该节点的<code>next</code>即可。</p><p>唯一麻烦的就是，如果开头一个或多个结点和val相等，则会稍复杂些。</p><p>可以使用哨兵节点来解决。</p><p>即： 创建一个哨兵节点<code>sentinel</code>作为头结点，并令<code>sentinel-&gt;next = head</code>。然后即可简化我自己的做法。不需要考虑头结点相等的特殊情况。</p><p>只要注意：返回值是<code>sentinel-&gt;next</code>。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br><br>        ListNode *sentinel = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>        sentinel-&gt;next = head;<br><br>        ListNode *pre = sentinel, *current = sentinel-&gt;next;<br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span> (current-&gt;val == val) &#123;<br>                    pre-&gt;next = current-&gt;next;<br>                    current = pre-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                pre = current;<br>                current = current-&gt;next;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sentinel-&gt;next;<br><br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：$O(n)$。</p><p>空间复杂度：$O(1)$。</p><p>不解释。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-多数元素</title>
    <link href="/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/5-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/"/>
    <url>/2022/05/11/leetcode/%E6%95%B0%E7%BB%84/5-%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210416205312401.png" alt="image-20210416205312401" style="zoom:67%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用map集合，key是数组元素，value是出现的次数。遍历整个数组，对于数组每个元素，查询map集合，如果存在，则将value + 1，如果不存在，则添加进map集合，并设value是1。</p><p>然后    遍历map集合，将value的值和数组一半元素一次比较，如果符合条件，则结束循环并输出。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; count;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator temp;<br>            <span class="hljs-keyword">if</span>((temp = count.<span class="hljs-built_in">find</span>(nums[i])) != count.<span class="hljs-built_in">end</span>()) &#123;<br>                temp-&gt;second++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count.<span class="hljs-built_in">insert</span>(&#123;nums[i], <span class="hljs-number">1</span>&#125;);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果数组元素个数为偶数，则直接除2，奇数则+1除2</span><br>        <span class="hljs-type">int</span> half = nums.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? (<span class="hljs-type">int</span>)nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span> : (<span class="hljs-type">int</span>)(nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::iterator i = count.<span class="hljs-built_in">begin</span>(); i != count.<span class="hljs-built_in">end</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(i-&gt;second &gt;= half) &#123;<br>                result = i-&gt;first;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历整个数组，所以是$O(n)$，n是数组元素个数。</p><p>空间复杂度：需要有一个map集合来存储元素，所以是$O(n)$。</p><h2 id="官方做法"><a href="#官方做法" class="headerlink" title="官方做法"></a>官方做法</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>和我思路差不多，都使用哈希表来维护一个元素和出现次数关系的集合。在此基础上，这种做法在遍历数组时维护了一个最大值，所以在遍历完后，不需要遍历哈希表来查找多数元素。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; counts;<br>        <span class="hljs-type">int</span> majority = <span class="hljs-number">0</span>, cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num: nums) &#123;<br>            ++counts[num];<br>            <span class="hljs-keyword">if</span> (counts[num] &gt; cnt) &#123;<br>                majority = num;<br>                cnt = counts[num];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> majority;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><p>同上。</p><p>时间复杂度$O(n)$，空间复杂度$O(n)$。</p><h3 id="排序法"><a href="#排序法" class="headerlink" title="排序法"></a>排序法</h3><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><p>首先将给定数组进行排序(从小到大，从大到小都可以)。则数组⌊$\frac{n}{2}$⌋位置一定是多数元素。</p><ul><li>对于数组元素个数为偶数n，则多数元素至少出现n / 2，那么不论该多数元素是最大值还是最小值，排序后，$\frac{n}{2}$位置一定是该元素；则如果该多数元素介于最大值和最小值，则也一定会在n/2位置。</li></ul><p>奇数同理。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> nums[nums.<span class="hljs-built_in">size</span>() / <span class="hljs-number">2</span>];<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：使用排序的默认实现，为$O(n*log{n})$。</p><p>空间复杂度：自己写排序算法，之需要使用$O(1)$空间，使用自带的排序算法，值传递，所以需要使用$O(logn)$的栈空间。</p><h4 id="Boyer-Moore投票算法"><a href="#Boyer-Moore投票算法" class="headerlink" title="Boyer-Moore投票算法"></a>Boyer-Moore投票算法</h4><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>设置一个候选人<code>cand_num</code>，和该候选人出现的次数变量<code>count</code>。</p><p>候选人初始化为<code>nums[0]</code>，<code>count</code>初始化为<code>1</code>。</p><p>然后遍历该数组，遇到和<code>cand_num</code>相同的数，则<code>count</code>加1，否则<code>count</code> - 1。</p><p>然后判断<code>count</code>是否为0，如果为0，则更换候选人为当前数；否则继续循环。</p><p>循环结束，当前<code>cand_num</code>即是多数元素。</p><p>解释：</p><p>因为多数元素的个数 大于 $\frac{n}{2}$，若7个元素，则多数元素个数大于3，若8个元素，则多数元素个数大于4。</p><p>因此多数元素个数 - 其他所有元素个数 一定  大于等于 1。</p><p>相当于每一个多数元素和数组其他元素相抵消，最后至少还剩一个多数元素。</p><h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br><br>        <span class="hljs-type">int</span> cand_num = nums[<span class="hljs-number">0</span>], count = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == cand_num) &#123;<br>                count++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                count--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) &#123;<br>                cand_num = nums[i];<br>                count = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cand_num;<br><br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-3"><a href="#性能分析-3" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度：遍历整个数组，为$O(n)$。</p><p>空间复杂度：只使用了两个变量，为$O(1)$。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>数组</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-相交链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/4-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411160829906.png" alt="image-20210411160829906" style="zoom:67%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411160848638.png" alt="image-20210411160848638" style="zoom:50%;" /></p><h2 id="自己的解法"><a href="#自己的解法" class="headerlink" title="自己的解法"></a>自己的解法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用哈希表，首先遍历链表B，将每个链表地址存入set集合。然后遍历链表A，对于链表A的每个节点，在set集合中查找有没有地址相同的元素，如果有，则该节点就是第一个交点。</p><p>如果遍历到A链表末尾依然没有，那么这两个链表不相交。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA == <span class="hljs-literal">nullptr</span> || headB == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        set&lt;ListNode *&gt; address;<br>        ListNode * b = headB;<br>        <span class="hljs-keyword">while</span> (b != <span class="hljs-literal">nullptr</span>) &#123;<br>            address.<span class="hljs-built_in">insert</span>(b);<br>            b = b-&gt;next;<br>        &#125;<br>        ListNode *a = headA;<br>        <span class="hljs-keyword">while</span> (a != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(address.<span class="hljs-built_in">count</span>(a)) &#123;<br>                <span class="hljs-keyword">return</span> a;<br>            &#125;<br>            a = a-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="更好的解法"><a href="#更好的解法" class="headerlink" title="更好的解法"></a>更好的解法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>双指针法。这种解法非常巧妙。</p><p>我们设链表A的节点数为a，链表B的节点数为b，它们的公共节点数为c。第一个公共节点(就是交点)为node。</p><p>定义两个指针pA和pB分别指向链表A和链表B，同时向后遍历，当pA遍历到A链表末尾，就重定向到链表B头结点；</p><p>同样的，当pB遍历到B链表结尾，就重定向到链表A头结点。</p><p>当指针pA遍历B链表走到node节点时，遍历的节点数是：<code>a + (b - c + 1)</code>，即走了<code>a + b - c</code>步。</p><p>当指针pB遍历A链表走到node节点时，遍历的节点数是：<code>b + (a - c + 1)</code>，即走了<code>b + a - c</code>步。</p><p>注：这里的加1，就是加上第一个公共节点。</p><p>因此指针pA和pB会同时到达公共节点。</p><ul><li>当c = 0时，即A、B链表没有交点，那么pA和pB最终会指向null。</li><li>当c &gt; 0时，pA和pB会同时指向交点。</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411163017410.png" alt="image-20210411163017410" style="zoom:67%;" /></p><p>这种方法就是用了<code>A + B = B + A</code>的思想。虽然各自路程不同，但加起来的路程是相等的。速度一样，最终一定会同时到达。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(headA == <span class="hljs-literal">nullptr</span> || headB == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        ListNode *pA = headA;<br>        ListNode *pB = headB;<br>        <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>            pA = pA!= <span class="hljs-literal">nullptr</span> ? pA-&gt;next : headB;<br>            pB = pB!= <span class="hljs-literal">nullptr</span> ? pB-&gt;next : headA;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pA;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>时间复杂度：最差情况是链表没有交点，此时时间复杂度为$O(a + b)$</li><li>空间复杂度：只用了两个指针，$O(1)$。</li></ul><p>贴一个leetcode解法的评论(哈哈哈哈哈哈哈)：</p><blockquote><p>| 这个算法也太浪漫了吧，错的人迟早会走散，而对的人迟早会相逢。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-最小栈</title>
    <link href="/2022/05/11/leetcode/%E6%A0%88/3-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2022/05/11/leetcode/%E6%A0%88/3-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411135957987.png" alt="image-20210411135957987" style="zoom:67%;" /></p><p>提示：<code>pop</code>、<code>getMin</code>和<code>top</code>操作总是在非空栈进行操作。</p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用链表来存储元素。</p><p>因为要求在常数时间内检索到最小元素的栈，所以肯定不能当调用<code>getMin()</code>时在栈中遍历元素。</p><p>应当是在<code>push</code>和<code>pop</code>操作中就需要找到最小值，当调用<code>getMin()</code>时直接返回。</p><p>因此我的思路是设置一个min指针，一直指向最小值。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> *next;<br>    &#125; node;<br><br>    node *head = <span class="hljs-literal">nullptr</span>;<br>    node *min = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        node * temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">node</span>();<br>        temp-&gt;val = val;<br>        temp-&gt;next = head;<br>        head = temp;<br><br>        <span class="hljs-keyword">if</span>(min == <span class="hljs-literal">nullptr</span>) &#123;<br>            min = temp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            min = min-&gt;val &lt; val ? min : temp;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//如果最小值就是栈顶元素,则需要重新找最小值</span><br>        <span class="hljs-keyword">if</span>(min == head) &#123;<br>            <span class="hljs-comment">//如果栈中只有一个元素或两个元素</span><br>            <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">nullptr</span> || head-&gt;next-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>                min = head-&gt;next;<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则遍历链表，查找最小值</span><br>            min = head-&gt;next;<br>            node *temp = min-&gt;next;<br>            <span class="hljs-keyword">while</span> (temp != <span class="hljs-literal">nullptr</span>) &#123;<br>                    <span class="hljs-keyword">if</span>(min-&gt;val &gt; temp-&gt;val) &#123;<br>                        min = temp;<br>                    &#125;<br>                    temp = temp-&gt;next;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//删除栈顶元素</span><br>        node * top = head;<br>        head = head-&gt;next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> head-&gt;val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min-&gt;val;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>时间复杂度：<code>push</code>、<code>top</code>和<code>getMin</code>都是$O(1)$，<code>pop</code>操作最坏时间复杂度是$O(n)$。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="官方提供的做法"><a href="#官方提供的做法" class="headerlink" title="官方提供的做法"></a>官方提供的做法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用辅助栈，每一个栈顶元素对应一个最小值。即在一个栈存放数据，另一个栈存放和数据栈对应位置的元素对应的最小值。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411151513976.png" alt="image-20210411151513976" style="zoom:50%;" /></p><p>当向数据栈中添加元素时，比较当前辅助栈栈顶元素和插入元素大小，取较小的添加到辅助栈。</p><p>从数据栈中删除栈顶元素时，同时删除辅助栈栈顶元素。</p><h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; data_stack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; min_stack;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        min_stack.<span class="hljs-built_in">push</span>(INT_MAX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>        data_stack.<span class="hljs-built_in">push</span>(val);<br>        min_stack.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(val, min_stack.<span class="hljs-built_in">top</span>()));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        data_stack.<span class="hljs-built_in">pop</span>();<br>        min_stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>时间复杂度：添加、删除、返回栈顶元素和返回最小值都是$O(1)$</li><li>空间复杂度：$O(N)$</li></ul><h3 id="其他做法"><a href="#其他做法" class="headerlink" title="其他做法"></a>其他做法</h3><p>可以使用C++的pair关键词，把要存储的元素和对应的最小值放在一个元组中。这样就只需要使用一个栈。</p><p>也可以不使用提供的stack默认实现，自定义链表实现，在定义节点时，添加min字段，即每一个节点都对应一个数据和最小值。</p><p>思路都大同小异，只不过具体实现不同。</p>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>栈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-环形链表</title>
    <link href="/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/2-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"/>
    <url>/2022/05/11/leetcode/%E9%93%BE%E8%A1%A8/2-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210411123641329.png" alt="image-20210411123641329" style="zoom:67%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用C++的vector数据结构存储已访问过的结点，从链表头节点开始，首先在vector中查找是否已存在该结点，存在表示已经访问过该结点，代表链表有环；不存在则把该结点放入vector中，head指向下一个结点。</p><p>只有两种情况：</p><ul><li>不是环形链表，则链表最后一个结点的next指向NULL</li><li>是环形链表，则一定会出现vector存在当前节点的情况</li></ul><p>以此来设置循环结束的时机。</p><p>即当前结点存在于vector中或当前结点为NULL。</p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        vector&lt;ListNode *&gt; addresses;<br>        ListNode *current = head;<br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span>(current != <span class="hljs-literal">nullptr</span> &amp;&amp; !flag) &#123;<br>            vector&lt;ListNode *&gt;::iterator result;<br>            result = <span class="hljs-built_in">find</span>(addresses.<span class="hljs-built_in">begin</span>(), addresses.<span class="hljs-built_in">end</span>(), current);<br>            <span class="hljs-keyword">if</span>(result != addresses.<span class="hljs-built_in">end</span>()) &#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                breaks;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                addresses.<span class="hljs-built_in">push_back</span>(current);<br>                current = current-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>需要遍历整个链表，所以时间复杂度为$O({n})$，空间复杂度也为$O(n)$。</p><h2 id="更好的做法"><a href="#更好的做法" class="headerlink" title="更好的做法"></a>更好的做法</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><p>和我自己的做法意思不大差，但是官方提供的代码使用的数据结构更好，代码更简洁。</p><p>即：</p><p>遍历所有节点，每次遍历到一个节点，判断该结点是否被访问过。</p><p>使用哈希表来存储所有已经访问过的节点。</p><p>使用set集合。</p><p>即Java中set类，或C++中unordered_set类。</p><h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br><br>        unordered_set&lt;ListNode *&gt; seen;<br>        <br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">if</span>(seen.<span class="hljs-built_in">count</span>(head)) &#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                seen.<span class="hljs-built_in">insert</span>(head);<br>                head = head-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> flag;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>同样，时间复杂度为$O({n})$，空间复杂度也为$O(n)$。</p><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><p>该方法需要对Floyd判圈算法(又称龟兔赛跑算法)有所了解。</p><p><strong>假想 乌龟 和 兔子 在链表上移动，兔子跑得快，乌龟跑得慢。那么当乌龟和兔子在链表上同一个节点开始移动时，如果链表没有环，那么兔子将一直在乌龟前方，直到乌龟到达最后一个节点；如果链表有环，那么兔子会先于乌龟进入环，并一直在环内移动。等到乌龟进入环后，由于兔子的速度快，他一定(注意，是一定会相遇)会在某个时刻和乌龟相遇。</strong></p><p>可以根据上述思路来解决该题。定义两个指针，一快一慢。慢指针每次只移动一步，快指针每次移动两步。初始状态，慢指针在位置<code>head</code>，快指针在位置<code>head-&gt;next</code>，这样当快指针在某一时刻追上慢指针，就说明链表为环形指针；<strong>当快指针为null或快指针的<code>next</code>为null</strong>，就说明链表不为环形链表。</p><p>注：</p><ul><li>为什么要判断快指针和快指针的next：因为快指针每次走两步，所以如果链表节点个数为奇数个，那么快指针走n次，会正好走到最后一个节点的后面，即null；当链表节点个数为偶数个，那么走n次，快指针正好指向最后一个节点。因此两个情况有任意一种情况出现，即出现null，则代表不是环形链表。</li><li>为什么初始状态慢指针在<code>head</code>位置，快指针在<code>head-&gt;next</code>位置：这是因为使用<code>while</code>循环，判断循环结束条件为<code>slow != fast</code>，即快指针和慢指针不相等，若快慢指针初始都在<code>head</code>位置，那就不会进入循环。当然也可以使用do while循环。那样，快慢指针都可以放在<code>head</code>位置。</li><li>其实快指针也可以一次走多步，3步，4步。都行， 但是这样会增加算法复杂度。</li></ul><h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        ListNode * slow = head;<br>        ListNode * fast = head-&gt;next;<br><br>        <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span> || fast-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="性能分析-2"><a href="#性能分析-2" class="headerlink" title="性能分析"></a>性能分析</h4><ul><li><p>时间复杂度：$O(n)$，其中n是链表节点数。</p></li><li><p>空间复杂度：$O(1)$，只使用了两个指针额外空间。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>链表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-无重复字符的最长子串</title>
    <link href="/2022/05/11/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/1-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <url>/2022/05/11/leetcode/%E5%93%88%E5%B8%8C%E8%A1%A8/1-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210328100444352.png" alt="image-20210328100444352" style="zoom:67%;" /></p><h2 id="自己的做法"><a href="#自己的做法" class="headerlink" title="自己的做法"></a>自己的做法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>没有什么好的想法。最简单最容易实现的就是暴力求解。</p><p>分别从每个字符开始，依次查看该字符之后的字符是否和之前的重复，如果不重复，那么就存入到字符数组中，和之后的字符去比较；如果重复，那就计算出该子串长度，和最长子串长度 变量比较，取较大的一个。直到最后一个字符，</p><h3 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h3><p>使用双指针，p1和p2。最开始同时同时指向字符串，缓存字符数组temp，和数组长度temp_length；先去查看数组中是否有和<em>p2相等的，如果有，那就算出此段长度，否则将\</em>p2指向的字符存入缓存数组， p2向前移动。</p><h3 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(<span class="hljs-type">char</span> * s)</span>&#123;<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">NULL</span> || *s == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<br><br>    <span class="hljs-type">char</span> *p1 = s;<br>    <span class="hljs-type">char</span> *p2 = s;<br>    <span class="hljs-type">int</span> length = (<span class="hljs-type">int</span>) <span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-comment">//最大子串长度初始设为0</span><br>    <span class="hljs-type">int</span> maxLength = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 缓存数组，存入子串字符</span><br>    <span class="hljs-type">char</span> temp[length];<br>    <span class="hljs-comment">// 数组长度</span><br>    <span class="hljs-type">int</span> temp_length = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 当p1指向&#x27;\0&#x27;就结束循环</span><br>    <span class="hljs-keyword">while</span> (*p1 != <span class="hljs-string">&#x27;\0&#x27;</span>)&#123;<br>        <br>        <span class="hljs-comment">// 标志变量，temp数组是否存在p2指向的字符</span><br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; temp_length; j++) &#123;<br>            <span class="hljs-comment">//遍历整个temp数组，如果有和*p2相等的，那么设flag为1</span><br>            <span class="hljs-keyword">if</span>(*p2 == temp[j]) &#123;<br>                flag = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//如果flag = 1，或者*p2指向了字符串结尾，就将缓存数组长度和最大子串长度比较</span><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-number">1</span> || *p2 == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>            maxLength = maxLength &lt; temp_length ? temp_length : maxLength;<br>            p1++;<br>            p2 = p1;<br>            <span class="hljs-comment">//将数组长度置为0，即清空数组</span><br>            temp_length = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果flag = 0，那么就将p2指向的字符串存入缓存，p2指向下一个字符</span><br>            temp[temp_length++] = *p2;<br>            p2++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxLength;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度是$O(n^2)$，空间复杂度是$O({n})$。</p><h2 id="更好的解法"><a href="#更好的解法" class="headerlink" title="更好的解法"></a>更好的解法</h2><p>涉及到子串问题的，滑动窗口使用的比较多。</p><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>当递增地枚举子串起始位置，那么子串结束位置也是递增的。</p><p>如果第k个字符是起始位置，第k + h 个字符是结束位置，那么当选择第k + 1个字符作为起始位置时，显然从k + 1到k + h的字符是不重复的，然后可以从 k + h开始继续向右比较，直到出现了重复字符。</p><h3 id="具体做法-1"><a href="#具体做法-1" class="headerlink" title="具体做法"></a>具体做法</h3><ul><li>使用双指针，并使用一个集合来存入当前滑动窗口内的字符。</li><li>在循环体内，先判断集合中是否存在右指针的下一个位置(即*(p + 1) )指向的字符，如果存在；那就结束循环，并计算此时子串长度；如果不存在，则右指针向右滑动一个位置，继续该操作</li><li>在上一步结束循环后，左指针应向右移动一个位置，同时从集合中删除左指针先前指向的字符，继续循环</li><li>直到遍历完整个字符串，循环结束</li></ul><h3 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        unordered_set&lt;<span class="hljs-type">char</span>&gt; chars;<br>        <span class="hljs-type">int</span> size = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> right = <span class="hljs-number">-1</span>, max_length = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) &#123;<br>                chars.<span class="hljs-built_in">erase</span>(s[i - <span class="hljs-number">1</span>]);<br>            &#125;<br>            <span class="hljs-keyword">while</span> (right &lt; size - <span class="hljs-number">1</span> &amp;&amp; !chars.<span class="hljs-built_in">count</span>(s[right + <span class="hljs-number">1</span>])) &#123;<br>                chars.<span class="hljs-built_in">insert</span>(s[right + <span class="hljs-number">1</span>]);<br>                right++;<br>            &#125;<br>            max_length = <span class="hljs-built_in">max</span>(max_length, right - i + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> max_length;<br><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h3><ul><li>时间复杂度：$O(N)$，N为字符串长度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
      <category>哈希表</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-Java中使用Redis</title>
    <link href="/2022/05/11/Redis/6-Java%E4%B8%AD%E4%BD%BF%E7%94%A8Redis/"/>
    <url>/2022/05/11/Redis/6-Java%E4%B8%AD%E4%BD%BF%E7%94%A8Redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中使用Redis。可以使用Redis官方提供的Jedis。和Apache提供的common-pool2。</p><p>因为Jedis对象不是线程安全的。所以使用common-pool，对象池来管理Jedis对象。</p><p>分别对应两个jar包。</p><p>maven坐标为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>Jedis的常用的方法名和参数名，基本都和Redis的命令和参数一样。</p><p>只演示一下Jedis对象创建、Jedis连接池和事务</p><h3 id="创建Jedis对象"><a href="#创建Jedis对象" class="headerlink" title="创建Jedis对象"></a>创建Jedis对象</h3><p>Jedis类有多个重载构造器</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102181753031.png" alt="image-20210102181753031" style="zoom: 50%;" /></p><p>常用的是<code>Jedis(String host int port)</code>，参数分别为主机号和端口号。</p><h3 id="Jedis连接池"><a href="#Jedis连接池" class="headerlink" title="Jedis连接池"></a>Jedis连接池</h3><p>创建一个工具类JedisPool，在类中有两个静态方法open、close和一个静态变量JedisPool。</p><p>open用来从连接池中获取一个Jedis对象，close负责关闭该链接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisUtils</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">JedisPool</span> <span class="hljs-variable">jedisPool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> JedisPool <span class="hljs-title function_">open</span><span class="hljs-params">(String host, <span class="hljs-type">int</span> port)</span> &#123;<br>        <span class="hljs-keyword">if</span>(jedisPool == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//创建Jedis连接池配置对象</span><br>            <span class="hljs-type">JedisPoolConfig</span> <span class="hljs-variable">jedisPoolConfig</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPoolConfig</span>();<br>            <span class="hljs-comment">//设置最大线程数，一个线程就是一个Jedis实例。默认为8</span><br>            jedisPoolConfig.setMaxTotal(<span class="hljs-number">10</span>);<br>            <span class="hljs-comment">//设置最大空闲实例数，设置这个可以保留足够连接，快速获取到Jedis对象</span><br>            jedisPoolConfig.setMaxIdle(<span class="hljs-number">2</span>);<br><span class="hljs-comment">//设置检查项为true，表示从线程池中获取到的Jedis对象一定是可用的</span><br>            jedisPoolConfig.setTestOnBorrow(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">//创建Jedis连接池。参数分别为配置，主机地址和端口。(还可以加上超时连接时间，访问密码)</span><br>            jedisPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisPool</span>(jedisPoolConfig, host, port);<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> jedisPool;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(jedisPool != <span class="hljs-literal">null</span>) &#123;<br>            jedisPool.close();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后使Jedis的<code>PoolgetResource()</code>方法来获取Jedis对象，并用try/catch语句块。在finally中关闭jedis对象。等于是将对象放回实例池中，并不是销毁该对象。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>Jedis中有事务Transcation类。</p><p>使用<code>Jedis.multi()</code>返回一个事务对象，通过该对象添加操作命令。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102182350395.png" alt="image-20210102182350395" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>Redis</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-Redis高级话题</title>
    <link href="/2022/05/11/Redis/5-Redis%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/"/>
    <url>/2022/05/11/Redis/5-Redis%E9%AB%98%E7%BA%A7%E8%AF%9D%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>事务是指一系列操作步骤，这些操作步骤，要么全都执行，要么全都不执行。</p><p>Redis中的事务是一组命令的集合，至少有两个命令。redis事务保证这些命令被执行时中间不会中断。</p><p>Redis事务相关的命令：</p><ol><li>multi：标记一个事务的开始。事务内的多条命令不会立即执行，而是会按照先后顺序放入一个队列中。总是返回OK</li><li>exec：执行所有事务块的内容。可以理解为提交事务。事务被打断返回nil，否则返回OK</li><li>discard：取消事务，放弃执行事务块中的所有命令。总是返回OK</li><li>watch：语法是：watch key [key..]，监视一个或多个key，如果在事务执行之前这些key被其他命令改动，那么事务被打断。总是返回OK。</li><li>unwatch：取消watch命令对所有key的监视，如果在执行了watch命令后，exec命令或discard命令先被执行了话，就不需要执行unwatch了。总是返回OK</li></ol><p>举几个例子：</p><h3 id="事务正常执行"><a href="#事务正常执行" class="headerlink" title="事务正常执行"></a>事务正常执行</h3><p>首先使用multi来标志事务开始，即告诉redis要开启一个事务，接下来输入的命令不要执行，先放到一个队列中。</p><p>然后使用exec来提交事务。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102123859889.png" alt="image-20210102123859889" style="zoom:67%;" /></p><h3 id="事务被放弃"><a href="#事务被放弃" class="headerlink" title="事务被放弃"></a>事务被放弃</h3><p>如果出现了命令的语法错误或者其他严重错误，导致服务器不能正常工作(例如内存不足)，那么Redis会检测到，并放弃事务。</p><p>一般都是语法出现错误，其他错误不常见。</p><p>例如使用incr给key对应的value值加1，incr只有一个参数，如果有多个参数，就会有语法错误。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102124525031.png" alt="image-20210102124525031" style="zoom:67%;" /></p><p>可以看到，因为之前出现的语法错误，事务已经被放弃。</p><h3 id="执行出错，不会放弃事务"><a href="#执行出错，不会放弃事务" class="headerlink" title="执行出错，不会放弃事务"></a>执行出错，不会放弃事务</h3><p>还有一种错误，只有在执行时才能发现，例如使用集合命令去操作字符串，incr命令操作不是数值的value等等。</p><p>这一类错误，Redis事务在执行到的时候，会报错，但是不会放弃事务。依然会执行其他事务。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102125059072.png" alt="image-20210102125059072" style="zoom:67%;" /></p><p>Redis在遇到这类错误，不会回滚事务，依然正常执行。这样可以保持Redis的高性能。</p><h3 id="主动放弃事务"><a href="#主动放弃事务" class="headerlink" title="主动放弃事务"></a>主动放弃事务</h3><p>在开启事务后，如果想放弃执行命令，可以使用discard命令放弃事务。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102125432602.png" alt="image-20210102125432602" style="zoom:50%;" /></p><h3 id="Redis的watch机制"><a href="#Redis的watch机制" class="headerlink" title="Redis的watch机制"></a>Redis的watch机制</h3><p>watch机制原理：</p><p>​        使用watch机制监视一个或多个key，如果有key的value值在事务提交之前被修改了，那么整个事务会被取消。执行exec时，会返回提示信息，表示事务已经失败。</p><p>​        watch机制，使的事务exec变的有条件，事务只有在watch监视的key对应value没有修改的情况下才会执行。如果使用watch监视了一个带过期时间的键，那么即时这个键过期了，事务仍然可以正常执行。</p><p>​            大多数情况下，不同客户端访问不同的键，相互同时竞争同一key的情况很少。</p><p>那么何时取消key的监视：</p><ol><li>watch命令可以调用多次，对键的监视从watch执行后开始生效，一致到调用exec为止，不管事务是否成功执行，对所有键的监视都会被先取消</li><li>当客户端断开连接时，该客户端对键的监视也会被取消</li><li>unwatch命令可以手动取消对所有键的监视</li></ol><p>一个例子：</p><p>开启两个客户端，在A客户端开启事务，修改str1的值，并监视str1的值，然后在exec执行之前，在B客户端修改str1的值，会看到在A客户端执行提交事务exec后，返回错误信息。</p><p>A客户端：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102130604633.png" alt="image-20210102130604633" style="zoom:50%;" /></p><p>B客户端：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102130637145.png" alt="image-20210102130637145" style="zoom:50%;" /></p><p>A客户端执行exec后：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102130656183.png" alt="image-20210102130656183" style="zoom:50%;" /></p><p>返回nil，说明没有成功执行。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化可以理解为存储数据，到一个不会丢失的地方。因为如果把数据放在内存中，电脑关闭或者重启就会丢失数据。所以放在内存中的数据不是持久化的，放在磁盘就算是持久化。</p><p>Redis提供了两种机制来对数据进行持久化存储。</p><h3 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h3><p>Redis DataBase(RDB)，就是在指定的时间间隔内将内存中的数据集快照(可以理解为数据的情况)写入磁盘，数据恢复时，将快照文件读入内存即可。</p><p>RDB保存了在某个时间点的数据集，就是当前时间点的全部数据。存储在一个二进制文件中，默认是dump.rdb。</p><p>RDB适合做备份，可以保存最近一个小时，一天的全部数据。保存数据是在单独进程写文件，不影响Redis正常使用，并且RDB恢复数据时，比AOF快。</p><h4 id="实现RDB"><a href="#实现RDB" class="headerlink" title="实现RDB"></a>实现RDB</h4><p>使用RDB实现数据持久化，只需要在Redis的配置文件中配置即可。默认配置时启动的。</p><p>在配置文件中搜索SNAPSHOTTING。</p><p>有三处需要配置：</p><ol><li><p>配置执行RDB生成快照的时间策略。</p><p> 配置格式：save seconds changes</p><p> 意思是，当在seconds秒内，至少有changs个key改动后，那么就保存一次数据集。</p><p> 例子：save 20 4</p><p> 意思是，当在二十秒内，有4个及以上的key被改动后，就保存数据集</p></li><li><p>dbfilename：设置RDB的文件名，默认dump.rdb</p></li><li><p>dir：指定RDB文件存储位置，默认是<code>./</code>当前目录。就是启动redis的工作目录。如果删除dump.rdb文件，然后在windows下的C:/user/username下重新启动redis-server，那么dump文件就会保存到C:/user/username下。</p></li></ol><p>一个例子：<br>修改配置文件</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102132454044.png" alt="image-20210102132454044" style="zoom:50%;" /></p><p>加上一个<code>save 20 4</code>，如果取消<code>save &quot;&quot;</code>的注释，代表不启用RDB。</p><p>其他不修改。</p><p>重新开启redis服务端，重新读取配置文件</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>RDB优点：存储的是数据快照文件，恢复数据方便。</p><p>缺点：</p><ul><li>会丢失最后一次快照以后更改的数据。如果不能容忍一定数据丢失，使用RDB不是很好</li><li>由于需要经常操作磁盘，RDB会分出一个子进程，如果redis数据库很大，子进程会占用较多时间。</li></ul><h3 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h3><p>Append-only File(AOF)，当Redis每收到一条改变数据的命令时，就把该命令追加写入到AOF文件中(只记录写操作，例如添加key，修改key对应value值，不记录读操作)，当Redis重启时，就读取AOF文件，把存储的所有命令重新执行一遍，来恢复数据。</p><h4 id="实现AOF"><a href="#实现AOF" class="headerlink" title="实现AOF"></a>实现AOF</h4><p>要在配置文件中配置对应项：</p><ol><li>appendonly：意思是是否开启AOF持久化，默认是no，改为yes即开启</li><li>appendfilename：指定AOF文件名，默认是appendonly,aof</li><li>dir:指定AOF存放的目录默认是<code>./</code></li><li>appendfsync：配置向AOF文件写命令数据时的策略，有以下可取值：<ul><li>no：不主动进行同步操作，完全交给操作系统来做(每30秒一次)，比较快但是不很安全</li><li>always：每次执行写入都会执行同步，慢一些，但是较为安全</li><li>everysec：每秒执行一次同步操作，比较平衡。<strong>默认项。</strong></li></ul></li><li>auto-apf-rewrite-min-size：允许重写的最小AOF文件大小，默认64M，当AOF文件大小64M时，开始整理AOF文件，去掉无用的操作命令，减小aof文件大小。</li></ol><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>AOF文件在操作过程中会变得越来越大，例如，输入一百次加法计算，最后数据库内存中只会存储最后的结果，但是AOF文件会存储100条记录，99条都对最终记录没用。但是Redis支持在不影响服务前提下，在后台重构AOF文件，让文件变小。</p><p>可以同时使用RDB和AOF两种方式，Redis默认优先加载AOF文件，因为aof数据最完整。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>通过持久化功能，Redis保证了即使服务器重启的情况下也不会丢失数据。但是数据只存储在一台服务器，如果这台服务器出现故障，那么数据同样会丢失。</p><p>为了避免单点故障，需要将数据赋值多份部署到不同的服务器上，即使一台服务器出现故障其他服务器依然可以继续提供服务。</p><p>这就要求当一台服务器上的数据更新后，自动将更新的数据同步到其他服务器上，通过Redis的主从复制来实现。</p><p>Redis提供了复制功能来自动实现多台redis服务器的数据同步，我们不需要关心如何复制，Redis会自动完成。</p><p>只要关心哪些服务器是从服务器，哪个是主服务器。</p><p>需要在配置文件中来指定多台服务器的主从关系。</p><p><strong>主服务器负责写入数据，同时将写入的数据实时同步给从服务器。</strong>主服务器可以读取、写入数据。</p><p><strong>从服务器只能读取数据，不能写入数据。</strong></p><p>这种模式叫做主从复制，master/slave，主服务器是master，从服务器是slave。</p><p>默认master用于写数据，slave用于读数据。在slave中写入数据会出现错误。</p><p>Redis主从复制有两种实现方法：</p><ul><li>修改配置文件，在启动时，服务器读取配置文件，并自动成为指定服务器的从服务器，构成主从复制关系</li><li>在启动redis服务时指定当前服务 成为某个主Redis服务器的从服务器。</li></ul><p>一般常用第一种方式，即修改配置文件。</p><p>主服务器不需要修改，在从服务器中加上slaveof，格式为</p><p><code>slaveof ip port</code></p><p>ip代表主服务器的ip地址，port是redis进程的端口号。</p><p>可以使用<code>info replication</code>来查看redis服务器所处角色，服务器间关系。</p><p>不配置文件的话启动默认都是master。</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>在同一电脑模拟三个服务端。其中一个是主服务器，另外两个是从服务器。</p><ol><li><p>复制三份redis配置文件，名称分别为redis6380.conf，redis6381.conf，redis6382.conf，分别代表三个服务端。</p></li><li><p>修改端口号port，分别为6380 6381 6382，其中6380为主服务器端口号。</p></li><li><p>再分别修改这三个配置文件的日志文件路径logfile，RDB文件名称dbfilename</p><p> ​    如果是linux系统，还需要指定pidfile，表示当前程序的pid文件路径。</p><p> ​    如果是linux系统，可以加上<code>daemonize yes</code>，表示后台启动。</p></li><li><p>在两个从服务器的配置文件中加入<code>slaveof 127.0.0.1 6380</code>，表示这两个服务器是ip为127.0.0.1、端口号为6380Redis服务器的从服务器。</p></li><li><p>启动三个服务器。</p></li></ol><p>注意：因为是在一台电脑模拟三台服务器，所以需要修改logfile、dbfilename这些配置。</p><p>​            在实际中，只需要加上slaveof即可。</p><p>结果：</p><p>运行主服务器：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102152651212.png" alt="image-20210102152651212" style="zoom:47%;" /></p><p>运行两台从服务器：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102152718666.png" alt="image-20210102152718666" style="zoom: 33%;" /><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102152738810.png" alt="image-20210102152738810"></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102152738810.png" alt="image-20210102152738810"></p><p>使用redis-cli.exe分别连接到三台服务器。</p><p>使用<code>info replication</code>查看服务器关系。</p><p>查看主服务器：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102152910164.png" alt="image-20210102152910164" style="zoom:50%;" /></p><p>可以看到，角色role是master，即主服务器。连接了两台从服务器，并给出了两台从服务器的ip，port和运行状态state</p><p>查看一台从服务器：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102153042651.png" alt="image-20210102153042651" style="zoom:50%;" /></p><p>可以看到，角色role是slave，即从服务器。</p><p>并给出了它的主服务器的ip，port和运行状态master-link-status：up。代表主服务器在运行，连接成功。</p><p>这时，主从服务器中数据都为空。</p><p>从服务器中不能写入数据：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102153239758.png" alt="image-20210102153239758" style="zoom:50%;" /></p><p>在主服务器中写入两个key：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102153328171.png" alt="image-20210102153328171" style="zoom:50%;" /></p><p>然后在从服务器中查看是否已经同步了主服务器的内容。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102153411104.png" alt="image-20210102153411104" style="zoom:50%;" /></p><p>可以看到，已经同步成功。</p><h3 id="容灾处理"><a href="#容灾处理" class="headerlink" title="容灾处理"></a>容灾处理</h3><p>当主服务器出现故障，不能使用后。需要手动将一台从服务器转为主服务器，即从slave提升为master，然后将其他slave重新挂到新的主服务器上。</p><p>在客户端执行命令。</p><p>使用的命令有：</p><ul><li>slaveof no one：将对应服务器提升为master。(即我不是任何服务器的从服务器)</li><li>slaveof ip port：在其他从服务器上使用，意思是改变该服务器对应的主服务器。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例如例子中的6380出现故障。</p><p>需要将6381提升为主服务器，然后6382改变为6381对应服务器的从服务器。</p><p>首先停掉6380</p><p>然后在6381对应客户端执行命令：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102154244425.png" alt="image-20210102154244425" style="zoom:67%;" /></p><p>使用<code>info replication</code>查看服务器连接信息：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102154318331.png" alt="image-20210102154318331" style="zoom:50%;" /></p><p>可以看到，已经提升为master，但是它还没有从服务器。</p><p>在6382对应客户端，执行改变主服务器命令：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102154427752.png" alt="image-20210102154427752" style="zoom:50%;" /></p><p>再次查看6381服务器信息：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102154457580.png" alt="image-20210102154457580" style="zoom:50%;" /></p><p>可以看到，已经有了从服务器。</p><p>如果出现故障的服务器修好了，需要再次把它加入到服务器集群中。</p><p>就应该启动它，然后把它作为现在主服务器的从服务器来使用。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li>一个master可以有多个slave</li><li>slave出故障，那么读请求的处理性能下降</li><li>master出故障，那么写请求无法执行。</li><li>当主服务器出现故障，需要手动指定其中一台slave使用<code>slaveof no one</code>命令提升为主服务器，其他slave执行slaveof命令指向新的主服务器。</li><li>主从复制模式出现故障需要手动处理，如果要实现自动化处理，就要使用Sentinel哨兵，实现故障自动转移。</li></ul><h2 id="Sentinel哨兵"><a href="#Sentinel哨兵" class="headerlink" title="Sentinel哨兵"></a>Sentinel哨兵</h2><p>Sentinel哨兵是redis官方提供的高可用的方案。用它来监控多个Redis服务实例的运行情况。Sentinel是一个运行在特殊模式下的Redis服务器，Sentinel哨兵是在多个Sentinel进程下互相协作的。</p><p>Sentinel系统有三个主要任务：</p><ul><li>监控：Sentinel不断检查主服务器和从服务器是否按照预期正常工作。</li><li>提醒：被监控的Redis出现问题，Sentinel会通知管理员或其他应用程序</li><li>自动故障转移：当监控的主服务器不能正常工作，Sentinel会开始进行故障转移操作。将一个从服务器升级为主服务器，并让其他从服务器挂到新的主服务器上，并且为客户端提供新的主服务器地址。</li></ul><p>每个Sentinel进程，应该独立运行在一台服务器上，多个Sentinel进程之间进行通讯，主要交换监控信息。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102160409308.png" alt="image-20210102160409308" style="zoom:50%;" /></p><p>每个Sentinel都监控主服务器，通过主服务器可以监控到从服务器。</p><p><strong>注意：至少要运行三个Sentinel进程，也就是至少有三台服务器运行Sentinel。并且运行的Sentinel服务器个数只能为奇数。</strong></p><p><strong>这是由Sentinel判断主服务器是否出现故障的机制决定的：每个Sentinel都独立判断主服务器是否出现故障，如果某个Sentinel进程认为主服务器出现故障，那么就投出一票。当投票数超过运行的Sentinel进程数后，那么就认定主服务器出现了故障，进行故障转移操作。也就是少数服从多数，所以至少有三台服务器运行Sentinel进程，且必须为奇数。</strong></p><p><strong>注意：Sentinel监控主服务机制：Sentinel会定期向master发送PING命令来确认master是否能够正常运行</strong></p><p><strong>注意：无需在sentinel配置文件中指定其他sentinel服务器的信息，因为sentinel可以通过发布和订阅功能来发现正在监视相同主服务器的其他Sentinel，这一功能是通过向频道sentinel:hello发送信息实现的。同样的，也无需列出主服务器属下的所有从服务器，因为Sentinel可以询问主服务器来获取这些信息。每个Sentinel会以两秒一次的频率，通过发布和订阅功能，向被它监视的所有主服务器和从服务器的sentinel:hello发送一条信息，信息中包含了Sentinel的ip地址、端口号和运行ID和完整的主服务器当前配置，当Sentinel通过所有主服务器和从服务器的sentinel:hello频道查找到之前从未出现过的sentinel时，它会将新的Sentinel添加到列表中(就是添加到自己的配置文件中)，关于这些，后面会讲到。</strong></p><p><strong>当发现主服务器出现故障并且投票数达到指定的投票数后，Sentinel会从 从服务器中选出一个来作为主服务器，并重新配置：将从服务器设置为主服务器，并将其他的从服务器挂到新的主服务器上。</strong></p><p>需要修改Sentinel的配置文件。</p><p>修改sentinal monitor这行，格式为：</p><p><code>sentinel monitor &lt;name&gt; &lt;masterIp&gt; &lt;masterPort&gt; &lt;投票数&gt;</code></p><p>其中：</p><ul><li>name：自定义项，表示主服务器，可以理解为给主服务器起个名</li><li>masterIp：要监控的主服务器的ip地址</li><li>masterPort：要监控的主服务器的端口号</li><li>投票数：当投票总数达到多少时，认定主服务器出现故障。例如：有三台运行Sentinel服务器，那么投票数就应该设为2。</li></ul><p><strong>注意：Windows版本的Redis没有sentinel配置文件，需要手动创建，然后通过redis-server.exe来运行，并加上选项—sentinel，格式为<code>redis-server.exe &lt;配置文件路径&gt; --sentinel</code></strong>。</p><p><strong>如果是linux系统，那么就有redis-sentinel可执行文件和配置文件。</strong></p><h3 id="一个例子-1"><a href="#一个例子-1" class="headerlink" title="一个例子"></a>一个例子</h3><p>以上面主从复制例子为基础，在同一台电脑分别运行三个sentinel进程。监控主服务器。</p><p>创建sentinel配置文件，分别为sentinel1.conf、sentinel2.conf、sentinel3.conf</p><p>添加内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs conf">bind 127.0.0.1<br>port 6388<br>sentinel myid df74029ad5ecbd7677fe8a9e18a97ee086e721c2<br>sentinel monitor mymaster 127.0.0.1 6380 2<br>sentinel down-after-milliseconds mymaster 5000<br>sentinel failover-timeout mymaster 15000<br>sentinel parallel-syncs mymaster 1<br></code></pre></td></tr></table></figure><p>其中端口号分别修改为6388、6389、6390。代表三个sentinel进程。</p><p>其中：</p><ul><li>down-after-milliseconds：该选项指定了，当sentinel向主服务器发送请求ping时，多长时间没有有效回复，被认定为主服务器故障。也就是说，发送ping命令后，如果在down-after-milliseconds毫秒内，主服务器没有作出有效回复，那么就被认定为主服务器出现故障。</li><li>failover-timeout：表示当故障转移开始后，如果在设定时间内没有执行任务故障转移操作，当前的sentinel会认为这次故障转移失败</li><li>parallel-syncs：当发生故障转移，主备切换时，<strong>该选项指定了最多有多少个slave同时对新的master进行数据同步</strong>。当同步数据时，从服务器无法处理命令请求。这个值越小，完成故障转移时间越长，但是读请求性能下降少；值越大，那么意味越多slave因为数据同步replication而不可用。</li></ul><p>然后启动sentinel：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102170222964.png" alt="image-20210102170222964" style="zoom:67%;" /></p><p>可以看到，sentinel运行在sentinel模式下。并且会自动检测到主服务器的所有从服务器。</p><p>接下来让主服务器停掉，查看Sentinel进程有什么变化：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102172318936.png" alt="image-20210102172318936"></p><p>另一个sentinel进程：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102172728948.png" alt="image-20210102172728948" style="zoom:50%;" /></p><p>可以看到，在主服务器停止工作以后，sentinel监控到了。并打印出日志。</p><p>然后从新选出了一个从服务器：端口为6381的服务器，作为主服务器。然后进行重新配置。</p><p>查看6381的信息：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102173147500.png" alt="image-20210102173147500" style="zoom:50%;" /></p><p>已经变成了主服务器。</p><p>这时，如果再重新启动6380服务器，那么该服务器会被sentinel监控到，并被设置为从服务器。</p><p>sentinel终端：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102173404158.png" alt="image-20210102173404158" style="zoom:150%;" /></p><p>另一个终端：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102173534732.png" alt="image-20210102173534732"></p><p>此时再查看6381信息：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102173428555.png" alt="image-20210102173428555" style="zoom:50%;" /></p><p>已经有两个从服务器：6380和6382。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ol><li>Sentinel会不断检查主从服务器是否工作正常</li><li>如果Sentinel出现问题，就无法监控。所以需要多个哨兵Sentinel，组成Sentinel网络。一个健康的Sentinel至少有三个Sentinel应用。彼此在不同服务器。(或者不同虚拟机)</li><li>监控同一个master的Sentinel会自动连接，组成一个分布式的Sentinel网络，彼此通信并交换被监控服务器和自身信息。</li><li>当一个Sentinel认为被监控的服务器下线时，它会向网络中其他Sentinel进行确认，判断服务器是否真的下线。</li><li>如果下线的是主服务器，那么Sentinel网络会进行自动故障转移，通过选举从   从服务器slave中选出一个成为新的主服务器，并重新进行配置。</li><li>下线的旧主服务器如果重新运行，那么Sentinel会让他成为从服务器。</li></ol><p><strong>注意：Sentinel监控的不只是主服务器，它监控的是所有服务器，只是当主服务器下线时，它会进行故障转移。</strong></p><h2 id="安全设置"><a href="#安全设置" class="headerlink" title="安全设置"></a>安全设置</h2><h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>默认的Redis是没有密码的，这样不太安全。可以通过修改配置文件来设置连接Redis服务端时的密码。</p><p>在配置文件中，设置<code>requirepass</code> 这一行。</p><p>格式是：<code>requirepass 密码</code></p><p>这时，使用客户端连接Redis服务端时，有两种方式：</p><ul><li>在执行redis-cli时使用-a选项来设置密码，例如：<code>redis-cli -a 123456</code></li><li>先执行redis-cli，但是这时不能执行任何redis命令。需要使用<code>auth 密码</code>来验证密码。</li></ul><h4 id="一个例子-2"><a href="#一个例子-2" class="headerlink" title="一个例子"></a>一个例子</h4><p>设置密码为123456，然后重新运行redis-server，并加载配置文件</p><p>使用第一种连接：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102175511144.png" alt="image-20210102175511144" style="zoom:50%;" /></p><p>同时也提示，使用-a选项在命令行直接输入密码是不安全的。</p><p>使用第二种连接：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102175430833.png" alt="image-20210102175430833" style="zoom:50%;" /></p><h3 id="修改绑定ip"><a href="#修改绑定ip" class="headerlink" title="修改绑定ip"></a>修改绑定ip</h3><p>在配置文件中，可以修改<code>bind ip</code>这行。</p><p>来指定可以访问redis服务器的ip地址。</p><p>多个ip使用空格分割。</p><h3 id="修改默认端口"><a href="#修改默认端口" class="headerlink" title="修改默认端口"></a>修改默认端口</h3><p>使用默认的端口比较危险。可以修改。</p><p>在配置文件中修改<code>port 端口号</code>即可。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>Redis</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-value数据类型及操作命令</title>
    <link href="/2022/05/11/Redis/4-value%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/11/Redis/4-value%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis一共有5种数据类型：</p><ol><li>字符串string：可以存储任何形式的字符串，包括二进制数据，序列化后的数据，JSON化后的数据，甚至是一张图片，最大512M</li><li>哈希类型Hash：是一个string类型的field和value的映射表，适合存储对象</li><li>列表list：简单的字符串列表，按照插入顺序排序，可以添加一个元素到头部(左边)或者尾部(右边)</li><li>集合Set：是String类型的无序集合，集合成员唯一，不能出现重复数据</li><li>有序集合zset：和集合set一样是string类型元素的集合，不允许重复成员。并且zset的每个元素会关联一个分数(分数可以重复)，redis按照分数为集合成员进行从小到大排序</li></ol><h2 id="字符串类型String"><a href="#字符串类型String" class="headerlink" title="字符串类型String"></a>字符串类型String</h2><p>常用命令：</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>语法：set key value</p><p>作用：新建一个key-value键值对，类型都为string</p><p>返回值：设置成功，返回OK</p><p>注意：如果库中已经有key这个名，那么新value会覆盖旧value</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101140021172.png" alt="image-20210101140021172" style="zoom:67%;" /></p><h3 id="setrange"><a href="#setrange" class="headerlink" title="setrange"></a>setrange</h3><p>语法：setrange key offset value</p><p>作用：用value替换key存储的值，从offset开始。如果key不存在，那么就当空白字符串，</p><p>返回值：修改后的字符串值长度</p><p>索引看作从1开始，那么offset就代表，从第offset后开始替换，不包括offset。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101142514988.png" alt="image-20210101142514988" style="zoom:67%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101142506797.png" alt="image-20210101142506797" style="zoom:67%;" /><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101142645311.png" alt="image-20210101142645311"></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101142506797.png" alt="image-20210101142506797" style="zoom:67%;" /><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101142645311.png" alt="image-20210101142645311" style="zoom:50%;" /></p><h3 id="mset"><a href="#mset" class="headerlink" title="mset"></a>mset</h3><p>语法：mset key value [key value ….]      使用空格分隔</p><p>作用：同时设置一个或多个key-value</p><p>返回值为OK</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101142905033.png" alt="image-20210101142905033" style="zoom:67%;" /></p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>语法：get key</p><p>作用：获取key对应的value值</p><p>返回值：获取成功，返回对应value值，否则返回nil(可以理解为null)</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101140143662.png" alt="image-20210101140143662" style="zoom:67%;" /></p><h3 id="getrange"><a href="#getrange" class="headerlink" title="getrange"></a>getrange</h3><p>语法：getrange key start end</p><p>作用：获取key存储字符串值从start到end结束的子字符串。包括start和end。<strong>索引从0开始，负数表示从字符串末尾开始，-1表示最后一个字符</strong></p><p>返回值：存在key，就返回指定子字符串；不存在，返回</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101141814824.png" alt="image-20210101141814824" style="zoom:67%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101141858495.png" alt="image-20210101141858495" style="zoom:67%;" /></p><h3 id="mget"><a href="#mget" class="headerlink" title="mget"></a>mget</h3><p>语法：mget key [key…]   使用空格分隔</p><p>作用：获取所有给定的key的字符串值</p><p>返回值：包含所有给定key对应的value列表。其中如果key不存在，则返回nil</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101143142094.png" alt="image-20210101143142094" style="zoom:67%;" /></p><h3 id="incr"><a href="#incr" class="headerlink" title="incr"></a>incr</h3><p>语法：incr key</p><p>作用：将key对应的value的值加1，当value值为数字类型时才可以使用，对非数字操作不行</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101140817603.png" alt="image-20210101140817603" style="zoom:67%;" /></p><h3 id="decr"><a href="#decr" class="headerlink" title="decr"></a>decr</h3><p>和incr用法一样，这个是减1</p><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p>语法：append key value</p><p>用法：如果key存在，则将value追加到已存在的value后面；如果不存在，那么就创建对应key和value</p><p>返回值：返回追加后，字符串总长度</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101141106168.png" alt="image-20210101141106168" style="zoom:80%;" /></p><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p>语法：strlen key</p><p>作用：返回key存储的字符串的长度</p><p>返回值：如果key存在， 那么返回字符串值的长度；不存在，返回0</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101141328434.png" alt="image-20210101141328434" style="zoom:80%;" /></p><h2 id="哈希类型Hash"><a href="#哈希类型Hash" class="headerlink" title="哈希类型Hash"></a>哈希类型Hash</h2><p>常用命令：</p><h3 id="hset"><a href="#hset" class="headerlink" title="hset"></a>hset</h3><p>语法：hset key field value</p><p>作用：向哈希表key中添加field-value键值对，如果key不存在，则新建hash表，执行赋值；如果存在field，则覆盖旧值</p><p>返回值：</p><ul><li>如果field是hash表中新field，且设置值成功，返回1</li><li>如果field已经存在，旧值覆盖新值，返回0</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101143825536.png" alt="image-20210101143825536" style="zoom:67%;" /></p><h3 id="hget"><a href="#hget" class="headerlink" title="hget"></a>hget</h3><p>语法：hget key field</p><p>作用：获取哈希表key中给定域的值</p><p>返回值：如果key不存在或者field不存在返回nil，否则返回field对应的值</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101144022748.png" alt="image-20210101144022748" style="zoom:67%;" /></p><h3 id="hmset"><a href="#hmset" class="headerlink" title="hmset"></a>hmset</h3><p>语法：hmset key field value [field value…]</p><p>作用：同时将多个field-value键值对添加到哈希表key中，此命令会覆盖已存在的field。如果key不存在，那么创建空的hash表，再执行hmset</p><p>返回值：成功返回OK，失败返回错误</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101144247754.png" alt="image-20210101144247754" style="zoom:67%;" /></p><h3 id="hmget"><a href="#hmget" class="headerlink" title="hmget"></a>hmget</h3><p>语法：hmget key field [field…]</p><p>作用：获取哈希表key中多个给定field对应的值</p><p>返回值：返回和field顺序对应的值，如果field不存在，返回nil</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101144415762.png" alt="image-20210101144415762" style="zoom:50%;" /></p><h3 id="hgetall"><a href="#hgetall" class="headerlink" title="hgetall"></a>hgetall</h3><p>语法：hgetall key</p><p>作用：获取哈希表key中所有的域和值</p><p>返回值：以列表形式返回哈希表中域和值，key不存在，返回空hash</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101144618780.png" alt="image-20210101144618780" style="zoom:67%;" /></p><h3 id="hdel"><a href="#hdel" class="headerlink" title="hdel"></a>hdel</h3><p>语法：hdel key field [field…]</p><p>作用：删除哈希表key中一个或多个指定field及其值。如果不存在field，则忽略</p><p>返回值：返回删除成功的field的数量</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101144801626.png" alt="image-20210101144801626" style="zoom:67%;" /></p><h3 id="hkeys"><a href="#hkeys" class="headerlink" title="hkeys"></a>hkeys</h3><p>语法：hkeys key</p><p>作用：查看哈希表key中所有的field</p><p>返回值：包含所有field的列表，key不存在返回空列表</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101145107819.png" alt="image-20210101145107819" style="zoom: 50%;" /><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101145125043.png" alt="image-20210101145125043"></p><h3 id="hvals"><a href="#hvals" class="headerlink" title="hvals"></a>hvals</h3><p>语法：hvals key</p><p>作用：返回哈希表中所有域对应的值</p><p>返回值：值的列表，key不存在，返回空列表</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101145125043.png" alt="image-20210101145125043"></p><h3 id="hexists"><a href="#hexists" class="headerlink" title="hexists"></a>hexists</h3><p>语法：hexists key field</p><p>作用：查看哈希表key中，指定的field是否存在值</p><p>返回值：存在返回1，不存在返回0</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101145150434.png" alt="image-20210101145150434" style="zoom:67%;" /></p><h2 id="列表类型List"><a href="#列表类型List" class="headerlink" title="列表类型List"></a>列表类型List</h2><p>简单的字符串列表，也就是value只能是字符串。可以添加一个元素到列表的表头(左边)或者表尾(右边)</p><p>常用命令：</p><h3 id="lpush"><a href="#lpush" class="headerlink" title="lpush"></a>lpush</h3><p>语法：lpush key value [value..]</p><p>作用：将一个或多个值插入列表key的表头(左边)，从左边开始加入值，按从左到右顺序依次加入到表头。<strong>如果不存在key，那么会创建一个list，并加入给定value。也就是说，如果给定key存在，那么列表至少有一个value。</strong></p><p>返回值：一个数字，新列表的长度</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101145717927.png" alt="image-20210101145717927" style="zoom:67%;" /></p><p>在列表中顺序依次为c b a</p><h3 id="lpushx"><a href="#lpushx" class="headerlink" title="lpushx"></a>lpushx</h3><p>和lpush用法一样，只是当key不存在时，该命令不会创建list</p><h3 id="rpush"><a href="#rpush" class="headerlink" title="rpush"></a>rpush</h3><p>语法：rpush key value [value..]</p><p>作用：将一个或多个值插入列表key的表尾(右边)，从左边开始加入值，按从左到右顺序依次加入到表尾。<strong>如果不存在key，那么会创建一个list，并加入给定value。也就是说，如果给定key存在，那么列表至少有一个value。</strong></p><p>返回值：一个数字，新列表的长度</p><p><code>rpush list a b c</code>，那么在列表中顺序为a   b   c</p><h3 id="rpushx"><a href="#rpushx" class="headerlink" title="rpushx"></a>rpushx</h3><p>和rpush用法一样，只是当key不存在时，该命令不会创建list</p><h3 id="lrange"><a href="#lrange" class="headerlink" title="lrange"></a>lrange</h3><p>语法：lrange key start stop</p><p>作用：获取列表key中指定区间的元素。索引从0开始。包括start和stop</p><p>也可以为负数，-1为列表最后一个元素，-2为倒数第二个元素，以此类推。start、stop超出列表范围不会出现错误。</p><p>返回值：指定区间的列表</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101150156030.png" alt="image-20210101150156030" style="zoom:67%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101150210479.png" alt="image-20210101150210479" style="zoom:67%;" /></p><h3 id="lindex"><a href="#lindex" class="headerlink" title="lindex"></a>lindex</h3><p>语法：lindex key index</p><p>作用：获取列表key中下标为index的元素。索引从0开始。也可以是负数，-1代表最后一个元素。</p><p>返回值：存在，则返回指定元素；index不再列表范围，返回nil</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101150644676.png" alt="image-20210101150644676" style="zoom:67%;" /></p><h3 id="llen"><a href="#llen" class="headerlink" title="llen"></a>llen</h3><p>语法：llen key</p><p>作用：获取列表key的长度</p><p>返回值：数值，列表长度；不存在key则返回0</p><h3 id="lrem"><a href="#lrem" class="headerlink" title="lrem"></a>lrem</h3><p>语法：lrem key count value</p><p>作用：根据参数count的值，移除列表中和参数value相等的元素，count&gt;0；则从列表左侧开始向右移除count个相等的元素；count&lt;0，则从列表右侧开始移除 count绝对值 个相等的元素；count=0，则移除所有和value相等的值</p><p>返回值：移除的元素个数</p><h3 id="lset"><a href="#lset" class="headerlink" title="lset"></a>lset</h3><p>语法：lset key index value</p><p>作用：将列表key下标为index的元素的值设置为value</p><p>返回值：成功返回OK；key不存在或者index超出范围返回错误信息</p><h3 id="linsert"><a href="#linsert" class="headerlink" title="linsert"></a>linsert</h3><p>语法：linsert key BEFORE|AFTER pivot value</p><p>作用：将值value插入到列表key中位于值pivot之前或之后的位置。key不存在或pivot不在列表，则不执行任何操作</p><p>返回值：执行成功，返回新列表长度；没有找到pivot返回-1；key不存在返回0</p><p>注意：pivot是值value，不是索引。</p><h3 id="lpop"><a href="#lpop" class="headerlink" title="lpop"></a>lpop</h3><p>语法：lpop key</p><p>作用：删除并获取列表key中第一个元素(最左边表头元素)</p><p>返回值：列表不存在，返回nil；否则返回对应元素值</p><h3 id="rpop"><a href="#rpop" class="headerlink" title="rpop"></a>rpop</h3><p>语法：rpop key</p><p>作用：删除并获取列表key中最后一个元素(最右边表尾元素)</p><p>返回值：列表不存在，返回nil；否则返回对应元素值</p><h3 id="blpop"><a href="#blpop" class="headerlink" title="blpop"></a>blpop</h3><p>语法：blpop key [key..] timeout </p><p>作用：删除并获取列表key中第一个元素(最左边表头元素)，如果列表没有元素会阻塞到超时。超时时间timeout单位为秒</p><p>返回值：列表不存在，返回nil；否则返回一个含有两个元素的列表，第一个元素是列表的key，第二个元素是被删除的value</p><h3 id="brpop"><a href="#brpop" class="headerlink" title="brpop"></a>brpop</h3><p>语法：brpop key [key..] timeout </p><p>作用：删除并获取列表key中最后一个元素(最右边表尾元素)，如果列表没有元素会阻塞到超时。超时时间timeout单位为秒</p><p>返回值：列表不存在，返回nil；否则返回一个含有两个元素的列表，第一个元素是列表的key，第二个元素是被删除的value</p><h2 id="集合类型Set"><a href="#集合类型Set" class="headerlink" title="集合类型Set"></a>集合类型Set</h2><p>Set是字符串类型的无序集合，元素不能重复</p><p>常用命令有：</p><h3 id="sadd"><a href="#sadd" class="headerlink" title="sadd"></a>sadd</h3><p>语法：sadd key member [member…]</p><p>作用：将一个或多个元素加入到集合key中；如果有member已经在集合中，则会被忽略，不会加入</p><p>返回值：加入到集合的新元素的个数，不包括被忽略的元素</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102113140552.png" alt="image-20210102113140552" style="zoom:67%;" /></p><h3 id="smembers"><a href="#smembers" class="headerlink" title="smembers"></a>smembers</h3><p>语法：smembers key</p><p>作用：获取集合key中所有的成员元素，不存在的key被视为空集合</p><p>返回值：成员元素列表</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102113244013.png" alt="image-20210102113244013" style="zoom:67%;" /></p><h3 id="sismember"><a href="#sismember" class="headerlink" title="sismember"></a>sismember</h3><p>语法：sismember key member</p><p>作用：判断member元素是否是集合key的成员</p><p>返回值：是返回1，不是返回0</p><h3 id="scard"><a href="#scard" class="headerlink" title="scard"></a>scard</h3><p>语法：scrad key</p><p>作用：获取集合中元素个数</p><p>返回值：一个数字</p><h3 id="srem"><a href="#srem" class="headerlink" title="srem"></a>srem</h3><p>语法：srem key member [member…]</p><p>作用：删除集合key中一个或多个元素，不存在的元素会被忽略</p><p>返回值：数字，成功删除的元素个数，不包括忽略的元素</p><h3 id="srandmember"><a href="#srandmember" class="headerlink" title="srandmember"></a>srandmember</h3><p>语法：srandmember key [count]</p><p>作用：如果只提供key参数，那么会随机返回集合一个元素，元素不删除；如果提供了count，count是正数，那么返回包含了count个元素的集合，集合元素各不相同；如果是负数，返回一个count绝对值的长度的集合，集合中元素可能会重复多次</p><p>返回值：多个元素的集合</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102114027892.png" alt="image-20210102114027892" style="zoom:67%;" /></p><h3 id="spop"><a href="#spop" class="headerlink" title="spop"></a>spop</h3><p>语法：spop key [count]</p><p>作用：随机从集合中删除并获取一个元素，count是删除元素的个数。不指定count，默认删除一个。</p><p>返回值：被删除的元素；如果key不存在或者空集合返回nil</p><h3 id="sinter"><a href="#sinter" class="headerlink" title="sinter"></a>sinter</h3><p>语法：sinter  key1 [key2…]</p><p>作用：返回给定所有元素的交集。如果只给一个集合参数，就返回该集合所有元素</p><p>返回值：一个交集合。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102114459556.png" alt="image-20210102114459556" style="zoom:67%;" /></p><h3 id="sinterstore"><a href="#sinterstore" class="headerlink" title="sinterstore"></a>sinterstore</h3><p>语法：sinter destination key1 [key2]</p><p>作用：返回给定所有集合的交集元素个数并存储到destination中</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102114733237.png" alt="image-20210102114733237" style="zoom:67%;" /></p><h3 id="sunion"><a href="#sunion" class="headerlink" title="sunion"></a>sunion</h3><p>语法：sunion key1 [key2]</p><p>作用：返回给定所有集合的并集元素，如果只给一个集合参数，就返回该集合所有元素。</p><p>返回值：一个集合</p><h3 id="sunionstore"><a href="#sunionstore" class="headerlink" title="sunionstore"></a>sunionstore</h3><p>语法：sunionstore destination key1 [key2]</p><p>作用：返回给定所有集合的并集元素个数并存储到destination中</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102114931584.png" alt="image-20210102114931584" style="zoom:50%;" /></p><h2 id="有序集合类型zSet"><a href="#有序集合类型zSet" class="headerlink" title="有序集合类型zSet"></a>有序集合类型zSet</h2><p>有序集合zset和集合类型set都是string类型的集合。且不允许重复。</p><p>不同的是，zset每个元素都会关联一个分数，分数可以重复，分数可以是整数或浮点数</p><p>redis通过分数来为集合成员进行从小到大的排序。</p><p>常用命令有：</p><h3 id="zadd"><a href="#zadd" class="headerlink" title="zadd"></a>zadd</h3><p>语法：zadd key score member [score member…]</p><p>作用：将一个或多个member元素及其score值加入到有序集合key中，如果mmember存在集合中，则更新score值。</p><p>返回值：新添加的元素个数，不包括已存在的member</p><h3 id="zrange"><a href="#zrange" class="headerlink" title="zrange"></a>zrange</h3><p>语法：zrange ket start stop [WITHSCORES]</p><p>作用：查询有序集合指定区间的元素。集合成员按score值从小到大来排序。索引从0开始。-1表示最后一个成员。如果加上WITHSCORES选项，表示让score和value一起返回</p><p>返回值：自定区间的成员集合</p><h3 id="zrevrange"><a href="#zrevrange" class="headerlink" title="zrevrange"></a>zrevrange</h3><p>语法：zrevrange ket start stop [WITHSCORES]</p><p>作用：查询有序集合指定区间的元素。集合成员按score值从大到小来排序。索引从0开始。-1表示最后一个成员。如果加上WITHSCORES选项，表示让score和value一起返回</p><p>返回值：自定区间的成员集合</p><p>和zrange命令基本一样。zrange从小到大排列，zrevrange从大到小排列</p><h3 id="zrem"><a href="#zrem" class="headerlink" title="zrem"></a>zrem</h3><p>语法：zrem key member [member…]</p><p>作用：删除有序集合key中的一个元素或多个，不存在的成员会被忽略</p><p>返回值：被成功刹车农户的成员数量。不包括被忽略的成员</p><h3 id="zcard"><a href="#zcard" class="headerlink" title="zcard"></a>zcard</h3><p>语法：zcard key</p><p>作用：获取有序集key元素个数</p><p>返回值：元素个数；key不存在，返回0</p><h3 id="zrangebyscore"><a href="#zrangebyscore" class="headerlink" title="zrangebyscore"></a>zrangebyscore</h3><p>语法：zrangebyscore key min max [WITHSCORES] [LIMIT offset count]</p><p>作用：获取有序集key中，所有socre介于min和max之间(包括min和max)的成员，有序集合按递增(从小到大)排序</p><p>​            使用符号<code>(</code>表示不包括min和max，也就是开区间；</p><p>​            使用-inf和+inf分别表示，最小和最大；</p><p>​            <strong>LIMIT用来限制返回结果的数量和区间。表示在符合条件的成员中，从第offset个位置(索引从0开始)开始，取count个元素。</strong></p><p>​            WITHSCORES表示一起显示score和value</p><p>返回值：指定区间的集合数据</p><p>使用的数据：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102120807849.png" alt="image-20210102120807849" style="zoom:50%;" /></p><p>第一个例子：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102120849877.png" alt="image-20210102120849877" style="zoom:50%;" /></p><p>使用<code>(</code>代表开区间：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102120937482.png" alt="image-20210102120937482" style="zoom:50%;" /></p><p>使用-inf和+inf表示最小和最大：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102121032936.png" alt="image-20210102121032936" style="zoom:50%;" /></p><p>使用limit限制输出开始位置和个数：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210102121129992.png" alt="image-20210102121129992" style="zoom:50%;" /></p><p>表示在符合条件的所有元素中，从第一个位置开始取，连续取2个元素。</p><h3 id="zrevrangebyscore"><a href="#zrevrangebyscore" class="headerlink" title="zrevrangebyscore"></a>zrevrangebyscore</h3><p>语法：zrevrangebyscore key min max [WITHSCORES] [LIMIT offset count]</p><p>作用：获取有序集key中，所有socre介于min和max之间(包括min和max)的成员，有序集合按递减(从大到小)排序</p><p>​            使用符号<code>(</code>表示不包括min和max，也就是开区间；</p><p>​            使用-inf和+inf分别表示，最小和最大；</p><p>​            <strong>LIMIT用来限制返回结果的数量和区间。表示在符合条件的成员中，从第offset个位置(索引从0开始)开始，取count个元素。</strong></p><p>​            WITHSCORES表示一起显示score和value</p><p>返回值：指定区间的集合数据</p><p>和zrangebyscore基本一样，这个是从大到小排序。</p><h3 id="zcount"><a href="#zcount" class="headerlink" title="zcount"></a>zcount</h3><p>语法：zcount key min max</p><p>作用：返回有序集key中，score值在min和max之间(默认包括min和max)的成员数量。使用<code>(</code>代表开区间</p><p>返回值：元素个数</p><h3 id="zscore"><a href="#zscore" class="headerlink" title="zscore"></a>zscore</h3><p>语法：zscore key member</p><p>作用：返回有序集key中，给定member的分数值score</p><p>返回值：分数值，不存在返回nil</p><h3 id="zrank"><a href="#zrank" class="headerlink" title="zrank"></a>zrank</h3><p>语法：zrank key member</p><p>作用：返回有序集合key中指定成员索引，分数由小到大排列</p><p>返回值：索引值，不存在返回nil</p><h3 id="zrevrank"><a href="#zrevrank" class="headerlink" title="zrevrank"></a>zrevrank</h3><p>语法：zrevrank key member</p><p>作用：返回有序集合key中指定成员索引，分数由大到小排列</p><p>返回值：索引值，不存在返回nil</p><h3 id="zremrangebyscore"><a href="#zremrangebyscore" class="headerlink" title="zremrangebyscore"></a>zremrangebyscore</h3><p>语法：zremrangebyscore key start stop</p><p>作用：删除指定分数区间的所有元素，默认包括start和stop，使用<code>(</code>可不包括，开区间</p><p>返回值：成功删除的元素个数</p><h3 id="zremrangebyrank"><a href="#zremrangebyrank" class="headerlink" title="zremrangebyrank"></a>zremrangebyrank</h3><p>语法：zremrangebyrank key start stop</p><p>作用：删除指定排名索引区间的所有元素，包括start和stop。索引从0开始，排序由小到大。</p><p>返回值：成功删除的元素个数</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>Redis</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-关于key的命令</title>
    <link href="/2022/05/11/Redis/3-%E5%85%B3%E4%BA%8Ekey%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/11/Redis/3-%E5%85%B3%E4%BA%8Ekey%E7%9A%84%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis是key-value型数据库。所以有操作key的一类命令，同样也有操作value的一类命令。</p><h2 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h2><p>语法：keys pattern</p><p>作用：查找所有符合模式pattern的key，pattern可以使用通配符。</p><p>通配符：</p><pre><code class="hljs">        1. *：表示0-多个字符，keys *代表查询所有key        2. ?：表示单个字符，例如keys hel?o，可匹配hello，helqo等</code></pre><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101131747885.png" alt="image-20210101131747885" style="zoom:80%;" /></p><h2 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h2><p>语法：exists key [key..]</p><p>作用：判断指定的key或多个key是否存在。</p><p>返回值：返回存在key的数量，不管是查找一个key还是多个key</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101132026879.png" alt="image-20210101132026879" style="zoom:67%;" /></p><h2 id="expire"><a href="#expire" class="headerlink" title="expire"></a>expire</h2><p>语法：expire key seconds</p><p>作用：设置key的生存时间，超过时间，key会自动删除，单位是秒</p><p>返回值：设置成功返回1，不成功是0</p><p>如果不设置，那么key会永久保存。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101132515408.png" alt="image-20210101132515408" style="zoom:67%;" /></p><h2 id="ttl"><a href="#ttl" class="headerlink" title="ttl"></a>ttl</h2><p>语法 ：ttl key</p><p>作用：返回key的剩余时间(time to live)，以秒为单位</p><p>返回值：</p><ul><li>返回   -1：代表没有设置key的生存时间，永不过期</li><li>返回   -2 ：代表不存在该key</li><li>数字：key的剩余时间，秒为单位</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101132827883.png" alt="image-20210101132827883" style="zoom:67%;" /></p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>语法：type key</p><p>作用：查看key存储的value值得数据类型</p><p>返回值：使用字符串表示的数据类型</p><ul><li>none：key不存在</li><li>string：字符串</li><li>list：列表</li><li>set 集合</li><li>zset：有序集合</li><li>hash：哈希表</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101133050493.png" alt="image-20210101133050493" style="zoom:67%;" /></p><h2 id="del"><a href="#del" class="headerlink" title="del"></a>del</h2><p>语法：del key [key..]</p><p>作用：删除存在的key，不存在的key忽略</p><p>返回值：数字，删除的key的数量</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101133229831.png" alt="image-20210101133229831" style="zoom:67%;" /></p><h2 id="persist"><a href="#persist" class="headerlink" title="persist"></a>persist</h2><p>语法：persist key </p><p>作用：移除key的过期时间，key将持久保持</p><p>返回值：成功返回1，失败返回0</p><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ol><li><p>randomkey</p><p> 语法：randomkey</p><p> 作用：从当前库随机返回一个key</p><p> 返回值：返回一个key</p></li><li><p>move </p><p> 语法：move key db</p><p> 作用：将当前数据库中的指定key移动到数据库db中</p><p> 返回值：成功返回1，失败返回0</p></li><li><p>pttl</p><p> 语法：pttl key</p><p> 作用：以毫秒为单位，返回key的剩余过期时间</p><p> 返回值：</p><ul><li>-1：没有设置key的过期时间，永久保存</li><li>-2：不存在该key</li><li>数字：以毫秒为单位，key的剩余过期时间</li></ul></li><li><p>rename</p><p> 语法：rename key newkey</p><p> 作用：重命名key为newkey</p><p> 返回OK代表成功</p><p> 当库中已存在newkey时，那么newkey对应的值将被覆盖，也就是newkey对应的value将是key对应的value</p><p> <img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101134657570.png" alt="image-20210101134657570" style="zoom:67%;" /></p></li><li><p>renamenx</p><p> 语法：rename key newkey</p><p> 作用：当newkey不存在时，将key改名为newkey。也就是避免覆盖已存在的key对应的value</p></li><li><p>dump</p><p> 语法：dump key</p><p> 作用：序列为给定key</p><p> 返回值：若序列化成功，则返回被序列化的值。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>Redis</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-Redis基本操作命令</title>
    <link href="/2022/05/11/Redis/2-Redis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/11/Redis/2-Redis%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先运行服务器端Redis：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101130538411.png" alt="image-20210101130538411" style="zoom: 50%;" /></p><h2 id="查看是否连接到服务器：ping"><a href="#查看是否连接到服务器：ping" class="headerlink" title="查看是否连接到服务器：ping"></a>查看是否连接到服务器：ping</h2><p>在客户端使用ping命令，可以查看客户端是否成功连接到服务端。如果成功连接到，会返回一个PONG</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101130645009.png" alt="image-20210101130645009" style="zoom:67%;" /></p><h2 id="切换库命令：select-db"><a href="#切换库命令：select-db" class="headerlink" title="切换库命令：select db"></a>切换库命令：select db</h2><p>Redis默认创建16个库(该配置可以在配置文件中修改)，redis默认使用第一个库。</p><p>使用 <code>select db</code>来切换其他库，db代表数据库编号，从0到15。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101130851545.png" alt="image-20210101130851545" style="zoom:80%;" /></p><h2 id="查看当前库中key的数目：dbsize"><a href="#查看当前库中key的数目：dbsize" class="headerlink" title="查看当前库中key的数目：dbsize"></a>查看当前库中key的数目：dbsize</h2><p>dbsize可以返回当前库中，key的数目。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101131011818.png" alt="image-20210101131011818" style="zoom:80%;" /></p><h2 id="删除当前库数据：flushdb"><a href="#删除当前库数据：flushdb" class="headerlink" title="删除当前库数据：flushdb"></a>删除当前库数据：flushdb</h2><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210101131115509.png" alt="image-20210101131115509" style="zoom:80%;" /></p><h2 id="退出：exit或quit"><a href="#退出：exit或quit" class="headerlink" title="退出：exit或quit"></a>退出：exit或quit</h2><p>注意，这个退出，只是指客户端退出，但是服务器端依然在运行。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>Redis</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-Redis基础</title>
    <link href="/2022/05/11/Redis/1-Redis%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/11/Redis/1-Redis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Redis介绍"><a href="#Redis介绍" class="headerlink" title="Redis介绍"></a>Redis介绍</h2><p>Redis是一个key-value存储系统，数据缓存在内存中，同时Redis会周期性的把更新的数据写入磁盘或修改操作写入追加的记录文件。</p><p>Redis支持主从同步，数据可以从主服务器上向任意数量的从服务器上同步。</p><p>Redis的value值支持5种数据类型，分别是字符串String，列表List、集合Set、有序集合zSet和哈希Hash。</p><h2 id="为啥使用Redis"><a href="#为啥使用Redis" class="headerlink" title="为啥使用Redis"></a>为啥使用Redis</h2><p>Redis是非关系型数据库，即NoSQL。在NoSQL数据库中数据之间是无联系的，没有关系，数据的结构是松散、可变的。</p><p>非关系型数据库的优势：</p><ul><li><p>大数据量，高性能</p><p>  NoSQL数据库都具有非常高的读写性能，尤其是在大数据量下，表现很优秀。这得益于数据的无关系型，数据库结构简单。</p></li><li><p>灵活的数据模型</p><p>  NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。</p></li><li><p>高可用</p></li><li><p>低成本</p></li></ul><p>当然，非关系型数据库也有劣势：</p><ul><li>数据之间没有关系</li><li>不支持标准的SQL，没有公认的NoSQL标准</li><li>没有关系型数据库的约束，大多数也没有索引概念</li><li>没有事务，不能依靠事务实现ACID</li><li>没有丰富的数据类型，如日期，数值，二进制等</li></ul><h2 id="Redis简单使用"><a href="#Redis简单使用" class="headerlink" title="Redis简单使用"></a>Redis简单使用</h2><p>Window版本的Redis不是真正的Redis，Reids的作者，是基于Linux系统，只写了Linux版本。Windows版本的Redis是微软公司推出的。但是和Linux版本的Redis使用基本相同。</p><p>在开发环境中，可以使用Windows，但在实际生产环境中，要使用Linux版本的。</p><h3 id="Windows下使用"><a href="#Windows下使用" class="headerlink" title="Windows下使用"></a>Windows下使用</h3><p>Redis有三个文件比较重要，redis-cli.exe、redis-server.exe和redis.window.conf，分别对应redis客户端，redis服务器端，redis的Windows版本配置文件。</p><p>在使用时，要先运行服务器端，然后运行客户端。</p><p>如果修改了配置文件，那么运行服务器时，要在./redis-server.exe 后加上 配置文件路径 redis.window.conf，让redis重新加载该配置文件。</p><p>Windows版本的Redis不支持后台启动。</p><p><strong>不要将Redis添加到Windows服务，会出错，很痛苦。</strong></p><h3 id="Linux下使用"><a href="#Linux下使用" class="headerlink" title="Linux下使用"></a>Linux下使用</h3><p>Linux和Windows文件一样。</p><p>Linux启动redis有两种方式：</p><ul><li>前台启动    ./redis-server：启动后，该终端不能输入其他命令，也不能关闭，只能运行redis-sever</li><li>后台启动   ./redis-server &amp;：启动后，终端可以继续输入其他命令</li></ul><p>一般使用后台启动。</p><p>Linux关闭redis服务也有两种方式：</p><ul><li>在redis客户端使用shutdown命令关闭。这种关闭方式，redis会先执行完数据操作，再关闭服务器</li><li>直接使用kill命令杀死进程。不推荐这种方式，有可能会造成数据丢失</li></ul><h2 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h2><p>Redis客户端是一个程序，通过网络连接到Redis服务器，在客户端软件中使用Redis可以识别的命令，向Redis服务器发送命令。</p><p>就是和Redis服务器进行交互的工具。</p><p>redis-cli.exe是Redis自带的命令行客户端。</p><p>有两种连接reids服务器的方式</p><ul><li><p>直接运行redis-cli.exe，这时，默认使用ip 127.0.0.1 端口6379</p></li><li><p>运行redis-cli.exe，使用选项连接服务器，-h 主机   -p  端口，例如</p><p>  <code>./redis-cli -h 127.0.0.1 -p 6379</code></p></li></ul><p>连接远程Redis服务器，还需要修改服务器端配置文件，因为Redis有安全保护措施，默认只有本机才可以访问。</p><p>修改两个地方：</p><ul><li>bind ip ：用来绑定ip，即只有该ip才可以访问Redis。注释掉该行。</li><li>protected-mode yes：设置保护模式，改为no</li></ul><p>需要重新加载redis配置文件。</p><h2 id="Redis日志"><a href="#Redis日志" class="headerlink" title="Redis日志"></a>Redis日志</h2><p>在redis的配置文件中可以配置Redis的日志级别和日志输出路径</p><h3 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a>loglevel</h3><p>loglevel配置项用来配置输出日志级别，有四个级别：</p><ul><li>debug：会打印很多信息，适用于开发和测试阶段</li><li>verbose：比debug清爽一点</li><li>notice：适用于生产环境，<strong>默认值。</strong></li><li>warning：警告信息</li></ul><p>开发时，可以使用debug，在生产环境使用notice</p><h3 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a>logfile</h3><p>logfile用来指定日志输出路径。</p><p>使用双引号来指定路径，例如<code>logfile &quot;D:/logs/redis.log&quot;</code></p><p>如果注释掉该行，那么默认输出到控制台。</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
      <category>Redis</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>后端</tag>
      
      <tag>Redis</tag>
      
      <tag>缓存数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12-SpringBoot集成logBack</title>
    <link href="/2022/05/11/SpringBoot/12-SpringBoot%E9%9B%86%E6%88%90logBack/"/>
    <url>/2022/05/11/SpringBoot/12-SpringBoot%E9%9B%86%E6%88%90logBack/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot官方推荐优先使用带有<code>-spring</code>的文件名作为日志配置(如使用logback-spring.xml)，默认放在src/main/resources目录下。如果不想用默认文件名格式和默认目录，可以通过配置文件的<code>logging.config</code>属性来指定自定义的名字。</p><p><code>logging-config=classpath:logging-config.xml</code>。</p><p>日志内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!-- 日志级别从低到高分为 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，</span><br><span class="hljs-comment">如果设置为 WARN，则低于 WARN 的信息都不会输出 --&gt;</span><br><span class="hljs-comment">&lt;!-- scan:当此属性设置为 true 时，配置文件如果发生改变，将会被重新加载，默认值为</span><br><span class="hljs-comment">true --&gt;</span><br><span class="hljs-comment">&lt;!-- scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认</span><br><span class="hljs-comment">单位是毫秒。当 scan 为 true 时，此属性生效。默认的时间间隔为 1 分钟。 --&gt;</span><br><span class="hljs-comment">&lt;!-- de<span class="hljs-doctag">bug:</span>当此属性设置为 true 时，将打印出 logback 内部日志信息，实时查看 logback</span><br><span class="hljs-comment">运行状态。默认值为 false。通常不打印 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;100 seconds&quot;</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--输出到控制台--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--此日志 appender 是为开发使用，只配置最底级别，控制台输出的日志级别是大</span><br><span class="hljs-comment">       于或等于此级别的日志信息--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">level</span>&gt;</span>debug<span class="hljs-tag">&lt;/<span class="hljs-name">level</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            %date:时间，精确到毫秒,%d也可以</span><br><span class="hljs-comment">            %-5p:日志级别，-代表左对齐，5代表占位符有5个</span><br><span class="hljs-comment">            %thread:表示哪个线程输出的日志</span><br><span class="hljs-comment">            %logger(60):代表类路径，60表示最长字符串长度</span><br><span class="hljs-comment">            %file:表示文件名</span><br><span class="hljs-comment">            %line:行数</span><br><span class="hljs-comment">            %msg:表示日志信息</span><br><span class="hljs-comment">            %n:换行符</span><br><span class="hljs-comment">          --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Pattern</span>&gt;</span>%d [%-5p] %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">Pattern</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 设置字符集 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--输出到文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;File&gt;/home/log/stdout.log&lt;/File&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">File</span>&gt;</span>D:/log/stdout.log<span class="hljs-tag">&lt;/<span class="hljs-name">File</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">            %date:时间，精确到毫秒</span><br><span class="hljs-comment">            %-5p:日志级别，-代表左对齐，5代表占位符有5个</span><br><span class="hljs-comment">            %thread:表示哪个线程输出的日志</span><br><span class="hljs-comment">            %logger(60):代表类路径，60表示最长字符串长度</span><br><span class="hljs-comment">            %file:表示文件名</span><br><span class="hljs-comment">            %line:行数</span><br><span class="hljs-comment">            %msg:表示日志信息</span><br><span class="hljs-comment">            %n:换行符</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%date [%-5p] [%thread] %logger&#123;60&#125;<br>                [%file : %line] %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 添加.gz 历史日志会启用压缩 大大缩小日志文件所占空间 --&gt;</span><br><br>            <span class="hljs-comment">&lt;!--&lt;fileNamePattern&gt;/home/log/stdout.log.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNam</span><br><span class="hljs-comment">            ePattern&gt;--&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>D:/log/stdout.log.%d&#123;yyyy-MM-dd&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><span class="hljs-comment">&lt;!-- 保留 30 天日志 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--单个设置，设置数据持久层的level--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.abc.springboot.mapper&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!--使用root标签引用，才能生效。全局设置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>如果要自己打印日志。需要引入lombok依赖，在需要打印的类上加注解<code>@Slf4j</code>。</p><p>然后使用该依赖的<code>log</code>来打印不同级别的日志。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210127151636088.png" alt="image-20210127151636088" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11-Thymeleaf</title>
    <link href="/2022/05/11/SpringBoot/11-Thymeleaf/"/>
    <url>/2022/05/11/SpringBoot/11-Thymeleaf/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>Thymeleaf是一个模板引擎，采用Java开发。</p><p>Thymeleaf对网络环境要求不严格，既能用于Web环境，也能用于非Web环境。在非Web环境(即不开启服务器，只打开该文件)下，可以直接显示模板的静态数据；在Web环境下，可以像JSP一样从后台接受数据，并替换掉模板的静态数据，它是基于HTML的，以HTML为载体，Thymeleaf要寄托在HTML标签下才可以实现。</p><p>SpringBoot集成了Thymeleaf技术，SpringBoot官方也推荐使用Thymeleaf来代替JSP技术。但它本身并不属于SpringBoot。</p><p>该模板文件可以直接在任何浏览器内正确显示，浏览器会自动忽略不能理解的属性。但是这并不是一个真正有效的HTML5文档，因为HTML5文档没有<code>th:*</code>这些非标准属性的。需要Thymeleaf解析后才会变成一个标准的HTML文档。</p><h2 id="Thymeleaf的简单使用"><a href="#Thymeleaf的简单使用" class="headerlink" title="Thymeleaf的简单使用"></a>Thymeleaf的简单使用</h2><p>首先要加入Thymeleaf的起步依赖，可以在创建SpringBoot项目时就直接添加该依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后创建html文件，并且需要在文件中添加：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;html xmlns:<span class="hljs-attribute">th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>即html文件变成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>并且默认将该模板文件放在resources/templates目录中，将其他静态资源文件如js，css，图片等放在resources/static目录中。</p><h2 id="Thymeleaf基础语法"><a href="#Thymeleaf基础语法" class="headerlink" title="Thymeleaf基础语法"></a>Thymeleaf基础语法</h2><p>所有有关Thymeleaf的属性开头都是<code>th:*</code>，<code>*</code>代表任意属性。有些浏览器不支持该写法。也可以使用<code>data-th-*</code>来代替<code>th:*</code>语法。</p><h3 id="显示文本"><a href="#显示文本" class="headerlink" title="显示文本"></a>显示文本</h3><p>使用<code>th:text</code>和<code>th:utext</code>来显示数据。</p><p>两者不同是：</p><p><code>th:text</code>属性不解析html元素，传来什么数据就显示什么数据。</p><p><code>th:utext</code>属性将解析HTML元素。如传来的数据是<code>&lt;p&gt;一个段落&lt;/p&gt;</code>，那么该属性会识别到<p>是一个html标签，进行解析。</p><h3 id="简单表达式"><a href="#简单表达式" class="headerlink" title="简单表达式"></a>简单表达式</h3><div class="table-container"><table><thead><tr><th>语法</th><th>描述</th><th>作用</th></tr></thead><tbody><tr><td><code>$&#123;..&#125;</code></td><td>变量表达式</td><td>取出上下文变量的值</td></tr><tr><td><code>*&#123;..&#125;</code></td><td>选择变量表达式</td><td>取出选择的对象的属性值</td></tr><tr><td><code>#&#123;..&#125;</code></td><td>消息表达式</td><td>能够从外部源(.properties文件)获得属性值，一般用于国际化消息</td></tr><tr><td><code>@&#123;..&#125;</code></td><td>链接表达式</td><td>用于表示各种超链接地址</td></tr><tr><td><code>~&#123;..&#125;</code></td><td>片段表达式</td><td>引用一段公共的代码片段</td></tr></tbody></table></div><h4 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h4><p>语法：${变量名}</p><p>说明：标准变量表达式用于访问容器上下文环境的变量。Thymeleaf使用变量表达式来获取Controller传过来的Model中的数据。</p><p>可以是简单变量String，Integer，这时候直接使用变量名即可。</p><p>也可以是引用变量，这时候要使用${变量名.属性名}的方式。</p><p><code>$&#123;..&#125;</code>的作用域是面向整个上下文。</p><p>一个例子：</p><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/thymeleaf&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getIndex</span><span class="hljs-params">(Model model)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setId(<span class="hljs-number">1</span>);<br>    user.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br>    user.setAddress(<span class="hljs-string">&quot;河北省石家庄市&quot;</span>);<br>    model.addAttribute(<span class="hljs-string">&quot;data&quot;</span>, <span class="hljs-string">&quot;测试Thymeleaf成功&quot;</span>);<br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>html文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;data&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    用户的ID是:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.id&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    用户的姓名是:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    用户的地址是:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$&#123;user.address&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210123193016754.png" alt="image-20210123193016754" style="zoom:50%;" /></p><h4 id="选择变量表达式"><a href="#选择变量表达式" class="headerlink" title="选择变量表达式"></a>选择变量表达式</h4><p>不推荐使用。</p><p>语法：*{…}</p><p>说明：也叫星号变量表达式。使用<code>th:object</code>属性来绑定对象。</p><p>然后使用<code>*</code>来代表这个对象，<code>*</code>后面的<code>&#123;&#125;</code>中的值时此对象的属性。</p><p>选择变量表达式<code>*&#123;..&#125;</code>类似于标准变量表达式<code>$&#123;..&#125;</code>表示变量的写法。</p><p>选择变量表达式是在执行时在选择的对象上求解，而标准变量表达式是在上下文的Model上求解。</p><p>这种写法比较繁琐，不推荐使用。</p><p>选择变量表达式<code>*&#123;..&#125;</code>的作用域是父标签<code>th:object</code>。</p><p>例子：</p><p>控制器方法不用改，html文件改为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Thymeleaf<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;data&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:object</span>=<span class="hljs-string">&quot;$&#123;user&#125;&quot;</span>&gt;</span><br>        用户ID:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;id&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        用户姓名:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;name&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        用户地址:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;*&#123;getAddress()&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也可以不使用<code>th:object</code>绑定对象，直接使用<code>*&#123;变量名.属性名&#125;</code>，和<code>$&#123;&#125;</code>用法一样。</p><h4 id="消息表达式"><a href="#消息表达式" class="headerlink" title="消息表达式"></a>消息表达式</h4><p>消息表达式<code>#&#123;..&#125;</code>用于国际化文字信息，也就是根据语言改变显示文字，<code>.properteis</code>文件命名规则一般是：</p><ul><li><code>basename.properties</code></li><li><code>basename_language.properties</code></li><li><code>basename_language_country.properties</code></li></ul><p>其中：basename是自定义的资源文件名称，language和country是Java支持的语言和国家。如中国中文是<code>messages_zn_CN.properties</code>。</p><p><code>basename.properties</code>是缺省加载的资源文件，当客户端根据本地语言查找不到相关资源文件，则使用该配置文件。</p><p>资源文件应该放在resources目录中。</p><p>SpringBoot加载资源文件的默认名称是messages。并且默认放在resources目录中。如果放在其他目录或者名称不是messages，那么在<code>application.properties</code>中修改<code>spring.messages.basename</code>属性来修改。如放在resources/i18n目录中，basename是message，那么属性应变为<code>spring.messages.basebame=i18n/message</code>。</p><h5 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h5><p>创建一个资源文件文件名为<code>messages_zn_CH.properties</code>：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">welcome.message</span>=<span class="hljs-string">欢迎你!</span><br></code></pre></td></tr></table></figure><p>在html文件中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;welcome.message&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就可以调用到属性值。</p><h5 id="使用占位符"><a href="#使用占位符" class="headerlink" title="使用占位符"></a>使用占位符</h5><p>消息表达式<code>#&#123;..&#125;</code>不允许直接处理静态文本消息，例如调用变量。但是可以在资源文件中使用占位符<code>&#123;&#125;</code>来处理费静态文本消息：</p><p>资源文件配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">welcome.message</span>=<span class="hljs-string">&#123;0&#125;, 欢迎你!</span><br><span class="hljs-attr">encoding</span>=<span class="hljs-string">&#123;0&#125;</span><br></code></pre></td></tr></table></figure><p>然后在html中以参数形式传递变量：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;welcome.message(&#x27;Jack&#x27;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>字符编码是:<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;#&#123;encoding($&#123;#request.getCharacterEncoding()&#125;)&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果一个属性中有多个占位符，如<code>encoding=&#123;0&#125;   &#123;1&#125;</code>，那么在参数传递时，使用逗号<code>,</code>来分割不同参数。</p><p>即：`&lt;span th:text=”#{encoding(‘字符编码是:’,$</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-SpringBoot设置字符编码</title>
    <link href="/2022/05/11/SpringBoot/10-SpringBoot%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <url>/2022/05/11/SpringBoot/10-SpringBoot%E8%AE%BE%E7%BD%AE%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>配置字符编码有两种方式，一种是在application.properties中设置，另一种就是用传统的字符编码过滤器。</p><p>推荐使用第一种方式，这里也只介绍第一种方式。</p><p>非常简单，在application.properties设置三个属性即可。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#设置请求响应的字符编码</span><br><span class="hljs-attr">server.servlet.encoding.enabled</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">server.servlet.encoding.force</span>=<span class="hljs-string">true</span><br><span class="hljs-attr">server.servlet.encoding.charset</span>=<span class="hljs-string">UTF-8</span><br></code></pre></td></tr></table></figure><p>第一个属性作用是启用编码。</p><p>第二个属性作用是强制使用设置的编码。</p><p>第三个属性指定要使用的字符集。</p><p>设置这三个属性就可以了。</p><p>在之前版本使用的是<code>server.http...</code>，这个属性被弃用了，使用现在这个<code>server.servlet</code>.就可以。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-SpringBoot使用Servlet</title>
    <link href="/2022/05/11/SpringBoot/9-SpringBoot%E4%BD%BF%E7%94%A8Servlet/"/>
    <url>/2022/05/11/SpringBoot/9-SpringBoot%E4%BD%BF%E7%94%A8Servlet/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在SpringBoot中有两种方法可以直接使用Servlet。当然一般都直接使用控制器类。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>使用注解<strong>@WebServlet</strong>来标识该类是一个Servlet类可以被SpringBoot扫描到。</p><p>该注解有一个属性urlPatterns来表示该Servlet处理哪个或者哪些请求。</p><p>然后在主类Application上加上注解<strong>@ServletComponentScan(“包路径”)</strong>，使用SpringBoot能够扫描到该Servlet。</p><p>例子：<br>创建一个Servlet类，继承HttpServlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/springboot/sayHello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5556813722982445881L</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> resp.getWriter();<br>        pw.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> resp.getWriter();<br>        pw.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在主类上加上注解<strong>@ServletComponentScan(“包路径”)</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ServletComponentScan(basePackages = &quot;com.example.demo.controller&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(DemoApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>就可以了。</p><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>第二种方式是使用配置类。</p><p>首先创建一个关于注册Servlet的配置类。并在该类上加上注解@Configuration</p><p>并创建一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServletConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title function_">httpServletRegistrationBean</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-type">ServletRegistrationBean</span> <span class="hljs-variable">servletRegistrationBean</span><br>                <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServlet</span>(),<span class="hljs-string">&quot;/springboot/sayHello&quot;</span>);<br>        <span class="hljs-keyword">return</span> servletRegistrationBean;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在方法上加上注解@Bean。该注解表示将该方法交给Spring容器管理。即该方法会产生一个对象，Spring容器将管理该对象。</strong></p><p><strong>@Bean注解只能在@Configuration注解下使用。</strong></p><p><strong>SerlvetRegistrationBean表示一个Servlet注册类对象。</strong></p><p><strong>在该方法中创建该对象，并将Servlet对象和该Servlet对象要处理的请求url作为参数。最后返回该对象。</strong></p><p>当然直接使用Servlet很少用，一般直接用控制器。</p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-过滤器Filter</title>
    <link href="/2022/05/11/SpringBoot/8-%E8%BF%87%E6%BB%A4%E5%99%A8Filter/"/>
    <url>/2022/05/11/SpringBoot/8-%E8%BF%87%E6%BB%A4%E5%99%A8Filter/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot使用过滤器有两种方式。一种是通过注解，另一种使用配置类。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>首先创建过滤器类，实现接口Filter。</p><p>使用<strong>@WebFilter</strong>注解，放在过滤器类上。该注解有一个参数urlPatterns，用来指定要过滤的请求url。</p><p>然后在启动类Application上加上注解<strong><code>@ServletComponentScan(basePackages = &quot;包路径&quot;)</code></strong></p><p>让SpringBoot扫描到过滤器类。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br> chain.doFilter(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在启动类加上注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ServletComponentScan(basePackages = &quot;com.example.demo.filter&quot;)</span><br><span class="hljs-meta">@SpringBootApplication</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoApplication</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(DemoApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以使用过滤器了。</p><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>创建配置类并加上@Configuration注解来配置过滤器类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    FilterRegistrationBean <span class="hljs-title function_">filterRegistrationBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">FilterRegistrationBean</span> <span class="hljs-variable">filterRegistrationBean</span><br>                <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterRegistrationBean</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFilter</span>());<br>        filterRegistrationBean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-keyword">return</span> filterRegistrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在配置类中创建一个方法，用来注册过滤器类，并通过@Bean注解交给Spring容器管理。</p><p>FilterRegistrationBean类用来实现注册过滤器类。创建该对象，将Filter对象作为参数传给该对象构造器，并调用<code>addUrlPatterns()</code>方法设置该过滤器的拦截请求URL。</p><p>通过该对象的<code>setOrder(int order)</code>方法来设置过滤器的优先顺序。</p><p>参数是int类型，数字越小优先级越高。可以从数字1开始。</p><p>也可以使用@Order(value=””)注解放到该方法上，来指定优先级。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><strong>注意</strong></h2><ul><li><p><strong>如果要设置优先级，则只能使用配置类方法来配置过滤器。注解方式无法设置优先级。(哪怕在过滤器类上加上@Order注解，也不起作用)。</strong></p></li><li><p><strong>注册几个过滤器就需要写几个方法，分别加上@Bean注解。</strong></p></li><li><p><strong>千万别忘了写<code>chain.doFilter(request, response);</code></strong></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-拦截器Interceptor</title>
    <link href="/2022/05/11/SpringBoot/7-%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor/"/>
    <url>/2022/05/11/SpringBoot/7-%E6%8B%A6%E6%88%AA%E5%99%A8Interceptor/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在SpringMVC中使用拦截器方法是创建拦截器类实现HandlerInterceptor接口，并在springmvc配置文件中注册该拦截器。</p><p>而在SpringBoot中，使用方法稍微变动了一下。</p><ol><li>创建拦截器类并实现HandlerInterceptor接口，并编写相关代码</li><li>在config包中创建配置类，并使用注解@Configuration来进行配置。配置类要实现WebMvcConfigurer接口</li></ol><p>第一步不具体说了，详细说明在SpringMVC笔记中有。</p><p>重点说一下第二步。</p><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>在SpringMVC中，配置拦截器是在springmvc配置文件中设置的。那么在SpringBoot中没有配置文件。就是用注解来进行配置。</p><p>首先创建一个配置类，并实现WebMvcConfigurer。并在该类加上注解@Configuration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorConfig</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在该类中重写WebMvcConfigurer接口的<code>addInterceptors</code>方法，该方法是用来注册拦截器类的。</p><p>该方法有一个形参，<code>InterceptorRegistry registry</code>，就是用来添加拦截器类的。</p><p>InterceptorRegistry类有三个方法：</p><ul><li><code>InterceptorRegistration addInterceptor(HandlerInterceptor)</code>：该方法用来添加拦截器对象，参数是一个拦截器对象，返回值是 InterceptorRegistration对象。</li><li><code>InterceptorRegistration addWebRequestInterceptor(WebRequestInterceptor interceptor)</code>：该方法用来添加继承了WebRequestInterceptor接口的拦截器对象，该接口和HandlerInterceptor的不同是：<ol><li>WebRequestInterceptor的形参WebRequest包装了HttpServletRequest和HttpServletResponse</li><li>WebRequestInterceptor的preHandle方法没有返回值，说明该方法逻辑并不影响后续执行。所以该接口实现就是为了获取Request的信息。</li><li>HandlerInterceptor的功能更加强大也更基础。</li></ol></li><li><code>List&lt;Object&gt; getInterceptors()</code>：该方法用来获取所有已注册的拦截器。</li></ul><p>其中InterceptorRegistration对象是用来进一步设置该拦截器的信息的，例如需要拦截的URL，不需要拦截的URL等。</p><p>该类所有的方法：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210123133210172.png" alt="image-20210123133210172" style="zoom:50%;" /></p><p>使用addPathPatterns方法来设置需要拦截的URL，使用excludePathPatterns方法来设置不需要拦截的URL。</p><p>形参是String数组或者List集合。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterceptorConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br><br>        String[] addPathPatterns = &#123;<br>                <span class="hljs-string">&quot;/spring/**&quot;</span>,<span class="hljs-string">&quot;/springboot/**&quot;</span><br>        &#125;;<br>        String[] excludePathPatterns = &#123;<br>                <span class="hljs-string">&quot;/spring/login&quot;</span>,<span class="hljs-string">&quot;/springboot/login&quot;</span><br>        &#125;;<br><br>        <span class="hljs-type">InterceptorRegistration</span> <span class="hljs-variable">interceptorRegistration</span> <span class="hljs-operator">=</span><br>                registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInterceptor</span>());<br>        interceptorRegistration.addPathPatterns(addPathPatterns);<br>        interceptorRegistration.excludePathPatterns(excludePathPatterns);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就完成了拦截器的注册。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>@Configuration注解就相当于xml文件，重写方法相当于写具体的代码。</p><p>多个拦截器，在一个方法内使用同一个<code>InterceptorRegistry registry</code>对象多次添加即可。每添加一个拦截器对象，就返回一个InterceptorRegistration，通过该对象的<code>order(int order)</code>方法可设置拦截器执行顺序，数字越小优先级越高。</p><p>顺序只针对拦截器的preHandle方法。</p><p>对于postHandle方法和afterCompletion方法顺序刚好和preHandle方法是反着的。</p><p>因为每执行一个preHandle方法，就将对应的postHandle方法和afterCompletion方法放入相应栈中。所以执行的时候先放进去的后执行。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-SpringBoot集成Redis</title>
    <link href="/2022/05/11/SpringBoot/6-SpringBoot%E9%9B%86%E6%88%90Redis/"/>
    <url>/2022/05/11/SpringBoot/6-SpringBoot%E9%9B%86%E6%88%90Redis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>集成Redis很简单。</p><ol><li>添加依赖</li><li>在application.properties中配置redis</li><li>使用RedisTemplate类操作Redis</li></ol><h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><p>首先添加SpringBoot的Redis起步依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-pool2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>commons-pools是一个连接池，用来管理Redis连接对象。</p><h2 id="配置Redis"><a href="#配置Redis" class="headerlink" title="配置Redis"></a>配置Redis</h2><p>在application.properties中配置Redis：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">## 是否启动日志SQL语句</span><br><span class="hljs-attr">spring.jpa.show-sql</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"># Redis 数据库索引（默认为 0）</span><br><span class="hljs-attr">spring.redis.database</span>=<span class="hljs-string">0</span><br><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-comment"># Redis 服务器连接密码（默认为空）</span><br><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string"></span><br><span class="hljs-comment"># springboot 2.0 redis默认客户端已换成lettuce</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"># 连接池最大连接数（使用负值表示没有限制） 默认 8</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-active</span>=<span class="hljs-string">8</span><br><span class="hljs-comment"># 连接池最大阻塞等待时间（使用负值表示没有限制） 默认 -1</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-wait</span>=<span class="hljs-string">-1</span><br><span class="hljs-comment"># 连接池中的最大空闲连接 默认 8</span><br><span class="hljs-attr">spring.redis.lettuce.pool.max-idle</span>=<span class="hljs-string">8</span><br><span class="hljs-comment"># 连接池中的最小空闲连接 默认 0</span><br><span class="hljs-attr">spring.redis.lettuce.pool.min-idle</span>=<span class="hljs-string">0</span><br><span class="hljs-attr">spring.redis.timeout</span>=<span class="hljs-string">5000</span><br></code></pre></td></tr></table></figure><p>分别是要连接的Redis服务器，端口号， 和密码(没有密码可以不写此项)。</p><h2 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h2><p>redisTemplate在存取数据时，会进行序列化和反序列化。就是把要存取的Java对象序列化和反序列化。</p><p>有几种序列器：</p><ul><li><p>JdkSerializationRedisSerializer：POJO对象的存取场景，使用JDK本身序列化机制，将pojo类通过ObjectInputStream/ObjectOutputStream进行序列化操作，最终redis-server中将存储字节序列。是默认的序列化策略。</p></li><li><p>StringRedisSerializer：Key或者value为字符串的场景，根据指定的charset对数据的字节序列编码成string，是“new String(bytes, charset)”和“string.getBytes(charset)”的直接封装。是最轻量级和高效的策略。</p></li><li><p>Jackson2JsonRedisSerializer：jackson-json工具提供了javabean与json之间的转换能力，可以将pojo实例序列化成json格式存储在redis中，也可以将json格式的数据转换成pojo实例。因为jackson工具在序列化和反序列化时，需要明确指定Class类型，因此此策略封装起来稍微复杂。【需要jackson-mapper-asl工具支持】</p></li><li><p>GenericFastJsonRedisSerializer：另一种javabean与json之间的转换，同时也需要指定Class类型。</p></li><li><p>OxmSerializer：提供了将javabean与xml之间的转换能力，目前可用的三方支持包括jaxb，apache-xmlbeans；redis存储的数据将是xml工具。不过使用此策略，编程将会有些难度，而且效率最低；不建议使用。【需要spring-oxm模块的支持】</p></li></ul><p>通过使用这几种序列化方式，可以自定义想如何序列化。</p><p>例如想让key的value使用Json序列化方式，就可以设置Jackson2JsonRedisSerializer或GenericFastJsonRedisSerializer。</p><p>注意使用Jackson时，记得导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.datatype<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-datatype-jsr310<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以不创建Redis配置类，使用SpringBoot默认的配置，也可以创建Redis配置类，自定义如何序列化、反序列化等配置。</p><h2 id="使用默认RedisTemplate操作Redis"><a href="#使用默认RedisTemplate操作Redis" class="headerlink" title="使用默认RedisTemplate操作Redis"></a>使用默认RedisTemplate操作Redis</h2><p>在服务类中使用@Resource或者@Autowired自动注入RedisTemplate对象。</p><p>该类时用来操作Redis的。</p><p>SpringBoot会自动配置RedisTemplate。</p><p>举个例子(例子中，RedisTemplate在控制器类中自动注入，但实际开发一般都是在服务层Service类中自动注入。这里只是为了演示)。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;<br><br><br><span class="hljs-meta">@PostMapping(value = &quot;/put&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">putRedis</span><span class="hljs-params">(String key, String value)</span> &#123;<br>    redisTemplate.opsForValue().set(key, value);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功插入数据,key:&quot;</span> + key + <span class="hljs-string">&quot;, value:&quot;</span> + value;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(value = &quot;/get&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getRedis</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;key:&quot;</span> + key + <span class="hljs-string">&quot;对应的value为:&quot;</span> +<br>            redisTemplate.opsForValue().get(key);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>一个是插入数据，一个是获取数据。</p><p>可以使实体类实现Serializable序列化接口。然后就可以将Java对象存入到Redis中。</p><p>例如：<br>实体类Student：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>        <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> String email;<br><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">//set和get方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>处理器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> StudentService studentService;<br><br>   <span class="hljs-meta">@Resource</span><br>   <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;    <br><br><br><span class="hljs-meta">@GetMapping(value = &quot;/get/&#123;id&#125;&quot;)</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getRedis</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> studentService.queryStudentById(id);<br>       redisTemplate.opsForValue().set(<span class="hljs-string">&quot;student1&quot;</span>, student);<br>       <span class="hljs-keyword">return</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;student1&quot;</span>);<br><br>   &#125;<br></code></pre></td></tr></table></figure><p>SpringBoot提供的Redis依赖有默认的序列化工具和反序列化。</p><p>处理器返回的就是一个Stuent对象。</p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>创建配置类RedisConfig。</p><p>注意，这时候使用自动注入，变量名要写返回RedisTemplate对象的方法名，这里使用的是redis。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableCaching</span> <span class="hljs-comment">//开启注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CachingConfigurerSupport</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * retemplate相关配置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> factory</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="hljs-title function_">redis</span><span class="hljs-params">(RedisConnectionFactory factory)</span> &#123;<br><br>        RedisTemplate&lt;String, Object&gt; template = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>&lt;&gt;();<br>        <span class="hljs-comment">// 配置连接工厂</span><br>        template.setConnectionFactory(factory);<br><br>        <span class="hljs-comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span><br>        <span class="hljs-type">Jackson2JsonRedisSerializer</span> <span class="hljs-variable">jacksonSeial</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jackson2JsonRedisSerializer</span>(Object.class);<br><br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span><br>        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);<br><br>        <span class="hljs-comment">//使用Jackson2Json无法正确反序列LocalDateTime，需要手动添加模块</span><br>        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);<br>        om.registerModule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaTimeModule</span>());<br><br>        <span class="hljs-comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span><br>        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);<br>        jacksonSeial.setObjectMapper(om);<br><br>        <span class="hljs-comment">// 值采用json序列化</span><br>        template.setValueSerializer(jacksonSeial);<br>        <span class="hljs-comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span><br>        template.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br><br>        <span class="hljs-comment">// 设置hash key 和value序列化模式</span><br>        template.setHashKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        template.setHashValueSerializer(jacksonSeial);<br><br>        <span class="hljs-comment">// 设置支持事务</span><br>        template.setEnableTransactionSupport(<span class="hljs-literal">true</span>);<br>        template.afterPropertiesSet();<br><br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对hash类型的数据操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisTemplate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> HashOperations&lt;String, String, Object&gt; <span class="hljs-title function_">hashOperations</span><span class="hljs-params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForHash();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对redis字符串类型数据操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisTemplate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ValueOperations&lt;String, Object&gt; <span class="hljs-title function_">valueOperations</span><span class="hljs-params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForValue();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对链表类型的数据操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisTemplate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ListOperations&lt;String, Object&gt; <span class="hljs-title function_">listOperations</span><span class="hljs-params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForList();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对无序集合类型的数据操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisTemplate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SetOperations&lt;String, Object&gt; <span class="hljs-title function_">setOperations</span><span class="hljs-params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForSet();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 对有序集合类型的数据操作</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisTemplate</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ZSetOperations&lt;String, Object&gt; <span class="hljs-title function_">zSetOperations</span><span class="hljs-params">(RedisTemplate&lt;String, Object&gt; redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> redisTemplate.opsForZSet();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：反序列化LocalDateTime时，Jackson2是无法反序列的，需要手动添加模块。详细看上面代码。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-RestFul和SpringMVC常用注解</title>
    <link href="/2022/05/11/SpringBoot/5-RestFul%E5%92%8CSpringMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/05/11/SpringBoot/5-RestFul%E5%92%8CSpringMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在SpringBoot中使用SpringMVC和直接使用SpringMVC没有任何不同，完全一样。</p><p>有几个常用的注解。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><p>SpringMVC的注解，处理http请求。</p><h3 id="RestController"><a href="#RestController" class="headerlink" title="RestController"></a>RestController</h3><p>SpringMVC4.0的新增注解，是@Controller注解功能的增强，相当于@Controller和@ResponseBody的组合注解。</p><p>如果一个Controller添加了@RestController，那么就相当于该Controller的所有方法都添加了@ResponseBody注解。</p><p>主要用于返回字符串或JSON数据。</p><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h3><p>支持Get和Post请求。</p><h3 id="GetMapping"><a href="#GetMapping" class="headerlink" title="@GetMapping"></a>@GetMapping</h3><p>只支持Get请求，别的请求方式会报错，405。Get请求主要用于查询操作。</p><h3 id="PostMapping"><a href="#PostMapping" class="headerlink" title="@PostMapping"></a>@PostMapping</h3><p>只支持Post请求，别的请求方式会报错，405。Post请求主要用于新增操作。</p><h3 id="PutMapping"><a href="#PutMapping" class="headerlink" title="@PutMapping"></a>@PutMapping</h3><p>只支持Put请求，别的请求方式会报错，405。Put请求主要用于修改数据。</p><h3 id="DeleteMapping"><a href="#DeleteMapping" class="headerlink" title="@DeleteMapping"></a>@DeleteMapping</h3><p>只支持Delete请求，别的请求方式会报错，405。Delete请求主要用于删除数据。</p><h2 id="RESTFul"><a href="#RESTFul" class="headerlink" title="RESTFul"></a>RESTFul</h2><p>REST是一种互联网软件架构设计的风格。但它不是标准的，只是提出了一个客户端和服务器交互时的架构理念和设计原则。基于这种理念和原则设计的接口可以更简洁，尺寸更小。任何技术都可以实现这种理念，如果一个架构符合REST原则，就称其为RESTFul架构。</p><p>这种架构简单来说，就是：</p><ul><li><p>接口命名使用名词，不要有动词。</p><p>  例如/student，/users等都属于RESTFul架构。而/addStudent，/deleteUser则不属于。</p></li><li><p>使用Http的方法来表示不同操作。</p><p>  因为没有动词在接口名称中，所以使用HTTP方法来表示要对数据进行的操作。一般来说：</p><ol><li>Get方法表示查询或者请求数据</li><li>Post方法表示新增数据。(也可以表示修改数据)</li><li>Put方法表示修改数据。</li><li>Delete方法表示删除数据</li></ol></li><li><p>使用status状态码来表示请求的结果。</p></li></ul><p>例如一个Http接口：<code>http://localhost/boot/order?id=1021&amp;status=1</code>，</p><p>那么采用RESTful风格则http地址应为：<code>http://localhost/boot/order/1021/status=1</code></p><p><strong>将参数转换为请求路径。</strong></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>轻量，直接基于Http，而不需要任何别的消息协议。</li><li>面向资源，一目了然。</li><li>数据描述简单，一般以xml，json做数据交换</li><li>简单，低重组。</li></ol><h3 id="RESTFul注意的地方"><a href="#RESTFul注意的地方" class="headerlink" title="RESTFul注意的地方"></a>RESTFul注意的地方</h3><ol><li>请求路径中不要出现动词</li><li>分页，排序等操作，一般使用参数来进行传递</li></ol><p>采用RESTful风格要使用的一个注解是：@PathVariable</p><p>该注解可以将URL中的占位符参数{xxx}绑定到处理器类方法的形参@PathVariable(“xxx”)中。</p><p>例如：</p><p>一个处理器方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/student/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> &#123;<br>    <span class="hljs-keyword">return</span> studentService.queryStudentById(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>那么当浏览器发送请求比如：<code>http://localhost/student/1010</code>时，就会把1010这个值绑定到处理器方法的形参id上。</p><p>只要保证注解@PathVariable中属性值和请求路径中占位符参数值一致。</p><p>当然也可以绑定多个，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(value = &quot;/student/&#123;id&#125;/&#123;name&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getStudent</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id,<span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String name)</span> &#123;<br>    <span class="hljs-keyword">return</span> studentService.queryStudentById(id);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，加上之前讲的SpringMVC的常用注解，就可以实现RESTful风格。</p><p><strong>注意：当出现请求冲突，即一个请求路径对应了两个处理器方法，那么解决方法一是修改请求路径，二是修改请求方法。</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-SpringBoot集成MyBatis和事务</title>
    <link href="/2022/05/11/SpringBoot/4-SpringBoot%E9%9B%86%E6%88%90MyBatis%E5%92%8C%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/05/11/SpringBoot/4-SpringBoot%E9%9B%86%E6%88%90MyBatis%E5%92%8C%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="集成MyBatis"><a href="#集成MyBatis" class="headerlink" title="集成MyBatis"></a>集成MyBatis</h2><p>集成MyBatis很简单：</p><ol><li>添加依赖</li><li>配置文件中配置数据源</li><li>使用MyBatis逆向工程生成映射文件和实体类，DAO接口，并在接口类中添加注解@Mapper</li></ol><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>SpringBoot集成MyBatis，需要添加两个依赖：</p><ol><li>SpringBoot中MyBatis的起步依赖，这个依赖在spring-boot-dependencies中没有，需要手动指定版本号。这是MyBatis提供的依赖</li><li>MYSQL驱动依赖，不需要指定版本号，spring-boot-dependencies中已经设置好了。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h3><p>在application.properties配置文件中，配置数据源：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>在默认情况下，MyBatis的xml映射文件不会编译到target的class目录中，</p><p>所以在pom文件中的build标签中，添加编译xml文件，配置resource标签。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​    </p><h3 id="逆向工程生成DAO接口，映射文件和实体类"><a href="#逆向工程生成DAO接口，映射文件和实体类" class="headerlink" title="逆向工程生成DAO接口，映射文件和实体类"></a>逆向工程生成DAO接口，映射文件和实体类</h3><p>逆向工程需要配置GeneratorConfig.xml文件，具体详见MyBatis笔记。</p><p>在SSM项目中，有一个DAO组件扫描器注册在Spring配置文件中。</p><p>在SpringBoot项目中，使用@Mapper注解即可，表示将该对象加入到Spring容器中。</p><p>做完这三步，剩下就和SSM没什么区别了，正常使用。</p><h3 id="DAO另一种开发方式"><a href="#DAO另一种开发方式" class="headerlink" title="DAO另一种开发方式"></a>DAO另一种开发方式</h3><p>可以去掉DAO接口类的@Mapper接口</p><p>然后 运行的主类Application类上添加注解包扫描@MapperScan(basePackages=”com.example.demo.mapper”)</p><p>也可以去掉basePackages，直接写对应包路径。</p><h3 id="将接口和映射文件分开"><a href="#将接口和映射文件分开" class="headerlink" title="将接口和映射文件分开"></a>将接口和映射文件分开</h3><p>因为SpringBoot不能自动编译接口映射的xml文件，需要在pom.xml文件中手动指定。所以也可以将映射文件直接放在resources目录下，即在resources目录下新建目录mapper存放映射文件。</p><p>并在application.properties配置文件中，指定映射文件的位置，格式为：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span><br></code></pre></td></tr></table></figure><p>这个配置只有在接口和映射文件不在同一个包的情况下，才需要指定。</p><h3 id="使用Druid数据池"><a href="#使用Druid数据池" class="headerlink" title="使用Druid数据池"></a>使用Druid数据池</h3><p>使用阿里的Druid，那么就首先的pom文件中引入druid的springboot起步依赖，druid-spring-boot-starter，然后在配置文件中加入：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><span class="hljs-attr">spring.datasource.druid.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br><span class="hljs-attr">spring.datasource.druid.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.druid.password</span>=<span class="hljs-string"></span><br><span class="hljs-attr">spring.datasource.druid.max-active</span>=<span class="hljs-string">20</span><br></code></pre></td></tr></table></figure><p>就可以正常使用了。</p><h2 id="集成事务"><a href="#集成事务" class="headerlink" title="集成事务"></a>集成事务</h2><p>使用事务也非常简单。只需要在服务接口的继承类需要事务的方法上加上注解@Transactional。</p><p>就可以开启事务。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentService</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Student <span class="hljs-title function_">queryStudentById</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-keyword">return</span> studentMapper.selectByPrimaryKey(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Spring之前版本中还需要在启动类Application类上加上@EnableTransactionManagement，来开启事务。</p><p>但是在新版本中已经不需要了。所以这个注解加不加都行。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-SpringBoot使用JSP</title>
    <link href="/2022/05/11/SpringBoot/3-SpringBoot%E4%BD%BF%E7%94%A8JSP/"/>
    <url>/2022/05/11/SpringBoot/3-SpringBoot%E4%BD%BF%E7%94%A8JSP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot推荐使用Thymeleaf模板技术(后面会讲)。所以如果要使用JSP就要手动配置。</p><p>在之前的学习中，jsp文件都是放在webapp目录中的，而在刚创建好的SpringBoot项目中没有webapp目录，</p><p>所以要手动创建webapp目录并在Project Structure中将webapp目录设置为Web Resource 目录。</p><p>并添加相应依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--引入Spring Boot内嵌的Tomcat对JSP的解析包，不加解析不了jsp页面--&gt;</span><br><span class="hljs-comment">&lt;!--如果只是使用JSP页面，可以只添加该依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--如果要使用servlet必须添加该以下两个依赖--&gt;</span><br><span class="hljs-comment">&lt;!-- servlet依赖的jar包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- jsp依赖jar包--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--如果使用JSTL必须添加该依赖--&gt;</span><br><span class="hljs-comment">&lt;!--jstl标签依赖的jar包start--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后要手动指定jsp最后编译的路径。SpringBoot要求jsp文件必须要编译到META-INF/resources目录中才能访问到，否则访问不到。</p><p>在pom.xml中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bulid</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--源文件位置--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/webapp<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--指定编译到META-INF/resource，该目录不能随便写--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">targetPath</span>&gt;</span>META-INF/resources<span class="hljs-tag">&lt;/<span class="hljs-name">targetPath</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--指定要把哪些文件编译进去，**表示webapp目录及子目录，*.*表示所有文件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bulid</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在application.properties中配置SpringMVC的视图解析器。其实就相当于SpringMVC的配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 其中:/相当于src/main/webapp</span><br><span class="hljs-attr">spring.mvc.view.prefix</span>=<span class="hljs-string">/</span><br><span class="hljs-attr">spring.mvc.view.suffix</span>=<span class="hljs-string">.jsp</span><br></code></pre></td></tr></table></figure><p>所有这些配置完成以后，使用JSP就和之前一模一样了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用JSP步骤为：</p><ol><li>创建webapp目录，并在目录结构中指定该目录为Web Resources Directory</li><li>加入springboot的jsp依赖，以及servlet和servlet-jsp依赖，如要使用jstl，则加入jstl依赖</li><li>在apolication.properties中配置SpringMVC的视图解析器。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-SpringBoot核心配置文件</title>
    <link href="/2022/05/11/SpringBoot/2-SpringBoot%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2022/05/11/SpringBoot/2-SpringBoot%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot有两种核心配置文件格式，一种是<code>.properties</code>，另一种是<code>.yml</code>或<code>.yaml</code>格式。</p><p><strong>文件名必须是application。</strong></p><p>默认采用<code>.properties</code>格式。</p><h2 id="properties"><a href="#properties" class="headerlink" title=".properties"></a>.properties</h2><p>这种配置文件格式 使用的是键值对组合，即key：value型。</p><p>例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#设置内嵌Tomcat端口号</span><br><span class="hljs-attr">server.port</span>=<span class="hljs-string">80</span><br><span class="hljs-comment">#配置项目上下文根</span><br><span class="hljs-attr">server.servlet.context-path</span>=<span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p>通过这种方式来配置项目。</p><h2 id="yml"><a href="#yml" class="headerlink" title=".yml"></a>.yml</h2><p>yml是一种yaml格式的配置文件，采用<strong>一定的空格、换行</strong>等格式进行排版进行配置。</p><p>yaml是一种直观能被计算机识别的数据序列化格式，容易阅读，yaml类似xml，但是语法比xml简单。</p><p><strong>值和前面的冒号配置项之间必须有一个空格。</strong></p><p>yml后缀也可以改成yaml后缀。</p><p>例如：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">80</span> <span class="hljs-comment">#80和前面的冒号中必须有一个空格</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/</span><br></code></pre></td></tr></table></figure><p>当两种配置文件格式<code>.properties</code>和<code>.yml</code>同时存在，默认优先使用<code>.properties</code>格式文件。    </p><h2 id="多环境配置文件"><a href="#多环境配置文件" class="headerlink" title="多环境配置文件"></a>多环境配置文件</h2><p>在实际开发中项目会经历很多阶段：开发、测试、上线。每个阶段采用的配置也不一样，例如端口、上下文等。</p><p>为了环境配置切换方便，SpringBoot提供了多环境配置。</p><p>具体实现：</p><ol><li>为每个环境提供一个配置文件，命名格式必须为：application-环境标识.yml/properties</li><li>创建总的SpringBoot配置文件，applcation.yml/properties</li><li>在总的配置文件中指明是使用哪个环境的配置文件</li></ol><p>例如：</p><p>创建三个不同环境的配置文件：</p><p><code>application-dev.properties</code>(开发环境)、<code>application-test.properties</code>(测试环境)、<code>application-product.properties</code>(生产环境)。</p><p>然后在总配置文件中，指定要使用的配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#SpringBoot的总配置文件</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#激活开发环境</span><br><span class="hljs-comment">#spring.profiles.active=dev</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#激活测试环境</span><br><span class="hljs-comment">#spring.profiles.active=test</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">#激活生产环境</span><br><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">product</span><br></code></pre></td></tr></table></figure><p>等号右边的值和配置文件中环境标识名称一致。可以修改总配置文件的配置，重新运行main方法。</p><p>现在使用的是生产环境的配置文件。</p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>在核心配置文件中，除了内置的配置项外，还可以自定义配置，然后采用如下注解来读取</p><p>对应配置的属性值。</p><h3 id="Value"><a href="#Value" class="headerlink" title="@Value"></a>@Value</h3><p>该注解用于逐个读取配置文件中的配置。</p><p>例如：</p><p>在核心配置文件中加入自定义配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">name</span>=<span class="hljs-string">LiMing</span><br><span class="hljs-attr">address</span>=<span class="hljs-string">America</span><br></code></pre></td></tr></table></figure><p>然后在控制器中使用@Value注解将属性值注入变量中。</p><p><strong>使用<code>$&#123;自定义配置属性名&#125;</code>来获取配置属性的值。</strong></p><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootController</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;address&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/springboot/sayHello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我的名字是:&quot;</span> + name + <span class="hljs-string">&quot;, 地址是:&quot;</span> + address;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210121160701430.png" alt="image-20210121160701430" style="zoom:50%;" /></p><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><p>该注解将整个文件映射成一个对象，用于自定义配置项比较多的情况。</p><p>在config包中创建ConfigInfo类，并给该类加上@Component和@ConfigurationProperties注解。</p><p>必须指定prefix属性，表示前缀。prefix用来区分同名配置项。</p><p>例子：<br>修改application.properties配置文件，加上自定义配置项：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">student.name</span>=<span class="hljs-string">Lily</span><br><span class="hljs-attr">student.address</span>=<span class="hljs-string">America</span><br></code></pre></td></tr></table></figure><p>有前缀student。</p><p>在config包中创建ConfigInfo类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;student&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigInfo</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br>&#125;<br></code></pre></td></tr></table></figure><p>指定属性prefix属性值为前缀student。</p><p>然后在控制器中使用创建ConfigInfo对象，并使用@Autowired注解自动注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootController</span> &#123;<br><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ConfigInfo configInfo;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/springboot/sayHello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;我的名字是:&quot;</span> + configInfo.getName() + <span class="hljs-string">&quot;, 地址是:&quot;</span> + configInfo.getAddress();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用对象方法获取对应配置属性值。</p><p>注意：使用@ConfigurationProperties注解要加入SpringBoot注解处理器依赖，GAV坐标为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>另：在配置文件中，如果使用中文会出现乱码。一般也不建议在配置文件中出现中文。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-SpringBoot概述</title>
    <link href="/2022/05/11/SpringBoot/1-SpringBoot%E6%A6%82%E8%BF%B0/"/>
    <url>/2022/05/11/SpringBoot/1-SpringBoot%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>SpringBoot的设计目的是<strong>简化</strong>Spring应用的初始搭建和开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不需要定义样板化的配置。</p><p>在以往采用SpringMVC+Spring+MyBatis开发时，搭建和整合三大框架，需要做很多工作，配置web.xml。配置Spring和MyBatis。而SpringBoot框架对此开发过程进行了革命性颠覆，完全抛弃了繁琐的xml配置过程，采用大量默认配置来简化开发过程。</p><p>​        </p><h2 id="SpringBoot特性"><a href="#SpringBoot特性" class="headerlink" title="SpringBoot特性"></a>SpringBoot特性</h2><p>SpringBoot有这些特性：</p><ol><li>能够快速创建基于Spring的应用程序</li><li>能够直接使用java的main方法启动内嵌的Tomcat服务器运行SpringBoot程序，不用部署war包</li><li>提供约定的starter POM来简化Maven配置，使Maven配置更简单</li><li>自动化配置，根据项目Maven依赖配置，SpringBoot自动配置Spring、SpringMVC。</li><li>提供了程序的健康检查功能</li><li>基本不使用XML配置文件，采用注解配置</li></ol><p>SpringBoot有四大核心：</p><ol><li>自动配置：针对很多Spring常见的功能，SpringBoot能自动提供相关配置</li><li>起步依赖，在创建SpringBoot项目时，告诉SpringBoot需要什么功能， 它就会自动引入相关依赖库</li><li>Actuator：能够深入运行中的SpringBoot应用程序，一探SpringBoot程序内部信息</li><li>命令行界面：这是SpringBoot的可选特性，主要针对Groovy语言使用。</li></ol><h2 id="第一个SpringBoot项目"><a href="#第一个SpringBoot项目" class="headerlink" title="第一个SpringBoot项目"></a>第一个SpringBoot项目</h2><p>使用IDEA来创建SpringBoot项目，使用Spring Initializr来创建SpringBoot项目。可以使用默认的<code>https://start.spring.io</code>，也可以使用阿里提供的<code>http://start.aliyun.com</code>。</p><p>jdk版本要大于8。</p><p>点击Next：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210121142542978.png" alt="image-20210121142542978" style="zoom:50%;" /></p><p>其中：</p><ul><li>Group和Artifact和Maven配置一样。</li><li>Packaging是用来设定打包方式，默认使用jar</li><li>Package指定SpringBoot启动类所在的包路径</li></ul><p>点击Next：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210121143108611.png" alt="image-20210121143108611" style="zoom:50%;" /></p><p>在此处添加所需要的依赖。</p><p>然后下一步来设置模块名称，Content root的根路径和模块文件的根路径。就创建成功了。</p><p>SpringBoot的pom文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!--继承SpringBoot框架的一个父项目，所有自己开发的Spring Boot都必须的继承--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>10-SpringBootDemo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>10-SpringBootDemo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--maven属性配置，可以在其它地方通过$&#123;&#125;方式进行引用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--SpringBoot框架web项目起步依赖，通过该依赖自动关联其它依赖，不需要我们一个一个去添加了--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!--SpringBoot框架的测试起步依赖，例如：junit测试，如果不需要的话可以删除--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--SpringBoot提供的打包编译等插件--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>项目目录结构：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210121143642447.png" alt="image-20210121143642447" style="zoom:50%;" /></p><ul><li>mvn、mvnw、mvnw.cmd：使用脚本执行maven相关命令，用的较少，可以删除</li><li>gitignore：使用版本控制工具git时，设置忽略提交的内容</li><li>static、templates：后面模板技术存放文件的目录</li><li>application.properties：SpringBoot 的配置文件，集成的配置都可以在该文件中进行配置，例如Spring、SpringMVC、MyBatis和Redis等。</li><li>Application.java：SpringBoot程序执行入口，执行该程序中main方法，SpringBoot就启动了。</li></ul><p>SpringBoot项目代码要放在Application类的同级目录或下级目录中。</p><p><strong>即contoller、entity、dao、service、exception等包要和Application类放在同一级或下级目录中，并通过注解来设置。</strong></p><p>一般在Application类同级目录创建一个web包，把所有代码放在web包中。</p><p>在web包下创建一个控制器，仍然使用@Controller注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBootController</span> &#123;<br><br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/springboot/sayHello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, Spring Boot&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在DemoApplication运行main方法，启动该项目。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210121145751590.png" alt="image-20210121145751590"></p><h2 id="需要注意的几个地方"><a href="#需要注意的几个地方" class="headerlink" title="需要注意的几个地方"></a>需要注意的几个地方</h2><ol><li><p>SpringBoot的父级依赖spring-boot-starter-parent配置之后，当前项目是一个SpringBoot项目。</p></li><li><p>spring-boot-starter-parent是一个SpringBoot 的父级依赖，开发SpringBoot程序都需要继承该父级项目，它用来提供相关Maven的默认依赖，使用它之后，常用的jar依赖可以省去version配置。</p></li><li><p>SpringBoot提供了哪些默认jar包的依赖，可以查看该父级依赖的pom文件</p></li><li><p>如果不想使用默认的依赖版本，可以通过pom文件属性配置覆盖各个依赖项，比如覆盖spring版本：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">spring.version</span>&gt;</span>5.0.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>@SpringBootApplication注解是SpringBoot的核心注解，主要的作用是开启Spring自动配置</p></li><li><p>main方法是标准的Java程序的main方法，作为项目启动运行的入口</p></li><li><p>@Controller及@ResponseBody仍然是之前学过的SpringMVC，因为SpringBoot里面仍然使用的是SpringMVC、Spring和MyBatis等框架。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-SpringMVC核心技术</title>
    <link href="/2022/05/11/Spring-MVC/5-SpringMVC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/"/>
    <url>/2022/05/11/Spring-MVC/5-SpringMVC%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="请求转发和重定向"><a href="#请求转发和重定向" class="headerlink" title="请求转发和重定向"></a>请求转发和重定向</h2><p>当处理器对请求处理完毕后，向其他资源跳转时，有两种跳转方式：请求转发和重定向。</p><p><strong>请求转发，是在服务器内进行跳转，不经过客户端，浏览器地址栏是不变的；而重定向是告诉客户端下一个访问的地址，让客户端重新发起一次请求，浏览器地址会改变。</strong></p><p>而根据所要跳转的资源类型，又分为两类：跳转到页面、跳转到其他处理器方法。</p><p><strong>但是注意：对于请求转发的页面，可以是WEB-INF中页面；但是重定向页面，是不能为WEB-INF中页面的。因为重定向相当于用于重新发起一次请求，而用户是不能直接访问WEB-IN目录的。</strong></p><p>SpringMVC框架对Serlvet中的请求转发和重定向操作进行了封装：</p><ul><li>forward：表示转发，等于<code>request.getRequestDispather(&quot;xx&quot;).forward(request, response)</code></li><li>redirect：表示重定向，相当于<code>response.sendRedirect(&quot;xxx&quot;)</code></li></ul><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><h4 id="处理器方法返回ModelAndView"><a href="#处理器方法返回ModelAndView" class="headerlink" title="处理器方法返回ModelAndView"></a>处理器方法返回ModelAndView</h4><p>返回ModelAndView时，要在<code>setViewName(&quot;视图路径&quot;)</code>前加上forward，即：<code>setViewName(&quot;forward:视图完整路径&quot;)</code></p><p><strong>注意：使用请求转发到视图时，必须要写完整路径，即以resources为根目录；并且不和视图解析器一同使用，使用请求转发时，就当没有视图解析器。</strong></p><p>例如：<code>mv.setViewName(&quot;forward:/WEB-INF/result.jsp&quot;);</code></p><h4 id="返回String"><a href="#返回String" class="headerlink" title="返回String"></a>返回String</h4><p>和返回ModelAndView一样，字符串格式：<code>&quot;forward:视图完整路径&quot;</code></p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向使用方式和请求转发差不多，格式<code>&quot;redirect:视图完整路径&quot;</code>。同样不和视图解析器一同使用。</p><p><strong>但是重定向不能访问WEB-INF目录下资源。</strong></p><p><strong>注意：如果在一个页面传递参数给服务器，服务器进行重定向，并将相应参数通过mv.addObject()传递给jsp文件，然后重定向的jsp调用了这个参数，那么是获取不到的。</strong></p><p>举个例子：<br>注册页面，传递参数给服务器，然后处理器方法将参数使用<code>addObject()</code>添加到ModelAndView中，并重定向到result.jsp中，jsp文件调用了这个参数。</p><p>注册页面代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;注册页面&lt;/title&gt;<br>    &lt;base href=<span class="hljs-string">&quot;http://localhost:80/myweb/&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        &lt;form action=<span class="hljs-string">&quot;student/addStudent.do&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>            &lt;table&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;姓名&lt;/td&gt;<br>                    &lt;td&gt;&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;/td&gt;<br>                &lt;/tr&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;Email&lt;/td&gt;<br>                    &lt;td&gt;&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;email&quot;</span>&gt;&lt;/td&gt;<br>                &lt;/tr&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;年龄&lt;/td&gt;<br>                    &lt;td&gt;&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/td&gt;<br>                &lt;/tr&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;&lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;注册&quot;</span>&gt;&lt;/td&gt;<br>                &lt;/tr&gt;<br>            &lt;/table&gt;<br>        &lt;/form&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>处理器方法：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/addStudent.do&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">addStudent</span><span class="hljs-params">(Student student)</span> &#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    String tip;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> service.addStuent(student);<br><br>    mv.addObject(<span class="hljs-string">&quot;myname&quot;</span>, student.getName());<br>    mv.addObject(<span class="hljs-string">&quot;myage&quot;</span>, student.getAge());<br>    mv.setViewName(<span class="hljs-string">&quot;redirect:/views/result.jsp&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure><p>result.jsp：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        姓名:$&#123;myname&#125;&lt;br&gt;<br>        年龄:$&#123;myage&#125;<br>    &lt;/div&gt;<br>    <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/FfWQyjZeRl.gif" alt="FfWQyjZeRl"></p><p>可以看到，在result.jsp页面获取不到处理器方法传递的数据。但是地址栏发生了改变而且带上了处理器方法放入到ModelAndView的两个参数myname和myage。</p><p><strong>这是因为：框架会把Model中的简单类型的数据，转为String，作为重定向页面的get请求参数使用，目的是在这两次请求之间传递参数。</strong></p><p>但result.jsp使用${}获取不到数据，是因为，重定向是两次请求，用了两个request对象，所以获取不到。那么正确的用法应该是result.jsp从URL中获取参数，也就是<code>request.getParameter(&quot;myname&quot;)</code>。才可以获取到参数。</p><p>把result.jsp改为：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        姓名:&lt;%=request.getParameter(<span class="hljs-string">&quot;myname&quot;</span>)%&gt;&lt;br&gt;<br>        年龄:&lt;%=request.getParameter(<span class="hljs-string">&quot;myage&quot;</span>)%&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>或者也可以使用<code>$&#123;param.myname&#125;</code>和<code>$&#123;param.myage&#125;</code></p><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/q9xo4jcpGj.gif" alt="q9xo4jcpGj"></p><p>这次可以看到，result.jsp正确获取到了数据。</p><p>以上面为例，来梳理一下重定向处理过程 ：</p><p>首先点击注册，客户端发送请求<code>/student/addStudent.do</code>，<strong>这时会创建一个request对象，包含参数</strong>；然后处理器方法添加myname和myage两个参数到ModelAndView中，然后执行重定向这行，最后服务器会把mv对象返回给客户端，客户端收到重定向指令后，<strong>会再次携带ModelAndView存放的参数，向ModelAndView指定的页面result.jsp发送get请求，同时参数也会出现在地址栏中。服务器收到后，会再次创建一个request对象，所以这时在result.jsp中使用<code>$&#123;myname&#125;</code>是获取不到数据的。只有使用<code>request.getParameter()</code>获取客户端发送来的参数才可以。</strong></p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>通常处理异常的方式就是try/catch代码块。但是当代码一多，方法一多了以后，这种方法就非常繁琐。而且也不便于维护。</p><p>SpringMVC框架处理异常的方式是：使用@ExceptionHandler注解和@ControllerAdvice注解处理异常。</p><p>SpringMVC框架采用的是统一的、全局的异常处理。把Controller中的所有异常处理集中到一个地方，采用AOP思想，把业务逻辑代码和异常处理代码分开，解耦合。</p><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p>使用@ExceptionHandler可以将一个方法指定为异常处理方法，该注解只有一个可选属性</p><ul><li>value：他是一个Class&lt;?&gt;数组，用于指定该注解的方法要处理的异常类。就是当发生哪些异常，使用该方法处理。默认为空数组</li></ul><p>被注解的方法，返回值可以是ModelAndView、String、void和对象等，方法名任意。</p><p>方法参数可以是Exception和子类对象，HttpServletRequest、HTTPServletResponse等。系统会自动给这些参数赋值。</p><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>这个注解字面意思是：控制器增强，也就是给控制器增加功能。</p><p>它放在类的上面，表明这是一个异常处理类。</p><p>使用@ControllerAdvice的类可以创建异常处理方法，并在方法上加上@ExceptionHandler。</p><p>说简单点，就是被@ExceptionHandler注解的类，就表明是一个专门处理controller方法异常的类。</p><p>这个类中的方法来处理异常。</p><p><strong>注意：需要在springMVC配置文件中配置组件扫描器，指定@ControllerAdvice所在包名。</strong></p><h3 id="异常处理步骤"><a href="#异常处理步骤" class="headerlink" title="异常处理步骤"></a>异常处理步骤</h3><ol><li><p>在exception包中创建自定义异常类</p></li><li><p>在handler包中创建异常处理类，并加上@ControllerAdvice注解</p><p> 并创建处理异常方法，加上@ExceptionHandler注解</p></li><li><p>创建处理异常页面视图</p></li><li><p>在springMVC中配置@ControllerAdvice注解所在包名，并声明注解驱动</p></li><li><p>在处理器方法中抛出异常</p></li></ol><p><strong>注意：当异常处理类中有多个方法时，那就和catch差不多。我们一般只会处理几个特定的类，将其他的所有异常抛给虚拟机。异常处理类也是这样。 使用@ExceptionHandler中value属性指定我们要处理的异常类；不指定value属性代表其他所有异常。所以没有指定value属性的被注解方法只能有一个。</strong></p><p>异常发生处理一般有几个方面：</p><ul><li>记录异常，包括记录到数据库，日志文件，日志发生的时间，错误内容等</li><li>发送通知给相关人员</li><li>给用户提示</li></ul><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>学生注册，当姓名或者年龄不符合要求就抛出异常。</p><h4 id="创建异常类"><a href="#创建异常类" class="headerlink" title="创建异常类"></a>创建异常类</h4><p>创建三个异常类：UserException、NameException、AgeException。后两个类是UserException的子类</p><p>这三个方法实现无参构造器和有参数message构造器。</p><h3 id="创建异常处理类"><a href="#创建异常处理类" class="headerlink" title="创建异常处理类"></a>创建异常处理类</h3><p>GlobalExceptionHandler类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = &#123;NameException.class&#125;)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">doNameException</span><span class="hljs-params">(Exception ex)</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>, ex.getMessage());<br>        mv.setViewName(<span class="hljs-string">&quot;nameError&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler(value = &#123;AgeException.class&#125;)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">doAgeException</span><span class="hljs-params">(Exception ex)</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>, ex.getMessage());<br>        mv.setViewName(<span class="hljs-string">&quot;ageError&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br><br>    <span class="hljs-meta">@ExceptionHandler</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">doDefaultException</span><span class="hljs-params">(Exception ex)</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>        mv.addObject(<span class="hljs-string">&quot;msg&quot;</span>, ex.getMessage());<br>        mv.setViewName(<span class="hljs-string">&quot;defaultError&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>三个方法分别处理NameException、AgeException和其他异常。</p><h4 id="创建异常页面"><a href="#创建异常页面" class="headerlink" title="创建异常页面"></a>创建异常页面</h4><p>对应有三个页面：nameError、ageError和defaultError、</p><p>nameError：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        nameError&lt;br&gt;<br>        $&#123;msg&#125;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>ageError：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        ageError&lt;br&gt;<br>        $&#123;msg&#125;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><p>defaltuError：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        defaultError&lt;br&gt;<br>        $&#123;msg&#125;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure><h4 id="修改springmvc配置文件"><a href="#修改springmvc配置文件" class="headerlink" title="修改springmvc配置文件"></a>修改springmvc配置文件</h4><p>在配置文件中加上对handler的注解扫描器，和注解驱动。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.example.handler&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="处理器方法"><a href="#处理器方法" class="headerlink" title="处理器方法"></a>处理器方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/addStudent.do&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">addStudent</span><span class="hljs-params">(Student student)</span> <span class="hljs-keyword">throws</span> UserException &#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    <span class="hljs-keyword">if</span>(!student.getName().equals(<span class="hljs-string">&quot;大傻子&quot;</span>))&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NameException</span>(<span class="hljs-string">&quot;姓名只能为大傻子，其他姓名不行&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(student.getAge() &gt; <span class="hljs-number">80</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AgeException</span>(<span class="hljs-string">&quot;年龄要小于80岁&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> service.addStuent(student);<br><br>    mv.addObject(<span class="hljs-string">&quot;myname&quot;</span>, student.getName());<br>    mv.addObject(<span class="hljs-string">&quot;myage&quot;</span>, student.getAge());<br>    mv.setViewName(<span class="hljs-string">&quot;redirect:/views/result.jsp&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p>对应三个异常，分别进行验证。</p><p>输入名称二傻子验证NameException，输入年龄90验证ageException，输入年龄abc验证其他异常。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/DXq8izZuEb.gif" alt="DXq8izZuEb"></p><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>SpringMVC拦截器的主要作用是拦截指定的用户请求，并进行响应的预处理和后处理。拦截的时间点在：<strong>处理器映射器根据用户提供的请求映射出了所要执行的处理器类，并且找到了要执行该处理器类的处理器适配器，在处理器适配器执行处理器之前。进行拦截。</strong>当然，在处理器映射器映射出所要执行的处理器类时，已经将拦截器和处理器组合为一个处理器执行链，并返回给了中央调度器。</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><p>实现HandlerInterceptor接口，来自定义拦截器类，该接口有三个方法：</p><ul><li><code>public boolean preHandle(request,response, Object handler)</code>：该方法在处理器方法执行之前执行，返回值为Boolean，若为true，则执行处理器方法，并将afterCompletion()方法放入到专门方法栈中等待执行；若为false，则不执行处理器方法</li><li><code>public boolean postHandle(request,response, Object handler,modelAndView)</code>：该方法在处理器方法执行之后执行，若处理器方法不执行，那么该方法不会执行。由于该方法在处理器方法执行后执行，且方法参数中包含ModelAndView，所以该方法可以修改处理器方法的处理结果数据，也可以修改跳转方向。</li><li><code>afterCompletion(request, response, Object handler, Exception ex)</code>：当preHandler()方法返回true时，会将该方法放到专门方法栈中，等到对请求进行响应的所有工作完成之后，才执行该方法。<strong>即：该方法是在中央调度器渲染(数据填充)了相应页面后执行的，所有该方法对ModelAndView操作对不影响响应结果。</strong></li></ul><p>处理过程：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201222195256643.png" alt="image-20201222195256643" style="zoom:80%;" /></p><h3 id="拦截器使用步骤"><a href="#拦截器使用步骤" class="headerlink" title="拦截器使用步骤"></a>拦截器使用步骤</h3><ol><li>定义拦截器类</li><li>在springmvc配置文件中注册拦截器，并设置要拦截的请求。</li></ol><p>例子：</p><p>定义拦截器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;在处理器方法之前执行了preHandle方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;在处理器方法之后执行了postHandle方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了afterCompletion方法&quot;</span>);<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;attr&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;attr删除之前====&quot;</span> + session.getAttribute(<span class="hljs-string">&quot;attr&quot;</span>));<br>        session.removeAttribute(<span class="hljs-string">&quot;attr&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;attr删除之后====&quot;</span> + session.getAttribute(<span class="hljs-string">&quot;attr&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/listStudents.do&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">listStudents</span><span class="hljs-params">(HttpSession session)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;收到请求&quot;</span>);<br>    List&lt;Student&gt; list = service.selectStudents();<br>    session.setAttribute(<span class="hljs-string">&quot;attr&quot;</span>, <span class="hljs-string">&quot;session中数据&quot;</span>);<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><p>springmvc配置文件中注册拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/student/listStudents.do&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.interceptor.MyInterceptor&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201222201818458.png" alt="image-20201222201818458" style="zoom:80%;" /></p><h3 id="多个拦截器"><a href="#多个拦截器" class="headerlink" title="多个拦截器"></a>多个拦截器</h3><p>当有多个拦截器时，在springmvc配置文件中就要注册多个拦截器。</p><p>当有多个拦截器时，<strong>形成拦截器链，拦截器链的执行顺序和在配置文件中的注册顺序一样。</strong></p><p><strong>注意：当某一个拦截器的preHandle()方法返回true并被执行时，会向专门的方法栈中放入该拦截器的afterCompletion。</strong></p><p>只要有一个preHandle()方法返回false，那么执行链会被断开，后续的处理器方法和postHandle()方法会无法执行。</p><p><strong>但是，无论执行链执行情况怎样，只要方法栈中有方法，即执行链中有preHandle方法返回true且被执行，那么就会执行方法栈中的afterCompletion方法。</strong></p><p>也就是只执行执行链断开前 执行过的preHandle方法对应的afterCompletion方法。</p><p>例子：</p><p>创建了三个拦截器，大致相同，第一个拦截器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;在处理器方法之前执行了第一个拦截器的preHandle方法&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;在处理器方法之后执行了第一个拦截器的postHandle方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了第一个拦截器的afterCompletion方法&quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其他两个，把输出语句改成对应序号就可以了。<strong>把第二个拦截器的preHandle返回值改为false。</strong></p><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/listStudents.do&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">listStudents</span><span class="hljs-params">(HttpSession session)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;收到请求&quot;</span>);<br>    List&lt;Student&gt; list = service.selectStudents();<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><p>springmvc配置文件注册拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/student/listStudents.do&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.interceptor.MyInterceptor1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/student/listStudents.do&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.interceptor.MyInterceptor2&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/student/listStudents.do&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.interceptor.MyInterceptor3&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注册顺序是123</p><p>执行结果：<br>    <img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201226151415085.png" alt="image-20201226151415085" style="zoom:80%;" /></p><p>可以看到，执行链在执行到第二个拦截器的preHandle后断开，那么只有第一个拦截器的afterCompletion被执行了。</p><h3 id="权限拦截器"><a href="#权限拦截器" class="headerlink" title="权限拦截器"></a>权限拦截器</h3><p>可以使用拦截器来验证权限，没有权限的不能访问。</p><p>只有先点击登录，才后台添加session，才可以查看学生信息，否则无法查看学生信息。</p><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/listStudents.do&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">listStudents</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;收到请求&quot;</span>);<br>    List&lt;Student&gt; list = service.selectStudents();<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/login.do&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">login</span><span class="hljs-params">(HttpSession session)</span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;attr&quot;</span>, <span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>index.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;html&gt;<br>&lt;head&gt;<br>    &lt;base href=<span class="hljs-string">&quot;&lt;%=basePath%&gt;views/&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h2&gt;SSM整合开发&lt;/h2&gt;<br>&lt;a href=<span class="hljs-string">&quot;register.jsp&quot;</span>&gt;学生注册&lt;/a&gt;&lt;br&gt;<br>&lt;a href=<span class="hljs-string">&quot;listStudents.jsp&quot;</span>&gt;查看学生信息&lt;/a&gt;<br>&lt;a href=<span class="hljs-string">&quot;/myweb/student/login.do&quot;</span>&gt;登录&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>拦截器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInterceptor1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;attr&quot;</span>);<br>        <span class="hljs-keyword">if</span>(attr == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;在处理器方法之后执行了postHandle方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了afterCompletion方法&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>springmvc配置拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/student/listStudents.do&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.interceptor.MyInterceptor1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/Olxo61hNGB.gif" alt="Olxo61hNGB" style="zoom:80%;" /></p><p>首先点击查看学生信息，可以看到，没有任何信息；点击登录，再查看信息，有了。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-SSM整合开发</title>
    <link href="/2022/05/11/Spring-MVC/4-SSM%E6%95%B4%E5%90%88%E5%BC%80%E5%8F%91/"/>
    <url>/2022/05/11/Spring-MVC/4-SSM%E6%95%B4%E5%90%88%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>开发思路：<br>     SpringMVC：管理Controller层对象</p><p>Spring：管理Service和dao层，和工具类对象</p><p>MyBatis：负责数据访问</p><p>整个流程是：用户发起请求—-&gt;SpringMVC接受—-&gt;Spring中Service处理—-&gt;调用MyBatis处理数据</p><p>一共有两个容器：</p><ul><li>SpringMVC容器，管理Controller控制器对象</li><li>Spring容器，管理Service、Dao、工具类对象</li></ul><p>要把合适的对象交给合适的容器管理。</p><p>Controller对象定义在springmvc配置文件中，Service、Dao对象定义在Spring配置文件中。</p><p>SpringMVC容器是Spring容器的子容器，类似Java的继承。子容器可以访问父容器的内容。</p><p>在子容器中的Controller可以访问父容器中Service对象。可以实现Controller调用Service对象。</p><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><p>SSM整个开发，有两种方式：基于XML配置文件方式，基于注解方式。</p><p>可以两种结合使用，以注解为主，XML配置为辅。</p><ul><li><p>创建数据库表</p></li><li><p>创建Maven web项目</p></li><li><p>加入依赖：</p><ol><li>servlet</li><li>jsp</li><li>spring-tx：为JDBC、Hibernate等提供声明式和编程式事务管理</li><li>spring-jdbc：对JDBC的简单封装</li><li>spring-aspects：对AspectJ框架的整合</li><li>spring-webmvc，该依赖包括：<ul><li>spring-aop：Spring的面向切面编程，提供AOP的实现</li><li>spring-beans：Spring IOC的基础实现，包括访问配置文件，创建和管理bean等</li><li>spring-content：在基础IOC服务上，提供拓展服务。</li><li>spring-core：Spring的核心工具包</li><li>spring-expressions：Spring表达式语言</li><li>spring-web：包含web应用开发时，用到Spring框架所需的核心类</li></ul></li><li>mybatis依赖</li><li>mybatis和spring整合后依赖：mybatis-spring</li><li>mysql驱动依赖</li><li>druid，阿里数据池依赖</li><li>jackson：json数据格式转换依赖，包括jackson-core和jackson-databind</li><li>junit：单元测试</li><li>annotion注解依赖依赖，javax.annotion-api。该包属于Java拓展库，需要手动导入</li><li>lombok，不多介绍</li></ol></li><li><p>pom文件设置包括资源文件编译</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><ul><li><p>配置web.xml</p><ol><li><p>注册ContextLoaderListener监听器：创建Spring容器，并将容器对象放入ServletContext作用域</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc配置文件路径<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol></li></ul><pre><code class="hljs">2. 注册字符集过滤器：解决请求参数中中文乱码问题    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceRequestEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure>3. 配置中央调度器DispatherServlet，创建SpringMVC容器    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring配置文件路径<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>        <br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></code></pre><ul><li><p>创建实体类</p></li><li><p>创建DAO接口</p></li><li><p>创建Mapper映射文件</p></li><li><p>设置MyBatis配置文件</p></li><li><p>创建Service接口和实现类</p></li><li><p>创建属性文件，jdbc.properties</p></li><li><p>spring配置文件</p><ol><li>声明组件扫描器</li><li>配置数据源</li><li>注册SqlSessionFactoryBean</li><li>注册动态代理对象</li><li>注册Service对象</li></ol></li><li><p>springmvc配置文件</p><ol><li><p>声明组件扫描器：<code>&lt;context:component-scan base-package=&quot;&quot;/&gt;</code></p></li><li><p>注册注解驱动：<code>&lt;mvc:annotation-driven/&gt;</code></p></li><li><p>指定视图解析器</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>使用<mvc:resources mapper=""  location="" />标签，声明哪些静态资源能够访问</p></li></ol></li><li><p>创建Controller类</p></li><li><p>创建视图页面，JS和css等，发送请求，处理返回数据。</p></li></ul><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>完成对学生表的查找和插入。</p><p>学生表：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201219091945650.png" alt="image-20201219091945650" style="zoom:50%;" /></p><h3 id="加入pom依赖和编译包括xml和properties"><a href="#加入pom依赖和编译包括xml和properties" class="headerlink" title="加入pom依赖和编译包括xml和properties"></a>加入pom依赖和编译包括xml和properties</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--单元测试--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Servlet,一定要用3.x版本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--JSP--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet.jsp-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--WEB依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库事务管理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--AspectJ框架--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库访问--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--MySql驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--阿里数据连接池--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--MyBatis框架--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--MyBatis和Spring整合--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Json数据格式转换--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--Java注解--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置web-xml"><a href="#配置web-xml" class="headerlink" title="配置web.xml"></a>配置web.xml</h3><h4 id="注册DispatherServlet"><a href="#注册DispatherServlet" class="headerlink" title="注册DispatherServlet"></a>注册DispatherServlet</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:conf/springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注册ContextLoaderListener监听器"><a href="#注册ContextLoaderListener监听器" class="headerlink" title="注册ContextLoaderListener监听器"></a>注册ContextLoaderListener监听器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:conf/applicationContext.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注册字符集拦截器"><a href="#注册字符集拦截器" class="headerlink" title="注册字符集拦截器"></a>注册字符集拦截器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置编码格式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceRequestEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><p>实体类Student(用到了Lombok)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-meta">@NonNull</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建DAO接口"><a href="#创建DAO接口" class="headerlink" title="创建DAO接口"></a>创建DAO接口</h3><p>StudentDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentDao</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertStudent</span><span class="hljs-params">(Student student)</span>;<br>    List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建MyBatis映射文件"><a href="#创建MyBatis映射文件" class="headerlink" title="创建MyBatis映射文件"></a>创建MyBatis映射文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.example.dao.StudentDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertStudent&quot;</span>&gt;</span><br>        insert into student(name, email, age) value (#&#123;name&#125;, #&#123;email&#125;, #&#123;age&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudents&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.entity.Student&quot;</span>&gt;</span><br>        select id, name, email, age from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建MyBatis配置文件"><a href="#创建MyBatis配置文件" class="headerlink" title="创建MyBatis配置文件"></a>创建MyBatis配置文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><span class="hljs-comment">&lt;!--关掉了日志--&gt;</span><br><span class="hljs-comment">&lt;!--    &amp;lt;!&amp;ndash;设置&amp;ndash;&amp;gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;settings&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &amp;lt;!&amp;ndash;输出日志到控制台&amp;ndash;&amp;gt;--&gt;</span><br><span class="hljs-comment">&lt;!--        &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--    &lt;/settings&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置别名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example.entity&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--映射文件配置,接口和映射文件名称完全一样，并且在同一目录，才能使用package标签--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example.dao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建Service接口和实现类"><a href="#创建Service接口和实现类" class="headerlink" title="创建Service接口和实现类"></a>创建Service接口和实现类</h3><p>StudentService接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentService</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">addStuent</span><span class="hljs-params">(Student student)</span>;<br>    List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>StudentServiceImpl实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentService</span> &#123;<br><span class="hljs-comment">//使用Resource注解自动注入，先ByName，再ByType</span><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StudentDao studentDao;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">addStuent</span><span class="hljs-params">(Student student)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> studentDao.insertStudent(student);<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> studentDao.selectStudents();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建属性文件jdbc-properties"><a href="#创建属性文件jdbc-properties" class="headerlink" title="创建属性文件jdbc.properties"></a>创建属性文件jdbc.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.url</span> = <span class="hljs-string">jdbc:mysql://localhost:3306/test</span><br><span class="hljs-attr">jdbc.username</span> = <span class="hljs-string">root</span><br><span class="hljs-attr">jdbc.password</span> = <span class="hljs-string">*********</span><br><span class="hljs-attr">jdbc.maxActive</span> = <span class="hljs-string">20</span><br></code></pre></td></tr></table></figure><h3 id="spring配置文件"><a href="#spring配置文件" class="headerlink" title="spring配置文件"></a>spring配置文件</h3><h4 id="声明组件扫描器"><a href="#声明组件扫描器" class="headerlink" title="声明组件扫描器"></a>声明组件扫描器</h4><p>用来扫描Service类对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.example.service&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置属性文件路径--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:conf/jdbc.properties&quot;</span>/&gt;</span><br><br><br><span class="hljs-comment">&lt;!--配置数据源，使用$&#123;&#125;来引用属性文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druid&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.maxActive&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注册SqlSessionFactoryBean"><a href="#注册SqlSessionFactoryBean" class="headerlink" title="注册SqlSessionFactoryBean"></a>注册SqlSessionFactoryBean</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--创建SqlSessionFactory对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druid&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:conf/mybatis.xml&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注册动态代理对象"><a href="#注册动态代理对象" class="headerlink" title="注册动态代理对象"></a>注册动态代理对象</h4><p>注册MapperScannerConfigurer对象，批量生成接口的代理对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--创建dao接口代理对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.example.dao&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这次没有配置事务管理。</p><h3 id="springmvc配置文件"><a href="#springmvc配置文件" class="headerlink" title="springmvc配置文件"></a>springmvc配置文件</h3><h4 id="声明组件扫描器-1"><a href="#声明组件扫描器-1" class="headerlink" title="声明组件扫描器"></a>声明组件扫描器</h4><p>用来扫描controller对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--组件扫描器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.example.controller&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="注册注解驱动"><a href="#注册注解驱动" class="headerlink" title="注册注解驱动"></a>注册注解驱动</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注解驱动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="指定视图解析器"><a href="#指定视图解析器" class="headerlink" title="指定视图解析器"></a>指定视图解析器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--注册视图解析器，前缀和后缀--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/views/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="声明静态资源访问标签"><a href="#声明静态资源访问标签" class="headerlink" title="声明静态资源访问标签"></a>声明静态资源访问标签</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--处理静态资源访问,location为静态资源目录,格式&quot;/dir/&quot;，mappring为静态资源目录所有文件映射,格式&quot;/dir/**&quot;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/static/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/static/&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:resources</span> <span class="hljs-attr">mapping</span>=<span class="hljs-string">&quot;/views/**&quot;</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;/views/&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意，视图解析器用来处理器方法返回视图时，用来解析视图路径的。而静态资源访问标签，是用来让前端直接访问静态资源的，</strong></p><h3 id="创建Controller类"><a href="#创建Controller类" class="headerlink" title="创建Controller类"></a>创建Controller类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(value =&quot;/student&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> StudentService service;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/addStudent.do&quot;)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">addStudent</span><span class="hljs-params">(Student student)</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>        String tip;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> service.addStuent(student);<br>        System.out.println(num);<br>        <span class="hljs-keyword">if</span>(num &gt; <span class="hljs-number">0</span>) &#123;<br>            tip = <span class="hljs-string">&quot;学生[&quot;</span> + student.getName() + <span class="hljs-string">&quot;]注册成功&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tip = <span class="hljs-string">&quot;学生[&quot;</span> + student.getName() + <span class="hljs-string">&quot;]注册失败&quot;</span>;<br>        &#125;<br>        mv.addObject(<span class="hljs-string">&quot;tip&quot;</span>, tip);<br>        mv.setViewName(<span class="hljs-string">&quot;result&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/listStudents.do&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">listStudents</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;收到请求&quot;</span>);<br>        List&lt;Student&gt; list = service.selectStudents();<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建页面，jsp、js等文件"><a href="#创建页面，jsp、js等文件" class="headerlink" title="创建页面，jsp、js等文件"></a>创建页面，jsp、js等文件</h3><h4 id="索引页面"><a href="#索引页面" class="headerlink" title="索引页面"></a>索引页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;%<br>    <span class="hljs-type">String</span> <span class="hljs-variable">basePath</span> <span class="hljs-operator">=</span> request.getScheme() + <span class="hljs-string">&quot;://&quot;</span> + request.getServerName()<br>                        + <span class="hljs-string">&quot;:&quot;</span> + request.getServerPort() + request.getContextPath() + <span class="hljs-string">&quot;/&quot;</span>;<br>%&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;base href=<span class="hljs-string">&quot;&lt;%=basePath%&gt;views/&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h2&gt;SSM整合开发&lt;/h2&gt;<br>&lt;a href=<span class="hljs-string">&quot;register.jsp&quot;</span>&gt;学生注册&lt;/a&gt;&lt;br&gt;<br>&lt;a href=<span class="hljs-string">&quot;listStudents.jsp&quot;</span>&gt;查看学生信息&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="注册页面"><a href="#注册页面" class="headerlink" title="注册页面"></a>注册页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;注册页面&lt;/title&gt;<br>    &lt;base href=<span class="hljs-string">&quot;http://localhost:80/myweb/&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        &lt;form action=<span class="hljs-string">&quot;student/addStudent.do&quot;</span> method=<span class="hljs-string">&quot;post&quot;</span>&gt;<br>            &lt;table&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;姓名&lt;/td&gt;<br>                    &lt;td&gt;&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span>&gt;&lt;/td&gt;<br>                &lt;/tr&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;Email&lt;/td&gt;<br>                    &lt;td&gt;&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;email&quot;</span>&gt;&lt;/td&gt;<br>                &lt;/tr&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;年龄&lt;/td&gt;<br>                    &lt;td&gt;&lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;age&quot;</span>&gt;&lt;/td&gt;<br>                &lt;/tr&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;<br>                    &lt;td&gt;&lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;注册&quot;</span>&gt;&lt;/td&gt;<br>                &lt;/tr&gt;<br>            &lt;/table&gt;<br>        &lt;/form&gt;<br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="注册成功页面"><a href="#注册成功页面" class="headerlink" title="注册成功页面"></a>注册成功页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        &lt;img src=<span class="hljs-string">&quot;../static/images/1.png&quot;</span> width=<span class="hljs-string">&quot;800px&quot;</span> height=<span class="hljs-string">&quot;600px&quot;</span>&gt;<br>        $&#123;tip&#125;<br>    &lt;/div&gt;<br>    <br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="查看所有学生页面"><a href="#查看所有学生页面" class="headerlink" title="查看所有学生页面"></a>查看所有学生页面</h4><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;查看学生&lt;/title&gt;<br>&lt;%--    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;../static/js/jquery_3.5.1.js&quot;</span>&gt;&lt;/script&gt;--%&gt;<br>    &lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br>        window.onload = function ()&#123;<br><br>            <span class="hljs-type">let</span> <span class="hljs-variable">xmlHttp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>            xmlHttp.onreadystatechange = function () &#123;<br>                <span class="hljs-keyword">if</span>(xmlHttp.readyState == <span class="hljs-number">4</span> &amp;&amp; xmlHttp.status == <span class="hljs-number">200</span>) &#123;<br>                    <span class="hljs-type">let</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> xmlHttp.responseText;<br>                    <span class="hljs-type">let</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> JSON.parse(json);<br>                    document.getElementById(<span class="hljs-string">&quot;stuBody&quot;</span>).innerHTML = <span class="hljs-string">&quot;&quot;</span>;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-type">let</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; data.length; i++)&#123;<br>                        document.getElementById(<span class="hljs-string">&quot;stuBody&quot;</span>).innerHTML =<br>                            document.getElementById(<span class="hljs-string">&quot;stuBody&quot;</span>).innerHTML +  <span class="hljs-string">&quot;&lt;tr&gt;&quot;</span><br>                            + <span class="hljs-string">&quot;&lt;td&gt;&quot;</span> + data[i].id + <span class="hljs-string">&quot;&lt;/td&gt;&quot;</span><br>                            + <span class="hljs-string">&quot;&lt;td&gt;&quot;</span> + data[i].name + <span class="hljs-string">&quot;&lt;/td&gt;&quot;</span><br>                            + <span class="hljs-string">&quot;&lt;td&gt;&quot;</span> + data[i].age + <span class="hljs-string">&quot;&lt;/td&gt;&quot;</span><br>                            + <span class="hljs-string">&quot;&lt;td&gt;&quot;</span> + data[i].email + <span class="hljs-string">&quot;&lt;/td&gt;&quot;</span><br>                            + <span class="hljs-string">&quot;&lt;/tr&gt;&quot;</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            xmlHttp.open(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;/myweb/student/listStudents.do&quot;</span>);<br>            xmlHttp.send();<br><br>        &#125;<br>    &lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;div align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>        &lt;p&gt;查询学生数据&lt;/p&gt;<br>        &lt;table border=<span class="hljs-string">&quot;1px&quot;</span> frame=<span class="hljs-string">&quot;box&quot;</span> rules=<span class="hljs-string">&quot;all&quot;</span> style=<span class="hljs-string">&quot;font-size: 25px&quot;</span> align=<span class="hljs-string">&quot;center&quot;</span>&gt;<br>            &lt;thead&gt;<br>                &lt;tr&gt;<br>                    &lt;td&gt;ID&lt;/td&gt;<br>                    &lt;td&gt;姓名&lt;/td&gt;<br>                    &lt;td&gt;年龄&lt;/td&gt;<br>                    &lt;td&gt;Email&lt;/td&gt;<br>                &lt;/tr&gt;<br>            &lt;/thead&gt;<br>            &lt;tbody id=<span class="hljs-string">&quot;stuBody&quot;</span>&gt;<br><br>            &lt;/tbody&gt;<br>        &lt;/table&gt;<br><br>    &lt;/div&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-静态资源访问问题</title>
    <link href="/2022/05/11/Spring-MVC/3-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/"/>
    <url>/2022/05/11/Spring-MVC/3-%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>在之前配置DispatherServlet时，标签<url-pattern>设置的是*.do。当时也写了，可以使用<code>/</code>。</strong></p><p><strong>那么所有请求都默认会给DispatherServlet来进行处理。</strong></p><p><strong>如果访问静态资源，DispatherServlet调用处理器映射器来查找相应处理器。当然是找不到的。因为DispatherServlet只能找到哪些使用@RequestMapper注解指定的处理器方法，所以这种情况下，所有的静态资源获取请求都会显示找不到，404错误。</strong></p><p>在Tomcat中，有一个专门处理静态资源访问请求的Servlet，叫DefaultServlet。这个Servlet注册在Tomcat的web.xml中，可以在/conf/web.xml文件中找到。</p><p>所以当在项目的web.xml文件中使用了<code>/</code>，就会替代tomcat的default。导致所有静态资源都给DispatherServlet处理。默认情况DispatherServlet是没有处理静态资源的能力的。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用<mvn:defalut-servlet-handler /></h3><p>在SpringMvc配置文件中声明<mvn:defalut-servlet-handler />标签后，springmvc框架会在容器中创建DefaultServletHttpRequestHandler处理器对象。它会对进入DisPatherServlet的URL进行检查，如果发现是静态资源的请求，就会把该请求转入Web应用服务器默认的Servlet处理。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用<mvn:resources /></h3><p>在Spring3.0版本后，Spring定义了专门用于处理静态资源访问请求的处理器ResourceHttpRequestHandler。并且添加了<mvn:resources />标签，来解决静态资源无法访问的情况。</p><p>在springmvc配置文件中加上该标签，就会创建ResourceHttpRequestHandler对象。</p><p>格式为：</p><mvc:resources location="" mapping = "" /><p>其中：</p><ul><li>location：表示静态资源所在目录，不要使用/WEB-INF目录及其子目录。例如”/images/“，<strong>两个斜杠不能缺，第一个代表根目录，第二个代表images目录下</strong>。</li><li>mapper：表示对该资源的请求，一般使用通配符<code>**</code>。例如”/images/<strong> </strong>“，代表images目录下的所有文件，包括子目录下的。<strong>斜杠同样不能少。</strong></li></ul><p>例如：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201217150523209.png" alt="image-20201217150523209" style="zoom:67%;" /></p><p><strong>注意：如果加上该标签，但是没有注解驱动标签<mvc:annotation-driven/>，那么动态资源和静态资源会发生冲突，导致动态资源无法访问。所以一定要加上注解驱动标签。</strong></p><p><strong>为了更方便一些，不用每类资源写一个标签，可以把所有静态资源放在同一个目录(例如static)中，然后只用一个标签就可以配置所有静态资源。</strong></p><h2 id="路径问题"><a href="#路径问题" class="headerlink" title="路径问题"></a>路径问题</h2><p><strong>区分一下相对路径前加斜杠<code>/</code>和不加的区别。</strong></p><p>在JSP、html、Js文件中使用的地址，都是在前端页面中的地址，是相对地址。</p><p>地址有两种：</p><ul><li>相对地址：没有协议开头的，例如user.some.do，/user/some.do</li><li>绝对地址：带有协议开头的，例如<a href="http://localhost">http://localhost</a></li></ul><p>相对地址不能独立使用，必须要有参考地址，参考地址 + 相对地址  组成完整地址。</p><p>举一个例子：</p><p>不加斜杠<code>/</code>：</p><p>访问资源<code>http://localhost:80/myweb/request.html</code></p><p>路径：<code>http://localhost:80/myweb/</code></p><p>资源：<code>request.html</code></p><p>那么当在request.html中发起user/some.do请求时(就是前端代码 链接是user/some.do)，访问地址会变成<code>http://localhost:80/myweb/user/some.do</code>。所以当在前端点击链接时，访问地址是当前页面的路径加上链接地址。</p><p>加上斜杠<code>/</code>：</p><p>访问资源<code>http://localhost:80/myweb/request.html</code></p><p>路径：<code>http://localhost:80/myweb/</code></p><p>资源：<code>request.html</code></p><p>而如果前端代码写的链接是/user/some.do，那么点击链接，这时访问地址会变成<code>http://localhost:80/user/some.do</code></p><p>那么是不是前端代码全都不加斜杠呢，其实也会出问题。</p><p>举一个例子：</p><p>后端响应一个页面就是当前页面，例如<code>http://localhost:80/myweb/request.html</code>中点击链接user/some.do，而这个请求响应的也是这个页面request.html，但是这时候地址栏路径就会变为<code>http://localhost:80/myweb/user/some.do</code>，那么响应的页面同样有链接/user/some.do，再次点击，路径就会变为<code>http://localhost:80/myweb/user/user/some.do</code>，这时候就会出现404错误。</p><p>处理器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/user/some.do&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doStringData</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/request.html&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>html代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>请求页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;user/some.do&quot;</span> &gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么运行结果：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/yBRFVxREPx.gif" alt="yBRFVxREPx" style="zoom:67%;" /></p><p>所以为了解决这种情况，可以在html页面中<head>标签中，加入<base href="">，页面中所有不带<code>/</code>的地址，都会加上base标签指定的路径。支持<a>、<img>、<form>等标签中的URL。</p><p>例如刚才的例子加上base标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>请求页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://localhost/myweb/&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;user/some.do&quot;</span> &gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/ID2LcSj9vw.gif" alt="ID2LcSj9vw" style="zoom:67%;" /></p><h3 id="路径使用方法"><a href="#路径使用方法" class="headerlink" title="路径使用方法"></a>路径使用方法</h3><p>所以总的来说：<br>    前端代码，使用base标签来指定所有不带<code>/</code>的路径，然后链接不带<code>/</code></p><p>后端代码，处理器方法注解@RequestMapper中value的值不加斜杠。</p><p>如果要返回静态资源，那么就加上/，例如返回一个html文件。<code>return “/index.html</code>。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-处理器方法</title>
    <link href="/2022/05/11/Spring-MVC/2-%E5%A4%84%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/11/Spring-MVC/2-%E5%A4%84%E7%90%86%E5%99%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>已经学了创建控制器类，控制器类里的一个方法对应一个请求或者多个请求。使用@RequestMapping来进行配置。</p><p>下面具体来讲一下处理器方法。</p><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>@RequestMapping注解可以放在类上面，也可以放在方法上。但是含义是完全不一样的。</p><h3 id="放在类上面"><a href="#放在类上面" class="headerlink" title="放在类上面"></a>放在类上面</h3><p>放在类上面，其实很简单。只有一种情况，就是当这个类中的所有方法对应的请求都有公共部分时，就可以把该公共部分提取出来放到类上。</p><p>表示类中的响应请求的方法都是以该地址作为父路径。</p><p>例如MyController类中有doSome()方法和doOther()方法，他们对应的请求分别是<code>/test/some.do</code>和<code>/test/other.do</code>，那么就可以把<code>/test</code>抽取出来，放在类定义上面，也就是<code>@RquestMapper(value=&quot;/test&quot;)</code>，然后在方法上只使用<code>@RequestMapping(value=&quot;/some.do&quot;)</code>和<code>@RequestMapping(value=&quot;/other.do&quot;)</code>即可。代码更简便，同时也便于修改。</p><h3 id="放在方法上面"><a href="#放在方法上面" class="headerlink" title="放在方法上面"></a>放在方法上面</h3><p>之前的例子已经用过了。@RequestMapping注解放在方法上。但只用到了value属性。@RequestMapping注解还有其他的属性。</p><p>下面来讲@RequestMapping的属性</p><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p>用来指定请求的实际地址，指定的地址是URI格式。前端代码的请求地址要和这个值保持一致。</p><p><strong>注意：只能一个方法对应多个请求，而不能一个请求对应多个方法，那样的话会报错。</strong></p><p>前端代码中不能加<code>/</code>。</p><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>指定请求的方式，例如GET、POST、PUT等</p><p>它的值是RequestMethod类的枚举值。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201208131258509.png" alt="image-20201208131258509" style="zoom:35%;" /></p><p>例如：<code>@RequestMapping(method=RequestMethod.GET)</code></p><p>如果不指定请求方式，那么没有限制，任意一种请求方式都可以。</p><h4 id="consumes"><a href="#consumes" class="headerlink" title="consumes"></a>consumes</h4><p>这个参数指定处理请求的提交内容类型Content-Type，例如application/json，application/html</p><p>也是是说，如果这个请求没有包含这个参数指定的提交内容类型，那么就不会处理。</p><h4 id="produces"><a href="#produces" class="headerlink" title="produces"></a>produces</h4><p>指定返回的内容类型，只有当请求头中的Accpet的值包含这个参数指定的值，才会处理。</p><p>同时其实也暗含了这个方法会返回指定类型的值。</p><h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p>指定request中必须包含某些指定参数值，才会让该方法处理。</p><p>格式为<code>params=&quot;key=value,..&quot;</code>。</p><h4 id="headers"><a href="#headers" class="headerlink" title="headers"></a>headers</h4><p>指定request中必须包含某些指定的header值，才让该方法处理请求。</p><p>格式为：<code>headers=&quot;key=value,..&quot;</code>。</p><h2 id="处理器方法参数"><a href="#处理器方法参数" class="headerlink" title="处理器方法参数"></a>处理器方法参数</h2><p>处理器方法可以包含以下四类参数，这些参数会在调用时由框架自动赋值，只要在方法形参中定义好，我们可以直接在方法内使用</p><ul><li>HttpServletRequest</li><li>HttpServletResponse</li><li>HttpSession</li><li>请求中所携带的请求参数</li></ul><p>例如想要使用前两个参数，直接在方法签名的形参列表定义即可：<code>public ModelAndView doSome(HttpServletRequest request, HttpServletResponse response)</code>。</p><h3 id="逐个参数接受"><a href="#逐个参数接受" class="headerlink" title="逐个参数接受"></a>逐个参数接受</h3><p>接受请求中所携带的请求参数，可以逐个参数接受。框架会自动进行类型转换。</p><p>只需要保证，前端代码的请求参数名和处理方法的参数名相同即可。</p><p>例如：<br>前端代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/some.do&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> &gt;</span><br>    姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交信息&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么处理方法中的参数名和前端提交的参数名保持一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">doSome</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    mv.addObject(<span class="hljs-string">&quot;name&quot;</span>, name);<br>    mv.addObject(<span class="hljs-string">&quot;age&quot;</span>, age);<br>    mv.setViewName(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201208134551362.png" alt="image-20201208134551362" style="zoom:33%;" /></p><p>可以看到参数正常接收到了。</p><h4 id="POST方式解决乱码问题"><a href="#POST方式解决乱码问题" class="headerlink" title="POST方式解决乱码问题"></a>POST方式解决乱码问题</h4><p>当使用POST方式提交值为中文的参数时，会出现乱码。</p><p>我们可以使用以往的解决方法，就是调用请求对象request.setCharacterEncoding()，设为UTF-8。但是这样太麻烦，需要重复编写。</p><p>可以使用过滤器，来统一设置POST请求的编码方式。</p><p>可以自定义过滤器类，也可以使用SpringMVC提供的过滤器类CharacterEncodingFilter类。</p><h5 id="在web-xml配置过滤器"><a href="#在web-xml配置过滤器" class="headerlink" title="在web.xml配置过滤器"></a>在web.xml配置过滤器</h5><p>需要在配置文件web.xml中注册过滤器。</p><p>该过滤器类有三个成员变量:</p><ul><li>encoding：字符串类型，指定项目使用的字符编码，一般用utf-8</li><li>forceRequestEncoding：布尔类型，指定请求对象request是否使用字符集encoding，默认是false，需要改为true</li><li>forceResponseEncoding布尔类型，指定响应对象response是否使用字符集encoding，默认是false，需要改为true</li></ul><p>同时设置<filter-mapper>中的<url-pattern>值为<code>/*</code>，表示强制所有的请求都必须通过该过滤器。</p><p>即：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceRequestEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceResponseEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><p>当请求URL的请求参数名和处理方法的形参名不相同时，使用@RequestParam注解放在形参名前，用来指定请求提交的参数名。</p><p>该注解有三个属性：</p><ul><li>value：请求参数名</li><li>required：指定该参数是否是必需，默认为true，即请求中必须包含该参数，如果没有，会抛出异常</li><li>defaultValue：默认值，如果设置了该值，那么required自动设为false。无论你是否手动配置了required。</li></ul><p>一般将required设为false。</p><p>例子：<br>修改前端代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;some.do&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> &gt;</span><br>    姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myName&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myAage&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交信息&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>那么方法签名改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">doSome</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;myName&quot;, required = false)</span>String name,</span><br><span class="hljs-params">                           <span class="hljs-meta">@RequestParam(&quot;myAge&quot;, required = false)</span> <span class="hljs-type">int</span> age)</span><br></code></pre></td></tr></table></figure><h3 id="对象参数接受"><a href="#对象参数接受" class="headerlink" title="对象参数接受"></a>对象参数接受</h3><p>若把处理器方法的参数定义为一个Java对象，那么只要保证请求的参数名和这个对象的属性名相同即可。</p><p>与逐个参数接受差不多。</p><p>只不过变成了和Java对象的属性名相同。</p><p><strong>适合用于请求参数比较多的情况。</strong></p><p><strong>这种方法在实际中应用的比较多。</strong></p><p>例如：</p><p>前端代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;some.do&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span> &gt;</span><br>    姓名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> &gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交信息&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建一个类Student</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">//set和get方法，构造器方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那么在处理器方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">doSome</span><span class="hljs-params">(Student student)</span> &#123;<br>    <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>    mv.addObject(<span class="hljs-string">&quot;myStudent&quot;</span>, student);<br>    mv.setViewName(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure><p>hello.jsp代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;欢迎界面&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;h1&gt;欢迎使用SpringMVC开发Web应用&lt;/h1&gt;<br>    &lt;h2&gt;姓名是：$&#123;myStudent.name&#125;&lt;/h2&gt;<br>    &lt;h2&gt;年龄是：$&#123;myStudent.age&#125;&lt;/h2&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="处理器方法返回值"><a href="#处理器方法返回值" class="headerlink" title="处理器方法返回值"></a>处理器方法返回值</h2><p>常见的返回值有四种类型：</p><ul><li>ModelAndView</li><li>String</li><li>void，无返回值</li><li>自定义类型的对象</li></ul><h3 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h3><p>如果处理器方法处理完以后，<strong>需要跳转到其他资源，并且要在跳转的资源间传递数据</strong>，那么处理器方法返回ModelAndView比较好的。</p><p>但如果，处理器方法只是进行跳转不传递数据，或者只传递数据并不向任何资源跳转(例如异步请求ajax)，则此时不应该返回ModelAndView。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>如果处理器方法执行完后，只进行资源跳转。那么可以返回String类型。返回的字符串可以指定逻辑视图名，视图解析器会将其解析，转换为物理视图地址(就是html、jsp等资源文件)。</p><p>如果跳转的资源是内部资源，那么因为已经在springmvc.xml文件中注册了视图解析器。所以直接返回方法名即可，视图解析器会将路径前缀和后缀拓展名进行拼接。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>发起请求就可以跳转到hello.jsp文件。</p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>如果处理器方法不需要跳转到其他资源，可以让处理器方法返回void。</p><p>例如对于ajax异步请求的响应。</p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>处理器方法可以返回Object对象，这个对象可以是String、Integer对象，也可以是自定义对象。但是返回的对象不是作为逻辑视图出现的。而是作为直接在页面显示的数据出现的。</p><p>返回对象，需要使用@ResponseBody注解，将转换后的JSON数据放入响应体中。<strong>通常是用来响应AJAX请求的。</strong></p><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><h5 id="导入pom依赖"><a href="#导入pom依赖" class="headerlink" title="导入pom依赖"></a>导入pom依赖</h5><p>因为返回Object数据，一般是将数据转换为JSON对象后传递给浏览器页面的。由Object转换为JSON，是由Jackson工具库完成的。需要导入Jackson的相关jar包。</p><h5 id="声明注解驱动"><a href="#声明注解驱动" class="headerlink" title="声明注解驱动"></a>声明注解驱动</h5><p>将Object数据转换为JSON数据，需要由消息转换器HttpMessageConverter完成。转换器的开启，需要声明注解驱动。</p><p>需要在springmvc配置文件中声明注解驱动，加上：<mvc:annotation-driven />。</p><p>消息转换器的功能：完成Java对象到json、xml、text和二进制等数据格式的转换。或反过来的转换。</p><h6 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h6><p>HttpMessageConverter是一个接口，负责将请求信息转换为一个对象(类型为T)，将对象(类型为T)输出为响应信息。</p><p>定义了Java对象转换为json、xml等数据格式的方法。</p><p>该接口中有四个方法：</p><ul><li><p><code>boolean canRead(Class&lt;?&gt; clazz, MediaType mediaType)</code>：指定转换器可以读取的对象类型，即转换器是否可以将请求信息转换为clazz类型的对象。同时指定支持MIME类型(text/html, application/json)。</p><p>  简单来说，这个 方法是用来检查输入流的数据格式是否可以转换为对应的Java对象</p></li><li><p><code>boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType)</code>：指定转换器是否可以将clazz类型的对象写入到响应流中，响应流支持的媒体类型在MediaType中定义</p><p>  简单来说，这个 方法是用来检查处理器方法的返回值是否可以转换为mediaType中的数据格式</p></li><li><p><code>T read(Class&lt;?&gt; clazz, HttpInputMessage inputMessage)</code>：将请求信息流转换为T类型的对象</p></li><li><p><code>T write(Class&lt;?&gt; clazz, HttpOutputMessage outputMessage)</code>：将T类型的对象写入到响应流中，同时指定响应媒体类型为contentType。就是将处理器方法返回的对象转换成指定数据格式。如果是json，就会使用Jackson的工具库来进行转换。</p></li></ul><pre><code class="hljs">其中MdeiaType用来表示数据格式，例如json、xml等</code></pre><p>这个接口有很多实现类，这些实现类分别完成了Java对象到json、xml等数据格式的转换。</p><p><strong>当Spring容器进行初始化时，在读取<mvc:annotation-driven />时，默认会创建七个HttpMessageConverter接口的实现类对象。</strong></p><p>这七个实现类对象分别是：</p><ul><li>ByteArrayHttpMessageConverter：负责读取二进制格式数据和写出二进制格式数据</li><li><strong>StringHttpMessageConverter：负责读取字符串格式数据和写出字符串格式数据</strong></li><li>ResourceHttpMessageConverter：读取资源文件和写出资源文件数据</li><li>SourceHttpMessageConverter：能够读、写来自HTTP请求与相应的javax.xml.transform.Source，支持DOMSource，SAXSource和StreamSource的XML格式</li><li>AllEncodingpassingFormHttpMessageConverter：负责处理表单数据</li><li>Jaxb2RootElementHttpMessageConverter：使用JAXB负责读取和写入xml格式的数据</li><li><strong>MapperJackson2HttpMessageConverter：负责读取和写入json格式的数据。使用Jackson的ObjectMapper读写json数据。操作Object类型数据。可读取application/json，相应媒体类型为application/json</strong></li></ul><p>其中加粗的两个比较常用。</p><h5 id="添加-ResponseBody注解"><a href="#添加-ResponseBody注解" class="headerlink" title="添加@ResponseBody注解"></a>添加@ResponseBody注解</h5><p>将该注解放在对应处理器方法上面。通过HttpServletResponse相应请求，返回数据的。</p><p>和其他注解没有顺序先后。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><h5 id="输出自定义对象"><a href="#输出自定义对象" class="headerlink" title="输出自定义对象"></a>输出自定义对象</h5><p>向浏览器返回一个自定义的对象Student，转换为json格式。</p><p>处理器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/returnStudent.do&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">doStudent</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setName(<span class="hljs-string">&quot;赵大宝&quot;</span>);<br>    student.setAge(<span class="hljs-number">21</span>);<br>    <span class="hljs-keyword">return</span> student;<br>&#125;<br></code></pre></td></tr></table></figure><p>异步请求代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    $(<span class="hljs-string">&quot;#btn&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        $.<span class="hljs-title function_">ajax</span>(&#123;<br>            <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;returnStudent.do&quot;</span>,<br>            <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;get&quot;</span>,<br>            <span class="hljs-attr">dataType</span>:<span class="hljs-string">&quot;json&quot;</span>,<br>            <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>                <span class="hljs-title function_">alert</span>(data);<br>            &#125;<br>        &#125;)<br><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201217132846957.png" alt="image-20201217132846957" style="zoom:67%;" /></p><p>返回对象Json数据的处理流程：</p><ul><li>框架会将Student类型，调用框架中的ArrayList<HttpMessageConverter>中每个实现类对象的canWrite方法，检查哪个HttpMessageConverter接口的实现类可以处理Student类型的数据，找到MapperJackson2HttpMessageConverter实现类</li><li>框架调用实现类的write方法，把student对象转换为json数据，调用Jackson的ObjectMapper</li><li>框架调用@ResponseBody把结果输出到浏览器，ajax请求处理完毕。</li></ul><h5 id="输出List集合"><a href="#输出List集合" class="headerlink" title="输出List集合"></a>输出List集合</h5><p>将List集合转换为JSON对象数组输出。</p><p>和上个例子差不多</p><p>处理器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/returnList.do&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">doList</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setName(<span class="hljs-string">&quot;赵大宝&quot;</span>);<br>    student.setAge(<span class="hljs-number">21</span>);<br>    list.add(student);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student1.setName(<span class="hljs-string">&quot;李二狗&quot;</span>);<br>    student1.setAge(<span class="hljs-number">22</span>);<br>    list.add(student1);<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><p>JS代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    $(<span class="hljs-string">&quot;#btn&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        $.<span class="hljs-title function_">ajax</span>(&#123;<br>            <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;returnList.do&quot;</span>,<br>            <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;get&quot;</span>,<br>            <span class="hljs-attr">dataType</span>:<span class="hljs-string">&quot;json&quot;</span>,<br>            <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>                $.<span class="hljs-title function_">each</span>(data, <span class="hljs-keyword">function</span> (<span class="hljs-params">i, n</span>)&#123;<br>                    <span class="hljs-title function_">alert</span>(n.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;  &quot;</span> + n.<span class="hljs-property">age</span>);<br>                &#125;)<br>            &#125;<br>        &#125;)<br><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201217134624351.png" alt="image-20201217134624351" style="zoom:73%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201217134613989.png" alt="image-20201217134610237" style="zoom:50%;" /></p><h5 id="返回文本数据"><a href="#返回文本数据" class="headerlink" title="返回文本数据"></a>返回文本数据</h5><p>处理器方法返回的是String类型，这里String表示数据，而不是视图。</p><p><strong>区分返回值String是数据还是视图的方法：</strong></p><p><strong>如果有注解@ResponseBody，那么就是数据；没有，就是视图</strong></p><p>返回String时，默认使用”text/plain;charset=ISO-8859-1”作为contentType，中文会出现乱码。（虽然在web.xml设置了拦截器，强制设置编码方式，但好像对这个没有效果）</p><p>解决方案：在@RequestMapping注解中加上属性produces = “text/plain;charset=utf-8”，来指定新的contentType</p><p>处理器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/returnStringData.do&quot;, produces = &quot;text/plain;charset=utf-8&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doStringData</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回的是文本数据&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>JS代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    $(<span class="hljs-string">&quot;#btn&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        $.<span class="hljs-title function_">ajax</span>(&#123;<br>            <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;returnStringData.do&quot;</span>,<br>            <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;get&quot;</span>,<br>            <span class="hljs-comment">// dataType:&quot;json&quot;,</span><br>            <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>                <span class="hljs-title function_">alert</span>(data);<br>            &#125;<br>        &#125;)<br><br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201217141214840.png" alt="image-20201217141214840" style="zoom:50%;" /></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-Spring-MVC基础</title>
    <link href="/2022/05/11/Spring-MVC/1-Spring-MVC%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/11/Spring-MVC/1-Spring-MVC%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>SpringMVC是一个基于Spring的框架，是Spring的一个模块，专门用来作web开发。</p><p>web开发的底层是Servlet，框架是在Servlet的基础上加入一些功能，封装一些功能，使得web开发更加方便。</p><p>SpringMVC和Spring一样，能够创建对象，并放入到SpringMVC容器中。SpringMVC容器中放的是控制器对象。</p><p>SpringMVC中有一个Servlet类：DispatherServlet，<strong>叫中央调度器</strong></p><p>​        它负责接受用户的所有请求，用户把请求给DispatherServlet，然后DispatherServlet把请求转发给Controller对象，由Controller对象处理请求。</p><p>DispatherServlet主要使用注解来进行开发，使用@Controller创建控制器对象，并把该对象放入SpringMVC容器中。当做一个Servlet对象，<strong>但它不是Servlet，是一个普通类的对象，只是SpringMVC赋予了控制器对象额外的功能。</strong></p><h2 id="DispatherServlet"><a href="#DispatherServlet" class="headerlink" title="DispatherServlet"></a>DispatherServlet</h2><p>​        DispatherServlet是SpringMVC的一个核心类，叫做中央调度器，或者前端控制器。它把用户的请求转发给Controller对象，并把Controller返回的结果再返回给用户。</p><p>​        <strong>同时，DispatherServlet创建的时候，会同时把SpringMVC容器也创建出来，把该容器放入ServletContext中，并读取SpringMVC配置文件中的内容，把Controller对象创建出来。</strong></p><p>​        需要在web.xml文件中注册该对象，格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>要加上<load-on-startup>标签，来使该对象在服务器启动时就创建出来，同时创建出SpringMVC容器来。这个标签中应该填一个大于等于0的数，数越小，创建顺序的优先级越高。</p><p>其中<url-pattern>的值有两种类型：</p><ul><li><p>使用拓展名方式，语法是<code>*.xxx</code>，其中xxx是自定义的拓展名，常用的有<code>*.do</code>、<code>*.action</code>、<code>*.mvc</code>等</p><p>  它表示，凡是以该拓展名结尾的全都交给这个中央调度器处理，例如值时<code>*.do</code>，那么url为<a href="http://localhost:80/myweb.some.do请求，以`.do`结尾，会交给该中央调度器处理">http://localhost:80/myweb.some.do请求，以`.do`结尾，会交给该中央调度器处理</a></p><p>  使用斜杠<code>/</code></p></li></ul><p>在默认情况下，SpringMVC读取Springmvc配置文件的路径为/WEB-INF/<servlet-name>-servlet.xml。</p><p>也就是说，上面注册中央调度器的name加上<code>-servlet</code>，例如上面<servlet-name>是springmvc，那么默认读取配置文件路径为<code>WEB-INF/springmvc-servlet.xml</code>。</p><p>很不方便，因此<strong>在<servlet>标签内</strong>可以使用<init-param>标签来自定义springmvc配置文件位置，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xmk">&lt;init-param&gt;<br>    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br>    &lt;param-value&gt;classpath:&lt;/param-value&gt;<br>&lt;/init-param&gt;<br></code></pre></td></tr></table></figure><p><param-name>的值固定不变，classpath后加上自定义配置文件路径。</p><p>最终格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>以一个很简单的例子来说明一下SpringMVC是如何使用的。</p><p>在前端页面发起一个请求，然后显示欢迎界面。</p><h3 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h3><p>在新建的maven项目中加入spring-webmvc依赖，这个依赖同时也包含了spring的核心依赖(不包含spring-jdbc、spring-tx、spring-aspectj依赖)。同时加入servlet和jsp依赖。</p><h3 id="在web-xml文件中注册DispatherServlet"><a href="#在web-xml文件中注册DispatherServlet" class="headerlink" title="在web.xml文件中注册DispatherServlet"></a>在web.xml文件中注册DispatherServlet</h3><p>使用前面讲的语法格式来注册中央调度器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>springmvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>*.do<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建发起请求的页面"><a href="#创建发起请求的页面" class="headerlink" title="创建发起请求的页面"></a>创建发起请求的页面</h3><p>request.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>请求页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;some.do&quot;</span>&gt;</span>发出一个请求<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建控制器类"><a href="#创建控制器类" class="headerlink" title="创建控制器类"></a>创建控制器类</h3><p>在controller包中创建一个<strong>普通类</strong>，名字随意。<strong>在类上面加上@Controller注解，表明这是一个控制器对象。</strong></p><p>在其中创建一个方法，返回值是ModelAndView，它是Spring-web中的一个类，Model代表数据，View表示页面</p><p>没有参数。</p><p><strong>在方法上加上注解@RequestMapper，该注解有个value属性，字符串类型，是唯一的，</strong></p><p><strong>值是对应请求地址uri，推荐加上<code>/</code>，该注解把一个请求和一个方法映射起来。</strong></p><p><strong>也就是当发起这个请求时，DispatherServlet会把该请求转发给这个方法。</strong></p><p><strong>若有多个请求地址匹配该方法，则value值可以写上一个数组。</strong></p><p>加上注解@RequestMapper的方法叫做<strong>控制器方法</strong>，或者处理器方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br>    <span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mv</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>();<br>        mv.addObject(<span class="hljs-string">&quot;param1&quot;</span>, <span class="hljs-string">&quot;开心&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;param2&quot;</span>, <span class="hljs-string">&quot;快乐&quot;</span>);<br>        mv.setViewName(<span class="hljs-string">&quot;/hello.jsp&quot;</span>);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建欢迎页面"><a href="#创建欢迎页面" class="headerlink" title="创建欢迎页面"></a>创建欢迎页面</h3><p>在WEB-INF/jsp目录中创建一个欢迎页面hello.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;欢迎页面&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;<br>    &lt;h2&gt;欢迎使用SringMVC做Web开发&lt;/h2&gt;<br>    &lt;h3&gt;$&#123;param1&#125;&lt;/h3&gt;<br>    &lt;h3&gt;$&#123;param2&#125;/h3&gt;<br>&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h3><p>在resources目录中，创建springmvc.xml配置文件。和spring配置文件一样，可以直接使用spring配置文件模板。</p><p>在其中：</p><ul><li><p>声明组件扫描器，用来扫描所有的注解，属性base-package指定@Controller注解所在的包名</p></li><li><p>声明视图扫描器，用来帮助处理视图。</p><p>  SpringMVC框架为了避免对于请求资源路径和拓展名的冗余，在视图解析器InternalResourceViewResolver中引入了请求的前缀和后缀，而ModelAndView只需要给出跳转页面的文件名即可。对于具体的文件路径和拓展名，视图解析器会自定完成拼接。</p><p>  语法格式为：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.example.controller&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;文件路径(文件所在目录)&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;拓展名，以.开头&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  这里使用：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;org.example.controller&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/jsp&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  那么在MyController的doSome方法中，<code>mv.setViewName(&quot;/WEB-INF/jsp/hello.jsp&quot;)</code></p><p>  改成<code>mv.setViewName(&quot;hello&quot;)</code>即可。</p></li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>运行时出现了错误，出现了NoSuchMethodError，找不到对应方法。</p><p>找了各种各样的解决方法。最后找到了问题。是因为Tomcat版本和pom文件引入的Servlet依赖版本不一致导致的。</p><p>我的Tomcat服务器版本是8.5.59，对应的Servlet版本应该是<code>3.1.*</code>，对应jsp版本应该是2.3.*</p><p>下图是对应关系：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201208121209461.png" alt="image-20201208121209461" style="zoom:50%;" /></p><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201208121501667.png" alt="image-20201208121501667" style="zoom:50%;" /></p><h2 id="SpringMVC处理请求的流程"><a href="#SpringMVC处理请求的流程" class="headerlink" title="SpringMVC处理请求的流程"></a>SpringMVC处理请求的流程</h2><p>以上面的例子，来说明SpringMVC处理请求的流程</p><ol><li><p>用户发起some.do请求</p></li><li><p>tomcat服务器通过配置文件web.xml直到some.do的请求应该给DispatherServlet</p></li><li><p>DispatherServlet根据springmvc配置文件springmvc.xml知道要把请求转发给doSome()方法</p></li><li><p>doSome方法处理请求，返回ModelAndView对象</p></li><li><p>框架把doSome返回的ModelAndView给视图解析器进行处理，视图解析器返回hello.jsp文件</p></li></ol><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201208123400687.png" alt="image-20201208123400687" style="zoom:50%;" /></p><p>抽象出来，并更加细致的解释SpringMVC处理请求的流程</p><ul><li><p>浏览器提交请求到中央调度器 </p></li><li><p>中央调度器直接将请求转给处理器映射器。</p></li><li><p>处理器映射器会根据请求，找到处理该请求的处理器，并将其封装为处理器执行链后 返回给中央调度器。 </p></li><li><p>中央调度器根据处理器执行链中的处理器，找到能够执行该处理器的处理器适配器。 </p></li><li><p>处理器适配器调用执行处理器。 </p></li><li><p>处理器将处理结果及要跳转的视图封装到一个对象 ModelAndView 中，并将其返回给 处理器适配器。 </p></li><li><p>处理器适配器直接将结果返回给中央调度器。 </p></li><li><p>中央调度器调用视图解析器，将 ModelAndView 中的视图名称封装为视图对象。</p></li><li><p>视图解析器将封装了的视图对象返回给中央调度器 </p></li><li><p>中央调度器调用视图对象，让其自己进行渲染，即进行数据填充，形成响应对象。 </p></li><li>中央调度器响应浏览器。</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201208123559367.png" alt="image-20201208123559367" style="zoom:50%;" /></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-MyBatisPlus</title>
    <link href="/2022/05/11/MyBatis/10-MyBatis-Plus/"/>
    <url>/2022/05/11/MyBatis/10-MyBatis-Plus/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>​    </p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis-Plus是MyBatis的增强工具。在MyBatis上，只做增强，不做改变。目的是简化开发，提高效率。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>无侵入：就是只做增强，不做改变。不会影响现有工程</li><li>损耗小：启动会自动注入基本的CRUD，性能基本无损耗</li><li>强大的CRUD操作：内置了通用的Mapper，通用的Service。也有强大的条件构造器</li><li>支持Lambda形式调用：使用Lambda表达式编写各类查询条件</li><li>支持主键自动生成：支持四种主键策略</li><li>内置代码生成器：采用代码或者Maven插件，可以直接生成Mapper、Model、Service、Controlloer代码</li><li>内置分页插件</li><li>支持多种数据库</li><li>内置性能分析插件</li><li>内置全局拦截插件</li></ol><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><ol><li>首先创建一张表，或者使用现成的表也可以。</li></ol><p>使用的表：student<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205113108645.png" alt="image-20210205113108645" style="zoom:67%;" /></p><ol><li><p>创建一个SpringBoot项目</p></li><li><p>添加mysql依赖，mybatis-plus依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在<code>application.properties</code>配置mysql</p><p> <img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205113510725.png" alt="image-20210205113510725" style="zoom:50%;" /></p></li><li><p>在包entity中创建实体类Student</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> String age;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>注意：</strong></p><p> <strong>实体类名字一定要和表名一致，大小写不区分。</strong></p><p> <strong>属性名和表中列名要保持一致，表中列名尽量使用<code>_</code>符号。代表前后是两个单词，MyBatis-Plus会把后面一个单词第一个字母大写，并去掉<code>_</code>例如列名<code>user_name</code>，会对应<code>userName</code>。</strong></p></li><li><p>在包dao中创建StudentMapper接口，继承MyBatis-Plus提供的通用Mapper接口<code>BaseMapper&lt;T&gt;</code>，泛型就是对应的实体类。加上注解<code>@Mapper</code>。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Student&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p> 这样就写完了基本的CRUD操作了。这些方法都由<code>BaseMapper</code>写好了。</p></li><li><p>测试</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMybatisPlus</span><span class="hljs-params">()</span> &#123;<br>       List&lt;Student&gt; students = studentMapper.selectList(<span class="hljs-literal">null</span>);<br>       students.forEach(System.out::println);<br>    <br>   &#125;<br></code></pre></td></tr></table></figure><p> 测试结果：</p><p> <img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205113948108.png" alt="image-20210205113948108" style="zoom:67%;" /></p></li></ol><p>可以看到，使用MyBatis-Plus，代码量很少。不需要写SQL语句，xml文件。</p><h2 id="配置日志输出"><a href="#配置日志输出" class="headerlink" title="配置日志输出"></a>配置日志输出</h2><p>在<code>application.properties</code>配置文件中配置数据库日志输出</p><p><code>mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code>。</p><p>代表标准输出。</p><h2 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h2><p>当进行插入操作时，如果没有指定主键。但主键又不能为空。所有这时候就需要生成主键。</p><h3 id="TableId"><a href="#TableId" class="headerlink" title="@TableId"></a><code>@TableId</code></h3><p>使用注解<code>@TableId</code>来标记一个表的注解。该注解应放在实体类中对应主键的属性上。</p><p>该注解有两个属性：</p><ul><li>value：字段名，可有可无。默认是空字符串</li><li>type：类型</li></ul><p>需要设置的就是type类型，值是一个枚举类型：</p><ul><li><code>IdType.AUTO</code>：表示表中主键是自增ID，使用该值，则表的主键必须是自增ID，否则没用</li><li><code>IdType.NONE</code>：为设置主键类型，等于跟随全局，约等于INPUT</li><li><code>IdType.INOUT</code>：表示需要手动输入，如果没输入，就设为null</li><li><code>IdType.ASSIGN_ID</code>：自动分配ID，使用雪花算法(主键类型为number或string)</li><li><code>IdType.ASSIGN_UUID</code>：自动分配ID，使用UUID算法</li></ul><p>如不指定，默认使用<code>IdType.NONE</code>。</p><p>还有三种<code>`IdType.ID_WORDKER</code>、<code>IdType.UUID</code>、<code>IdType.ID_WORKER_STR</code>，已经被抛弃不使用了。</p><p>前三种无需介绍，详细介绍后两种。</p><h3 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h3><p>SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。其核心思想就是：使用一个 64 bit 的 <strong>long</strong> 型的数字作为全局唯一 id。在分布式系统中的应用十分广泛，且ID 引入了时间戳，基本上保持自增的。</p><p>这64位中，分为4部分：</p><ol><li>占一位：固定是0</li><li>占41位：表示时间戳，单位毫秒。存储的是(当前时间戳-开始时间戳)，开始时间戳一般是id生成器开始使用的时间，由程序指定，41位，可以用69年。也就是从开始时间一直用69年，才会用完所有数字</li><li>占10位：表示程序所在机器信息。也表示该服务最多可部署在$2^{10}$台机器上。其中5个bit代表机房id，5个bit代表机器id</li><li>占12位：用来记录同一毫秒产生的不同id，即，如果前面所有都一样，这部分用来区分不同id。占12位，表示一毫秒可生产$2^{12}$个不同的id，即4096个id</li></ol><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205161158740.png" alt="image-20210205161158740" style="zoom:70%;" /></p><h3 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h3><p>不过多介绍。</p><p>UUID有16个字节，通常以36字节字符串表示。</p><p>UUID有多个版本，版本不同，实现的方式不同。</p><h2 id="更新操作"><a href="#更新操作" class="headerlink" title="更新操作"></a>更新操作</h2><p>​    <code>BaseMapper&lt;T&gt;</code>接口提供了两个更新操作相关方法。</p><p><strong><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205165816947.png" alt="image-20210205165816947" style="zoom:80%;" /></strong></p><p>第一个方法先不讲。</p><p>第二个方法，参数对应实体类对象。</p><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>在更新操作时，传入一个实体类对象，MyBatis-Plus会动态拼接SQL语句，当属性值不为空，则更新该属性；当属性值为null，就不会更新。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setId(<span class="hljs-number">1013</span>);<br>    student.setAge(<span class="hljs-number">43</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> studentMapper.updateById(student);<br>    System.out.println(i);<br>    System.out.println(i == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;更新成功&quot;</span>: <span class="hljs-string">&quot;更新失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>只设置了主键ID和年龄。日志：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205170259420.png" alt="image-20210205170259420" style="zoom:80%;" /></p><p>可以看到，SQL语句只更新了age。</p><p>加上<code>student.setEmail(&quot;wusong@qq.com&quot;)</code></p><p>再次执行效果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205170406889.png" alt="image-20210205170406889" style="zoom:67%;" /></p><p>可以看到，已经加上了email字段。</p><p>所以MyBatis-Plus会动态拼接SQL语句。</p><h3 id="自动填充字段"><a href="#自动填充字段" class="headerlink" title="自动填充字段"></a>自动填充字段</h3><p>有时候，一些字段，不应该手动传值更新，例如创建时间，修改时间。这些应该要自动地进行修改。</p><p>MyBatis-Plus提供了这样的功能。</p><h4 id="TableField"><a href="#TableField" class="headerlink" title="TableField"></a><code>TableField</code></h4><p>该注解用于非主键的属性。</p><p>该注解有以下几个属性：</p><div class="table-container"><table><thead><tr><th>属性</th><th>类型</th><th>说明</th><th>默认值</th><th>必须指定</th></tr></thead><tbody><tr><td><code>value</code></td><td><code>String</code></td><td>数据库字段名</td><td><code>&quot;&quot;</code></td><td></td></tr><tr><td><code>el</code></td><td><code>String</code></td><td>映射为原生<code>#&#123;..&#125;</code>逻辑，<br>相当于xml文件里的<code>#&#123;...&#125;</code>部分</td><td><code>&quot;&quot;</code></td><td></td></tr><tr><td><code>exist</code></td><td><code>Boolean</code></td><td>是否为数据库表字段</td><td><code>true</code></td><td></td></tr><tr><td><code>condition</code></td><td><code>String</code></td><td>字段<code>where</code>实体查询比较的条件<br>有值按设置的值为准，没有则默认全局</td><td><code>&quot;&quot;</code></td><td></td></tr><tr><td><code>update</code></td><td><code>String</code></td><td>字段<code>update set</code>部分注入，<br>例如<code>update=&quot;%s+1&quot;</code>，表示更新时会<br>set version = version + 1</td><td><code>&quot;&quot;</code></td><td></td></tr><tr><td><code>insertStrategy</code></td><td><code>Enum</code></td><td>自动插入字段时的插入策略</td><td><code>DEFAULT</code></td><td></td></tr><tr><td><code>updateStrategy</code></td><td><code>Enum</code></td><td>自动更新字段时的更新策略</td><td><code>DEFAULT</code></td><td></td></tr><tr><td><code>whereStrategy</code></td><td><code>Enum</code></td><td>测试该字段是否为null或空字符串</td><td><code>DEFAULT</code></td><td></td></tr><tr><td><strong><code>fill</code></strong></td><td><code>Enum</code></td><td>字段自动填充策略</td><td><code>FieldFill.DEFAULT</code></td><td></td></tr><tr><td><code>select</code></td><td><code>boolean</code></td><td>是否进行select查询</td><td><code>true</code></td><td></td></tr><tr><td><code>keepGlobalFormat</code></td><td><code>boolean</code></td><td>是否保持使用全局format进行处理</td><td><code>false</code></td><td></td></tr><tr><td><code>jdbcType</code></td><td><code>jdbcType</code></td><td>JDBC类型</td><td><code>jdbcType.UNDEFINED</code></td><td></td></tr><tr><td><code>typeHandler</code></td><td><code>Class&lt;? extends TypeHandler&gt;</code></td><td>类型处理器</td><td><code>UnknownTypeHandler.clss</code></td><td></td></tr><tr><td><code>numericScale</code></td><td><code>String</code></td><td>指定小数点后保留位数</td><td><code>&quot;&quot;</code></td></tr></tbody></table></div><p>其中需要使用的是<code>fill</code>属性。</p><p>共有4种值：</p><ul><li><code>FieldFill.DEFAULT</code>：不处理，默认值</li><li><code>FieldFill.INSERT</code>：插入时填充字段</li><li><code>FieldFill.UPDATE</code>：更新时填充字段</li><li><code>FieldFill.INSERT_UPDATE</code>：插入和更新时填充字段</li></ul><p>如果只想在添加一行数据时填充指定字段，更新时不再填充，例如<code>create_time</code>创建时间，那么就使用<code>FieldFill.INSERT</code></p><p>而想在添加和更新数据时都填充指定字段，使用<code>FieldFill.INSERT_UPDATE</code>。</p><p>可以实现<code>MetaObjectHandler</code>接口来实现自定义填充策略。</p><p>实现两个方法：</p><ul><li><code>void insertFill(MetaObject metaObject)</code>：插入策略，fill属性使用了<code>FieldFill.INSERT</code>或<code>FieldFill.INSERT_UPDATE</code>策略的会调用该方法</li><li><code>void updateFill(MetaObject metaObject)</code>：更新策略，fill属性使用了<code>FieldFill.UPDATE</code>或<code>FieldFill.INSERT_UPDATE</code>策略会调用该方法</li></ul><p><code>MetaObject</code>代表元数据。</p><p>并在两个方法中调用<code>this.setFieldValByName(String fieldName, Object val, MetaObject metaObject);</code></p><p>其中：</p><ul><li>fieldName：代表属性名称，例如要更新<code>createTime</code>字段，那么这个值就是<code>createTime</code></li><li>val：属性值，例如更新<code>createTime</code>字段，那么就可以赋值<code>new Date()</code></li><li>metaObject：传入方法参数的那个metaObject即可</li></ul><p>注意：</p><ul><li>填充的原理就是直接给实体类对应属性赋值</li><li>MetaObjectHandler提供的默认策略是：如果属性有值则不覆盖，填充值为null则不填充</li><li>自定义填充处理器需要加上<code>@Component</code>注解，来交给Spring容器管理</li><li>如需要输出日志，则加上注解<code>@Slf4j</code></li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>首先在实体类中添加两个属性，并加上注解<code>@TableField</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br><span class="hljs-keyword">private</span> Date createTime;<br><span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br><span class="hljs-keyword">private</span> Date updateTime;<br></code></pre></td></tr></table></figure><p>首先创建一个填充处理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MetaObjectHandler</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;插入填充开始&quot;</span>);<br>        <span class="hljs-built_in">this</span>.setFieldValByName(<span class="hljs-string">&quot;createTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), metaObject);<br>        <span class="hljs-built_in">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), metaObject);<br>        log.info(<span class="hljs-string">&quot;插入填充结束&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> &#123;<br>        log.info(<span class="hljs-string">&quot;更新填充开始&quot;</span>);<br>        <span class="hljs-built_in">this</span>.setFieldValByName(<span class="hljs-string">&quot;updateTime&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(), metaObject);<br>        log.info(<span class="hljs-string">&quot;更新填充结束&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进行插入操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setId(<span class="hljs-number">1014</span>);<br>    student.setName(<span class="hljs-string">&quot;如来佛祖&quot;</span>);<br>    student.setAge(<span class="hljs-number">1000</span>);<br>    student.setEmail(<span class="hljs-string">&quot;rulai@163.com&quot;</span>);<br>    studentMapper.insert(student);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这里并没有写<code>createTime</code>和<code>upateTime</code></p><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205173912472.png" alt="image-20210205173912472"></p><p>并且打印出自定义的日志：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205173953002.png" alt="image-20210205173953002"></p><p>进行更新操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setId(<span class="hljs-number">1014</span>);<br>    student.setAge(<span class="hljs-number">1200</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> studentMapper.updateById(student);<br>    System.out.println(i);<br>    System.out.println(i == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;更新成功&quot;</span>: <span class="hljs-string">&quot;更新失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205174143487.png" alt="image-20210205174143487"></p><p>打印出自定义日志：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210205174202105.png" alt="image-20210205174202105"></p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><h4 id="并发控制介绍"><a href="#并发控制介绍" class="headerlink" title="并发控制介绍"></a>并发控制介绍</h4><p>并发控制：当程序可能出现并发的情况时，就需要保证在并发状态下数据的准确性，以确保当前用户和其他用户一起操作时，得到的结果和单独操作时的结果是一样的，这种手段就是并发控制。</p><p>简单来说：并发控制就是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。</p><p>如果没有做好并发控制，就会导致<strong>脏读</strong>、<strong>幻读和不可重复读</strong>等问题。</p><p>首先明确：乐观锁和悲观锁，都是定义出来的概念，是一种思想。</p><p><strong>乐观锁用于读多写少的场景，悲观锁用于写多读少的情况。</strong></p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>介绍：</p><p>​    当对数据库数据进行修改时，为了避免同时被其他人修改，最好的办法是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式称为悲观并发控制。</p><p>​    悲观锁，具有独占和排他特性，之所以叫悲观锁，是因为它总是假设最坏的情况，每次读取数据时都默认其他线程会更改数据。</p><p>悲观锁的实现：</p><ul><li>传统关系型数据库使用这种锁机制，例如行锁，表锁，读锁，写锁等，都是在操作前先上锁</li><li>Java中的同步<code>synchronized</code>关键字</li></ul><p>悲观锁主要分为<strong>共享锁</strong>和<strong>排它锁</strong>：</p><ul><li>共享锁又称为读锁，简称S锁。共享锁是多个事务对于统一数据可以共享一把锁，都可以访问数据，但不能修改只能读</li><li>排它锁称为写锁，简称X锁。排它锁不能与其他锁并存，如果一个事务获取了一个数据的排它锁，那么其他事务就不能再获取该数据的其他锁，包括共享锁和排它锁。获取排它锁的事务可以对数据进行读取和修改</li></ul><p>说明：</p><p>​        悲观并发控制实际是“先取锁再访问”的保守策略，为数据处理安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外开销，也增加了产生死锁的机会，另外会降低并行性。</p><p>​    </p><h4 id="乐观锁-Optimistic-Locking"><a href="#乐观锁-Optimistic-Locking" class="headerlink" title="乐观锁(Optimistic Locking)"></a>乐观锁(Optimistic Locking)</h4><p>介绍：</p><p>​        乐观锁是相对悲观锁而言，乐观锁加上数据一般不会发生冲突，所以在数据进行提交更新时，才会正式对数据的冲突进行检测，如果冲突，则返回错误的信息，让用户决定如何去做。乐观锁适合读操作较多的场景。</p><p>乐观锁的实现：</p><ul><li>CAS实现</li><li>版本号控制：也是一会要介绍的。一般是在数据库表或你某个字段加上一个数据版本号version字段，表示数据被修改的次数。当数据被修改时，version值会+ 1，当线程A要更新数据值时，读取数据同时也读取version值，在提交更新时，若刚才读取的version和当前数据库version值一致才更新，否则重试更新操作，直到更新成功</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>MyBatis-Plus提供的插件都需要在配置类中注册组件。</p><p>首先创建配置类，并加上<code>@Configuration</code>，并创建一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title function_">mybatisPlusInterceptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">MybatisPlusInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MybatisPlusInterceptor</span>();<br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimisticLockerInnerInterceptor</span>());<br>    <span class="hljs-keyword">return</span> interceptor;<br>&#125;<br></code></pre></td></tr></table></figure><p>MyBatisPlusInterceptor是MyBatis-Plus提供的拦截器类，在方法中新建一个类，需要什么插件，就创建对应的插件接口实现类，并使用<code>addInnerInterceptor()</code>添加到拦截器中。</p><p>可用的插件接口实现类有：</p><ul><li><code>PaginationInnerInterceptor</code>：自动分页</li><li><code>TenanLineInnerInterceptor</code>：多租户</li><li><code>DynamicTableNameInnerInterceptor</code>：动态表名</li><li><code>OptimisticLockerInnerInterceptor</code>：乐观锁</li><li><code>IllegalSQLInnerInterceptor</code>：sql性能规范</li><li><code>BlockAttackInnerInterceptor</code>：防止全表更新和删除</li></ul><p>注：也可以在该配置类中加上注解<code>@MapperScan</code>，不加其实也行，因为DAO接口加上注解<code>@Mapper</code>，不需要扫描。</p><h3 id="MyBatis-Plus实现乐观锁"><a href="#MyBatis-Plus实现乐观锁" class="headerlink" title="MyBatis-Plus实现乐观锁"></a>MyBatis-Plus实现乐观锁</h3><p>MyBatis-Plus实现乐观锁非常简单。</p><p>在数据库表中加上一个字段<code>version</code>，可以是int类型，并设默认值为1</p><p>只要在实体类中添加定义一个属性<code>private Integer version</code>，并在其上加上注解<code>@Version</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Version</span><br><span class="hljs-keyword">private</span> Integer version;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>支持的数据类型只有：int、Integer、long、Long、Date、Timestamp、LocalDateTime</li><li>整数类型下 <code>newVersion = oldVersion + 1</code></li><li><code>newVersion</code>会写回到实体类中</li><li>只支持<code>updateById()</code>和<code>update(entity, wrapper)</code>方法</li><li>在<code>update(entity, wrapper)</code>方法中，wrapper不能复用</li></ul><p><strong>特别注意！注意！：只有在更新之前，进行查询操作，才会实现乐观锁，单纯的更新不会实现。</strong></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setId(<span class="hljs-number">1014</span>);<br>    student.setAge(<span class="hljs-number">34</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> studentMapper.updateById(student);<br>    System.out.println(i);<br>    System.out.println(i == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;更新成功&quot;</span>: <span class="hljs-string">&quot;更新失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这样写，是不会实现乐观锁的。因为获取不到version值。</p><p><strong>必须要在更新之前进行查询操作：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> studentMapper.selectById(<span class="hljs-number">1013</span>);<br>    student.setAge(<span class="hljs-number">34</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> studentMapper.updateById(student);<br>    System.out.println(i);<br>    System.out.println(i == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;更新成功&quot;</span>: <span class="hljs-string">&quot;更新失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样才会实现乐观锁。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210206180311794.png" alt="image-20210206180311794" style="zoom:80%;" /></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>自定义填充处理类不要忘记加注解<code>@Component</code></li><li>实体类属性上记得加注解<code>TableField</code>，并指定<code>fill</code>属性</li><li>实现乐观锁，一定要先进行查询操作。气死，TM弄了一天。</li></ol><h3 id="分页插件"><a href="#分页插件" class="headerlink" title="分页插件"></a>分页插件</h3><p>在配置类中添加：<code>interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));</code></p><p>即可注册分页插件，数据库类型是MYSQL。</p><p>然后使用Page类或IPage接口都可以。Page类实现了IPage接口。</p><p>使用Mapper类的两个方法：</p><ul><li><code>&lt;E extends IPage&lt;T&gt;&gt; E selectPage(E page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);</code></li><li><code>&lt;E extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; E selectMapsPage(E page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);</code></li></ul><p>使用上一种方式较多。</p><p>使用方法：</p><ol><li>根据给定参数 当前页码和每页数据量创建Page对象。</li><li>在服务层调用mapper对象的上述两个方法</li><li>使用Page对象获得查询到的使用</li></ol><p>例子：</p><ol><li><p>创建服务层方法：<code>public Page&lt;Categories&gt; list(Page&lt;Categories&gt; page);</code></p></li><li><p>在继承类实现该方法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Page&lt;Categories&gt; <span class="hljs-title function_">list</span><span class="hljs-params">(Page&lt;Categories&gt; page)</span> &#123;<br>    Page&lt;Categories&gt; categoriesPage = categoriesMapper.selectPage(page, <span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">return</span> categoriesPage;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol><li>使用传入的参数或返回值(这俩是一个Page对象)来获得查询到的数据和相关数据</li></ol><ol><li><p>在控制层创建Page对象，并调用服务层方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getCategories</span><span class="hljs-params">(Integer pageNumber, Integer limit)</span> &#123;<br>    Page&lt;Categories&gt; page = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Page</span>&lt;&gt;(pageNumber, limit);<br>    Page&lt;Categories&gt; list = categoriesService.list(page);<br>    List&lt;Categories&gt; records = page.getRecords();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>注意：</strong></p><ol><li>如果自定义方法实现分页，并调用了mapper的分页方法(就是刚说的两个方法)，<strong>如果返回值是Page对象(和例子一样)，那么传来的参数Page对象不能为空，因为返回值Page对象和参数Page对象就是一个对象。</strong></li><li>如果返回值是List集合，那么参数Page对象就可以为空，表示不进行分页。</li></ol><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p><code>BaseMapper</code>有几种查询方法：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210221130459868.png" alt="image-20210221130459868" style="zoom:67%;" /></p><p>挨个介绍：</p><ul><li><p><code>List&lt;T&gt; selectBatchIds(Collection&lt;? extends Serializable&gt;)</code>：以Id为查询条件做批量查询，即可同时查询多个Id匹配的行，参数是一个集合，可以是List、Set和Queue，返回值是一个List集合</p><p>  例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelect</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Student&gt; students = studentMapper.selectBatchIds(Arrays.asList(<span class="hljs-number">1001</span>, <span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>));<br>    students.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>  结果：</p><p>  ​    <img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210221131546875.png" alt="image-20210221131546875"></p></li><li><p><code>T selectById(Serializable)</code>：单个查询，返回值是对应实体类</p><p>  例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelect</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> studentMapper.selectById(<span class="hljs-number">1001</span>);<br>    System.out.println(student);<br>&#125;<br></code></pre></td></tr></table></figure><p>  运行结果：</p><p>  <img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210221131708309.png" alt="image-20210221131708309" style="zoom:150%;" /></p></li><li><p><code>List&lt;T&gt; selectByMap(Map&lt;String, Object&gt;)</code>：条件查询，使用Map对象，key是String，代表属性名；Object代表属性值。多个key/value对，使用and连接。</p><p>  例子：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelect</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">HashMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>    map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;刘备&quot;</span>);<br>    List&lt;Student&gt; students = studentMapper.selectByMap(map);<br>    students.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><pre><code class="hljs">运行结果：![image-20210221132145371](https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210221132145371.png)例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelect</span><span class="hljs-params">()</span> &#123;<br>    HashMap&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;刘备&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;age&quot;</span>, <span class="hljs-string">&quot;76&quot;</span>);<br>    List&lt;Student&gt; students = studentMapper.selectByMap(map);<br>    students.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>运行结果：![image-20210221132308173](https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210221132308173.png)</code></pre><p>后面七个方法都使用了Wrapper条件构造类来设定查询条件。后面再讲。</p><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>首先来讲一下逻辑删除和物理删除。</p><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>逻辑删除的本质就是更新或者修改操作。它并不是真的把数据删除。而是在表中将对应的是否删除标识(如deleted属性或is_delete属性)，做修改操作。例如0是未删除，1是删除。如果该字段修改为1，那么在逻辑上数据是被删除的，但是数据依然存在在数据库中。</p><h3 id="物理删除"><a href="#物理删除" class="headerlink" title="物理删除"></a>物理删除</h3><p>与之对应的就是物理删除，就是实实在在的删除。数据不会存在在数据库中。</p><p>这两种删除的一个应用就是回收站。在将文件加入回收站时，并不会删除，而只是把对应删除标识修改，从回收站恢复该文件，则再修改标识，这是逻辑删除；而清空回收站就是物理删除。</p><h3 id="MyBatis-Plus的删除操作"><a href="#MyBatis-Plus的删除操作" class="headerlink" title="MyBatis-Plus的删除操作"></a>MyBatis-Plus的删除操作</h3><p>几个方法：</p><ul><li><code>int delete(Wrapper&lt;T&gt;)</code>：使用Wrapper构造条件删除</li><li><code>deleteById(Serializable)</code>：根据主键删除</li><li><code>deleteByMap(Map&lt;String, Object&gt;)</code>：根据Map集合删除</li><li><code>deleteBatchIds(Collection&lt;? extends Serializable&gt;)</code>：根据集合删除</li></ul><p>用法基本都和查询操作差不多。不多讲。</p><p>重点讲一下如何实现逻辑删除。</p><h3 id="实现逻辑删除"><a href="#实现逻辑删除" class="headerlink" title="实现逻辑删除"></a>实现逻辑删除</h3><ol><li><p>在表中添加deleted字段，类型为boolean或int，默认值是false或0，不为空。</p></li><li><p>在配置文件中配置：</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybatis-plus.global-config.db-config.logic-not-delete-value</span>=<span class="hljs-string">0</span><br><span class="hljs-attr">mybatis-plus.global-config.db-config.logic-delete-value</span>=<span class="hljs-string">1</span><br></code></pre></td></tr></table></figure></li><li><p>在实体类deleted属性上添加注解<code>@TableLogic</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableLogic</span><br><span class="hljs-keyword">private</span> Boolean deleted;<br></code></pre></td></tr></table></figure><p> 就可以了。</p></li></ol><p>实现了逻辑删除后，MyBatis-Plus一系列CRUD操作会发生改变：</p><ul><li>插入操作：不作限制，推荐字段在数据库设置默认值</li><li>查询操作：追加where条件来过滤已删除数据，如<code>where deleted = 0</code></li><li>更新操作：追加where条件防止更新已删除数据</li><li>删除操作：转变为更新操作，即<code>update tablename set deleted = 1 where ...</code></li></ul><p>字段类型支持说明：</p><ul><li>支持所有数据类型，推荐使用Integer、Boolean和LocalDateTime</li><li>如果数据库字段使用datetime，逻辑未删除值和已删除值支持配置为字段串<code>null</code>，另一个值致辞配置为函数来获取值如<code>now()</code></li></ul><p>例子：</p><p>删除操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDelete</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> studentMapper.deleteById(<span class="hljs-number">1044</span>);<br>    System.out.println(i);<br>    System.out.println(i == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;删除成功&quot;</span> : <span class="hljs-string">&quot;删除失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210221140256573.png" alt="image-20210221140256573"></p><p>查询操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selectAll</span><span class="hljs-params">()</span> &#123;<br>    List&lt;Student&gt; students = studentMapper.selectList(<span class="hljs-literal">null</span>);<br>    students.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210221140352545.png" alt="image-20210221140352545"></p><h2 id="条件构造器"><a href="#条件构造器" class="headerlink" title="条件构造器"></a>条件构造器</h2><p>MyBatis-Plus有一个条件构造抽象类Wrapper，它是用来构造复杂的where条件的。</p><p>Wrapper有几个子类：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20210221141448914.png" alt="image-20210221141448914" style="zoom:80%;" /></p><p>主要就分为查询和更新对应Wrapper类。</p><h3 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h3><p>首先介绍抽象类AbstractWrapper有的方法：</p><p>注意：</p><ul><li>出现的方法中第一个形参condition表示该条件是否加入最后生成的sql中</li><li>在形参中出现的R为泛型，在普通wrapper中是String，在LanbdaWrapper中是函数</li><li>以下方法出现的<code>R column</code>均表示数据库字段，而不是实体类数据库字段名。</li><li>使用中如果形参的Map或List为空，则不会加入最后生成的sql中</li></ul><p>为了方便，不会再写含有形参condition的方法。condition形参永远放在第一个参数位置。</p><p>方法：</p><ul><li><p><code>allEq(Map&lt;R, V&gt; params)</code><br><code>allEq(Map&lt;R, V&gt; params, boolean null2IsNull)</code><br></p><p>  说明：</p><p>  全部相等(或个别isNull)<br><code>params</code>：key为数据库字段名，value为字段值<br><code>null2IsNull</code>：为true则在map的value为空时调用<code>isNull</code>方法，false则忽略vaue为空的字段</p><p>  示例：</p><p>  <code>allEq(&#123;id:1, name:&quot;Jack&quot;, age :null&#125;)</code>—&gt;<code>id = 1 and name = Jack and age is null</code></p><p>  <code>allEq(&#123;id:1, name:&quot;Jack&quot;, age :null&#125;, false)</code>—&gt;<code>id = 1 and name = Jack</code></p></li></ul><hr><pre><code class="hljs">`between(R column, Object val1, Object val2)``notBetween(R column, Object val1, Object val2)`说明：前两个表示指定字段值在设定两个值之间，闭区间，即`[2,6]`；后两个方法表示不在两个设定值之间，开区间，即($-\infty$, 2) &amp; (6, $+\infty$)示例：`between(&quot;age&quot;, 18 ,30)`--&gt;`age between 18 and 30``notBetween(&quot;age&quot;, 18 ,30)`--&gt;`age not between 18 and 30`---</code></pre><p>​    </p><ul><li><p><code>like(R column Object val)</code></p><p>  <code>notLike(R column, Object val)</code></p><p>  说明：Like ‘%值val%’；NotLike ‘%值val%’</p><p>  示例：</p><p>  <code>like(&quot;name&quot;, &#39;k&#39;)</code>—&gt;<code>name like &#39;%k%&#39;</code></p><p>  <code>notLike(&quot;name&quot;, &#39;k&#39;)</code>—&gt;<code>name not like &#39;%k%&#39;</code></p></li></ul><pre><code class="hljs">根据`%`位置，还有`likeLeft(R column, Object val)`和`likeRight(R column, Object val)`两个方法。分别对应`%`放在左边和右边。---</code></pre><ul><li><p><code>isNull(R column)</code></p><p>  <code>isNotNull(R column)</code></p><p>  说明：</p><ul><li>第一个判断字段为空</li><li><p>第二个判断字段不为空</p><p>示例：<br><code>isNull(&quot;name&quot;)</code>—&gt;<code>name is null</code></p><p><code>isNotNull(&quot;name&quot;)</code>—&gt;<code>name is not null</code></p></li></ul><hr></li><li><p><code>is(R column, Collection&lt;?&gt; value)</code></p><p>  <code>is(R column, Object... values)</code></p></li></ul><pre><code class="hljs">`notIn(R column, Collection&lt;?&gt; value)``notIn(R column, Object... values)`说明：- 前两个使用in关键词- 后两个使用not in关键词示例：`in(&quot;age&quot;, &#123;1, 2, ,3&#125;)`--&gt;`age in (1, 2, 3)``in(&quot;age&quot;, 1, 2, 3)`--&gt;`age in (1, 2, 3)``Notin`和`in`用法一样---</code></pre><ul><li><p><code>nested(Consumer&lt;Param&gt; consumer)</code></p><p> 表示正常嵌套，只加括号，不带and或or</p><p> 例如：<code>nested(i-&gt;i.eq(&quot;name&quot;, &#39;Jack&#39;).ne(&quot;status&quot;, 1))</code>—&gt;<code>(name = &#39;Jack&#39; and status = 1)</code></p></li></ul><pre><code class="hljs">`apply(String applySql, Object... params)`拼接sql注意：该方法可用于数据库函数动态入参的params对应前面的applySql内部的index部分，这样不会有sql注入风险，反之会有。例如：`apply(&quot;id = 1&quot;)`--&gt;`id = 1`​            `apply(&quot;date_format(dataColumn, &#39;%Y-%m-%d&#39;) = &#39;2008-08-08&#39;&quot;)`--&gt;`date_format(dataColumn, &#39;%Y-%m-%d&#39;) = &#39;2008-08-08&#39;`---</code></pre><ul><li><p><code>eq(R column, Object val)</code></p><p>  说明：等于=</p><p>  示例：</p><p>  <code>eq(&quot;name&quot;， &quot;赵四&quot;)</code>—&gt;<code>name = &#39;赵四&#39;</code></p></li></ul><p>与eq类似的还有：</p><ul><li>ne：not equal，不相等</li><li>gt：greater than，大于</li><li>ge：greater equal，大于等于</li><li>lt：less than，小于</li><li>le：小于等于</li></ul><p>还有一些简单的方法，看名字就知道作用和用法：</p><ul><li><code>orderByDesc</code></li><li><code>orderByAsc</code></li><li><code>groupBy</code></li><li><code>having</code></li><li><code>esists</code></li><li><code>notExists</code></li></ul><p>还有两个方法：</p><ul><li><code>or()</code></li><li><code>and()</code></li></ul><p>表示使用or或and拼接。</p><p>注意：主动调用<code>or</code>表示下一个方法使用or拼接。不调用则默认使用and。</p><p><code>or(Consumer&lt;Param&gt; consumer)</code></p><p>表示or嵌套。</p><p>例如：</p><p><code>or(i -&gt; i.eq(&quot;name&quot;, &#39;Jack&#39;).ne(&quot;status&quot;, 1))</code>—&gt;<code>or (name = &#39;Jack&#39; and status &lt;&gt; 1)</code></p><h3 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h3><p><code>select(String... sqlSelect)</code></p><p>用于设置查询字段。</p><p>例如：</p><p><code>select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;)</code></p><h3 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h3><p>有两个方法：</p><ul><li><p><code>set(String column, Object val)</code></p><p>  SQL的set字段</p><p>  例如<code>set(&quot;name&quot;, &quot;Jack&quot;)</code></p><p>  <code>set(&quot;name&quot;, &quot;&quot;)</code>—&gt;字段值变为空字符串</p><p>  <code>set(&quot;name&quot;, null)</code>—&gt;字段值变为null</p></li><li><p><code>setSql(String sql)</code></p><p>  直接设置set部分的sql语句</p><p>  如：<code>setSql(&quot;name=&#39;Jack&#39;&quot;)</code></p></li></ul><h2 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h2><p>使用代码生成器自动生成代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataAutoGenerator</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//创建自动生成器对象</span><br>        <span class="hljs-type">AutoGenerator</span> <span class="hljs-variable">ag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoGenerator</span>();<br>        <br>        <span class="hljs-comment">//创建全局配置对象</span><br>        <span class="hljs-type">GlobalConfig</span> <span class="hljs-variable">gc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalConfig</span>();<br>        <span class="hljs-comment">//获取项目绝对路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">projectPath</span> <span class="hljs-operator">=</span> System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);<br>        <span class="hljs-comment">//设置输出目录</span><br>        gc.setOutputDir(projectPath + <span class="hljs-string">&quot;/12-MyBatis_Plus/src/main/java&quot;</span>);<br>        <span class="hljs-comment">//设置作者</span><br>        gc.setAuthor(<span class="hljs-string">&quot;zhao-xin&quot;</span>);<br>        <span class="hljs-comment">//设置生成后不打开输出目录</span><br>        gc.setOpen(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">//设置Service类命名</span><br>        gc.setServiceName(<span class="hljs-string">&quot;%sService&quot;</span>);<br>        <span class="hljs-comment">//开启 swagger2 模式</span><br>        gc.setSwagger2(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//添加全局配置到自动生成器</span><br>        ag.setGlobalConfig(gc);<br><br>        <span class="hljs-comment">//创建数据源对象，并配置数据源。这部分比较熟悉，不细讲了。</span><br>        <span class="hljs-type">DataSourceConfig</span> <span class="hljs-variable">dsf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataSourceConfig</span>();<br>        dsf.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>);<br>        dsf.setDriverName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        dsf.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dsf.setPassword(<span class="hljs-string">&quot;bigbang2022&quot;</span>);<br>        dsf.setDbType(DbType.MYSQL);<br>        ag.setDataSource(dsf);<br><br>        <span class="hljs-comment">//配置包</span><br>        <span class="hljs-type">PackageConfig</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageConfig</span>();<br>        <span class="hljs-comment">//配置父包，entity等包生成在该包中</span><br>        pc.setParent(<span class="hljs-string">&quot;com.example&quot;</span>);<br>        <span class="hljs-comment">//设置实体类，数据访问层，服务层和控制层的名称</span><br>        pc.setEntity(<span class="hljs-string">&quot;entity&quot;</span>);<br>        pc.setMapper(<span class="hljs-string">&quot;mapper&quot;</span>);<br>        pc.setService(<span class="hljs-string">&quot;service&quot;</span>);<br>        pc.setController(<span class="hljs-string">&quot;controller&quot;</span>);<br>        <span class="hljs-comment">//添加到自动生成器中</span><br>        ag.setPackageInfo(pc);<br><br><br><br>        <span class="hljs-comment">// 策略配置</span><br>        <span class="hljs-type">StrategyConfig</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StrategyConfig</span>();<br>        <span class="hljs-comment">//设置命名策略为下划线转驼峰</span><br>        strategy.setNaming(NamingStrategy.underline_to_camel);<br>        <span class="hljs-comment">//设置列名命名策略也为下划线转驼峰</span><br>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<br>        <span class="hljs-comment">//是否开启实体类使用lombok</span><br>        strategy.setEntityLombokModel(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">//使用Rest风格</span><br>        strategy.setRestControllerStyle(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">//设置需要生成的表名</span><br>        strategy.setInclude(<span class="hljs-string">&quot;student&quot;</span>);<br>        <br>        strategy.setControllerMappingHyphenStyle(<span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-comment">//设置逻辑删除字段</span><br>        strategy.setLogicDeleteFieldName(<span class="hljs-string">&quot;deleted&quot;</span>);<br>        <span class="hljs-comment">//设置乐观锁字段</span><br>        strategy.setVersionFieldName(<span class="hljs-string">&quot;version&quot;</span>);<br><br>        <span class="hljs-comment">//设置自动填充字段</span><br>        List&lt;TableFill&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TableFill</span>(<span class="hljs-string">&quot;create_time&quot;</span>, FieldFill.INSERT));<br>        list.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TableFill</span>(<span class="hljs-string">&quot;update_time&quot;</span>, FieldFill.INSERT_UPDATE));<br>        strategy.setTableFillList(list);<br>        <span class="hljs-comment">//添加到自动生成器对象</span><br>        ag.setStrategy(strategy);<br><br>        <span class="hljs-comment">//设置模板引擎</span><br>        ag.setTemplateEngine(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VelocityTemplateEngine</span>());<br>        <br>        <span class="hljs-comment">//执行</span><br>        ag.execute();<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-MyBatis逆向工程</title>
    <link href="/2022/05/11/MyBatis/9-MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/2022/05/11/MyBatis/9-MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MyBatis逆向工程，简单说，就是通过数据库表来自动生成映射文件、DAO接口和实体类。而不需要手动去写。</p><p>使用方法：</p><ol><li>创建GeneratorConfig.xml配置文件</li><li>在pom文件中加入mybatis-generator-core依赖，和mybatis-generator的maven插件</li><li>编写配置文件</li><li>使用插件来生成实体类、mapper文件和Dao接口</li></ol><p>也可以创建MyBatis-Generator类来代替maven插件生成对应类，但比使用插件麻烦很多。</p><h2 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">generatorConfiguration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <br>    <br>    <br>    <span class="hljs-comment">&lt;!--指定连接数据库的JDBC 驱动包所在位置，指定到你本机的完整路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">classPathEntry</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;D:\software\Others\Maven\maven-repository\mysql\mysql-connector-java\8.0.22\mysql-connector-java-8.0.22.jar&quot;</span>/&gt;</span><br>    <br>    <br>    <br>    <br>    <span class="hljs-comment">&lt;!--配置table表信息内容体，targetRuntime 指定采用MyBatis3的版本--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;tables&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3&quot;</span>&gt;</span><br>        <br>        <br>        <br>        <br>        <br>        <span class="hljs-comment">&lt;!--抑制生成注释，由于生成的注释都是英文的，可以不让它生成,true为不生成注释--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <br>        <br>        <br>        <br>        <br>        <br>        <span class="hljs-comment">&lt;!--配置数据库连接信息--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test?useSSL=false<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8<span class="hljs-symbol">&amp;amp;</span>autoReconnect=true&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;数据库密码&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;nullCatalogMeansCurrent&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">jdbcConnection</span>&gt;</span><br>        <br><br>        <span class="hljs-comment">&lt;!--生成model 类，targetPackage 指定 model 类的包名，targetProject 指定</span><br><span class="hljs-comment">        生成的 model放在eclipse的哪个工程下面--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.model&quot;</span></span><br><span class="hljs-tag">                            <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trimStrings&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaModelGenerator</span>&gt;</span><br>        <br>        <br>        <br>        <br>             <br>        <span class="hljs-comment">&lt;!--生成 MyBatis的Mapper.xml文件，targetPackage 指定 mapper.xml文件的包名，targetProject 指定生成的 mapper.xml放在 eclipse的哪个工程下面</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.mapper&quot;</span></span><br><span class="hljs-tag">                         <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">sqlMapGenerator</span>&gt;</span><br>        <br>        <br>                <br>        <br>        <span class="hljs-comment">&lt;!--生成 MyBatis的 Mapper接口类文件,targetPackage 指定 Mapper 接口类的包名，targetProject 指定生成的 Mapper 接口放在eclipse 的哪个工程下面</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.example.demo.mapper&quot;</span></span><br><span class="hljs-tag">                             <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;enableSubPackages&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">javaClientGenerator</span>&gt;</span><br>        <br>        <br>        <br>        <span class="hljs-comment">&lt;!--数据库表名及对应的Java模型类名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Student&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">enableCountByExample</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">enableUpdateByExample</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">enableDeleteByExample</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">enableSelectByExample</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">selectByExampleQueryId</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>                       <br>        <br>        <br>        <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">                &lt;table tableName=&quot;user&quot; domainObjectName=&quot;User&quot;</span><br><span class="hljs-comment">                       enableCountByExample=&quot;false&quot;</span><br><span class="hljs-comment">                       enableUpdateByExample=&quot;false&quot;</span><br><span class="hljs-comment">                       enableDeleteByExample=&quot;false&quot;</span><br><span class="hljs-comment">                       enableSelectByExample=&quot;false&quot;</span><br><span class="hljs-comment">                       selectByExampleQueryId=&quot;false&quot; /&gt;--&gt;</span><br>                <br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后使用插件自动生成代码。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-PageHelper</title>
    <link href="/2022/05/11/MyBatis/8-PageHelper/"/>
    <url>/2022/05/11/MyBatis/8-PageHelper/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PageHelper插件是一个通用分页插件，它是用来给查询得到的数据分页的。</p><p>使用pagehelper的步骤：</p><h2 id="加入maven依赖"><a href="#加入maven依赖" class="headerlink" title="加入maven依赖"></a>加入maven依赖</h2><p>坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="加入plugin配置-配置拦截器"><a href="#加入plugin配置-配置拦截器" class="headerlink" title="加入plugin配置(配置拦截器)"></a>加入plugin配置(配置拦截器)</h2><p>在mybatis配置文件中</p><p>在<environments>标签之前加入  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="调用PageHelper静态方法"><a href="#调用PageHelper静态方法" class="headerlink" title="调用PageHelper静态方法"></a>调用PageHelper静态方法</h2><p>在需要进行分页的MyBatis查询方法之前调用<code>PageHelper.startPage()</code>静态方法即可，紧跟在这个方法后的第一个MyBatis查询方法会被分页。</p><p>startPage方法有几个重载形式：</p><ul><li><code>startPage(int pageNum, int pageSize)</code></li><li><code>startPage(int pageNum, int pageSize, boolean count)</code></li><li><code>startPage(int pageNum, int pageSize, String orderBy)</code></li><li><code>startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero)</code></li></ul><p>参数含义：</p><ul><li>pageNum：页码，就是要需要显示第几页</li><li>pageSize：每页显示数量</li><li>count：是否进行count查询</li><li>reasonable：分页合理化，null时使用默认配置</li><li>pageSizeZero：当为true且pageSize=0时返回全部结果；当为false时分页。null时使用默认配置</li></ul><p>例子：<br>要查询数据库中所有的数据</p><p>DAO接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudents&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span>&gt;</span><br>    select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudents</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    PageHelper.startPage(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    List&lt;Student&gt; list = dao.selectStudents();<br>    <span class="hljs-keyword">for</span>(Student stu:list) &#123;<br>        System.out.println(stu);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>数据表：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201204120512650.png" alt="image-20201204120512650" style="zoom:50%;" /></p><p>运行结果：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201204120544522.png" alt="image-20201204120544522" style="zoom:50%;" /></p><p><strong>可以看到，在执行查询前，加上了count操作，用来查询该表有多少行，在查询语句后加上了<code>Limit ?</code>。</strong></p><p>除此之外PageHelper还有其他几个方法</p><h3 id="offsetPage"><a href="#offsetPage" class="headerlink" title="offsetPage"></a>offsetPage</h3><p>有两种重载形式</p><ul><li><code>offsetPage(int offset, int limit)</code></li><li><code>offsetPage(int offset, int limit, boolean count)</code></li></ul><p>参数含义：</p><ul><li>offset：起始位置，也就是从哪行开始数。同时<strong>包括该行。注意：应该按第一行为0的数法。也就是说，如果从第一行开始显示，这个参数应该设为0</strong></li><li>limit：每页显示的数量</li><li>count：是否进行count查询</li></ul><p>例子：</p><p>接口方法和映射文件不变。</p><p>测试代码改为<code>PageHelper.offsetPage(0, 2)</code></p><p>运行结果：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201204120929472.png" alt="image-20201204120929472" style="zoom:50%;" /></p><h3 id="orderBy"><a href="#orderBy" class="headerlink" title="orderBy"></a>orderBy</h3><p>方法<code>orderBy(String orderBy)</code>，可以设置查询结果按什么排序，参数orderBy是列名</p><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>方法<code>long count(ISelect select)</code>，可以返回任意查询方法的行数。</p><p>ISelect是一个接口，只有一个方法<code>void doSelect()</code>，可以使用匿名内部类实现它，在该方法中调用自己的查询方法。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudents</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> PageHelper.count(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ISelect</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSelect</span><span class="hljs-params">()</span> &#123;<br>            dao.selectStudents();<br>        &#125;<br>    &#125;);<br>    System.out.println(count);<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-动态SQL</title>
    <link href="/2022/05/11/MyBatis/7-%E5%8A%A8%E6%80%81SQL/"/>
    <url>/2022/05/11/MyBatis/7-%E5%8A%A8%E6%80%81SQL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>动态SQL，是指sql的内容是变化的，可以根据不同的条件来获取不同sql语句，主要是where部分发生变化。</p><p>使用MyBatis提供的各种标签堆条件做出判断来实现动态拼接Sql语句。常见的动态SQL标签有<if>、<where>、<choose>、<foreach>等。</p><p>主要解决的是查询条件不确定的情况，在程序运行期间，根据用户提交的查询条件进行查询。提交的查询条件不同，那么执行的SQL语句也不同，如果将每种情况都列出，会产生大量SQL语句，因此，可使用动态SQL解决这样的问题。</p><h2 id="实体符号"><a href="#实体符号" class="headerlink" title="实体符号"></a>实体符号</h2><p>在映射文件中的动态SQL中若出现，大于号(&gt;)，小于号(&lt;)，大于等于号(&gt;=)，小于等于号(&lt;=)等符号，应该转换为实体符号，否则XML文件可能解析错误。尤其是小于号(&lt;)。</p><p>实体符号表</p><div class="table-container"><table><thead><tr><th>符号</th><th>含义</th><th>实体符号</th></tr></thead><tbody><tr><td><code>&lt;</code></td><td>小于</td><td><code>&amp;lt;</code>(less than)</td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>&amp;gt;</code>(greater than)</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>&amp;gt;=</code></td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>&amp;lt;=</code></td></tr></tbody></table></div><h2 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h2><p>if标签的语法格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;使用参数Java对象的属性值作为判断条件，语法：属性=xxx值&quot;</span>&gt;</span><br>sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当if标签中条件成立时，才会拼接if中的sql语句。</p><p>简单例子：<br>DAO接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; <span class="hljs-title function_">selectStudentIf</span><span class="hljs-params">(Student student)</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentIf&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select * from student<br>    where<br>    <span class="hljs-comment">&lt;!--只有当Java对象传来的参数name不为空，且不为空字符串时，才会加入该语句--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27; &quot;</span> &gt;</span><br>        name = #&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    &lt;！--当age大于零时，拼接下面的sql语句--&gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age &gt; 0&quot;</span> &gt;</span><br>        and age <span class="hljs-symbol">&amp;gt;</span> #&#123;age&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudentIf</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student.setName(<span class="hljs-string">&quot;赵四&quot;</span>);<br>    student.setAge(<span class="hljs-number">20</span>);<br>    List&lt;Student&gt; list = dao.selectStudentIf(student);<br>    <span class="hljs-keyword">for</span>(Student stu : list) &#123;<br>        System.out.println(stu);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>可以运行成功。</p><p>但是有一个问题，当name为空，而年龄不为空时，where语句变成 <code>where and age &gt; #&#123;age&#125;</code>，这个语句语法是错误的。会报错。</p><p>所以为了避免这种情况，需要在where语句中加入一个不影响查询结果和后面if语句的恒为真条件。例如<code>1 = 1</code></p><p>那么映射文件中select标签需要改写为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentIf&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select * from student<br>    where 1 = 1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null and name != &#x27;&#x27; &quot;</span> &gt;</span><br>        and name = #&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;age &gt; 0&quot;</span> &gt;</span><br>        and age <span class="hljs-symbol">&amp;gt;</span> #&#123;age&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样，无论在什么条件，sql语句都能够正常执行。<strong>并且注意，加上恒成立条件<code>1 = 1</code>后，第一个if标签中要加上and</strong></p><h2 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h2><p>if标签比较麻烦的地方就是需要在where后面手动加上<code>1= 1</code>的子句。</p><p>而where标签可以实现，在有查询条件时，自动加上where子句；没有查询条件时，不会添加where子句。</p><p>语法格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br>        and ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br>        and ...<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    ..<br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其实就是where标签中嵌套if标签。</p><p>需要注意的是：第一个if标签中，可以没有and，也可以写上and，系统会自动把多余and去掉。</p><h2 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h2><p><foreach>标签用于实现对数组和集合的遍历。常用在in语句中，in的语法格式为<code>where 列名 in (成员1，成员2，成员3,...)</code></p><p>语法格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br>    #&#123;item的值&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br></code></pre></td></tr></table></figure><p>foreach标签有五个属性：</p><ul><li>collection：表示要遍历的集合类型，如果是数组，值就是array；如果是List集合，值就是list</li><li>item：自定义的变量，代表要遍历的集合变量，相当于<code>for(Student stu:list)</code>中的stu</li><li>open：开始的字符，一般是<code>(</code></li><li>close：结束的字符，一般是<code>)</code></li><li>separator：集合成员之间的分隔符，一般是<code>,</code></li></ul><p>有两种常用方式，一种是遍历简单类型，一种是遍历引用类型。</p><p>区别就是占位符#{item的值}有所不同。<strong>简单类型<code>#&#123;&#125;</code>里面直接是item定义的值，而引用类型里需要再使用<code>.</code>符号使用引用类型的成员变量。如<code>#&#123;student.id&#125;。</code></strong></p><p>使用两种方式的例子：</p><h3 id="遍历简单类型"><a href="#遍历简单类型" class="headerlink" title="遍历简单类型"></a>遍历简单类型</h3><p>简单类型就是Java的基本数据类型加上String。</p><p>例子：<br>DAO接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; <span class="hljs-title function_">selectStudentsByIds</span><span class="hljs-params">(List&lt;Integer&gt; list)</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentsByIds&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span>&gt;</span><br>    select * from student where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> &gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudentsByIds</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    list.add(<span class="hljs-number">1001</span>);<br>    list.add(<span class="hljs-number">1002</span>);<br>    list.add(<span class="hljs-number">1003</span>);<br>    List&lt;Student&gt; students = dao.selectStudentsByIds(list);<br>    <span class="hljs-keyword">for</span>(Student stu:students) &#123;<br>        System.out.println(stu);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201204104546520.png" alt="image-20201204104546520" style="zoom:50%;" /></p><h3 id="遍历引用类型"><a href="#遍历引用类型" class="headerlink" title="遍历引用类型"></a>遍历引用类型</h3><p>DAO接口的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Student&gt; <span class="hljs-title function_">selectStudentsByIds</span><span class="hljs-params">(List&lt;Student&gt; list)</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentsByIds&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span>&gt;</span><br>    select * from student where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> &gt;</span><br>        #&#123;student.id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudentsByIds</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    List&lt;Student&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student1.setId(<span class="hljs-number">1001</span>);<br>    list.add(student1);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>    student2.setId(<span class="hljs-number">1002</span>);<br>    list.add(student2);<br>    List&lt;Student&gt; students = dao.selectStudentsByIds(list);<br>    <span class="hljs-keyword">for</span>(Student stu:students) &#123;<br>        System.out.println(stu);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201204104945216.png" alt="image-20201204104945216" style="zoom:50%;" /></p><h2 id="sql标签"><a href="#sql标签" class="headerlink" title="sql标签"></a>sql标签</h2><p><sql>标签用于定义SQL片段，让其他SQL标签复用。</p><p>语法格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br>sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br></code></pre></td></tr></table></figure><p>属性id用来标识该sql语句，是一个唯一值。</p><p>使用<include>标签来使用该语句。语法格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>属性refid就是需要使用的sql语句的id</p><p>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;select&quot;</span> &gt;</span><br>    select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentsByIds&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;select&quot;</span> /&gt;</span><br>    where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> &gt;</span><br>        #&#123;student.id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-别名</title>
    <link href="/2022/05/11/MyBatis/6-%E5%88%AB%E5%90%8D/"/>
    <url>/2022/05/11/MyBatis/6-%E5%88%AB%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="默认别名"><a href="#默认别名" class="headerlink" title="默认别名"></a>默认别名</h2><p>MyBatis给Java的常用类型提供了别名：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201203180719481.png" alt="image-20201203180719481" style="zoom:50%;" /></p><p>左边是别名，右边是Java数据类型。大部分都是变成小写即可。</p><h2 id="自定义别名"><a href="#自定义别名" class="headerlink" title="自定义别名"></a>自定义别名</h2><p>MyBatis同样支持自定义别名来进行开发，主要在resultType属性中使用。</p><p>需要在主配置文件中mybatis.xml文件中来定义。</p><p>单个类型定义别名的语法格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中type是类型的全限定名称，alias是自定义别名</p><p>批量定义别名的语法格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>扫描整个包下的类，别名是类名(首字母小写或大写都可以)，name是包名</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-输出结果</title>
    <link href="/2022/05/11/MyBatis/5-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/"/>
    <url>/2022/05/11/MyBatis/5-%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h2><p>该标签表示执行sql语句返回值的类型，使用java类型的全限定名称或者MyBatis定义的别名。但是推荐使用全限定名称。</p><p>注意：如果返回的是集合，那么应该设置为集合包含的元素，而不是集合本身。</p><p>resultType和resultMap不能同时使用。</p><p>MyBatis框架内部会调用对应类的构造方法来创建对象，使用setXXX方法给属性赋值。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map数据类型可以作为sql查询的返回值，推荐使用Map<Object, Object>。<strong>但是注意：Map如果作为接口返回值，sql语句的查询结果只能有一条记录，多于一条记录就会出现错误。</strong></p><p>其中，列名是Map的key，列值是Map的value。</p><p>例子：<br>DAO接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> HashMap&lt;Object, Object&gt; <span class="hljs-title function_">selectStudentById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;hashmap&quot;</span> &gt;</span><br>    select id, name, email, age from student where id = #&#123;studentId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudentById</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">studentDao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    HashMap&lt;Object, Object&gt; hashMap = studentDao.selectStudentById(<span class="hljs-number">1002</span>);<br>    System.out.println(hashMap);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201203182849126.png" alt="image-20201203182849126" style="zoom:50%;" /></p><p>但是如果查询结果超过一条，就会报错。</p><h2 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h2><p>resultMap可以自定义sql的查询结果对应列值和java对象属性的映射关系。更灵活的把列值赋给指定属性。经常用在列名和Java对象属性名不一样的情况。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol><li><p>首先定义resultMap，指定列名和属性的对应关系。</p><p> 语法格式为：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;&quot;</span> &gt;</span><br>    <span class="hljs-comment">&lt;!--主键字段使用id--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!--非主键使用result--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p> 其中resultMap的id属性是自定义的唯一值，在操作数据库标签的resultMap使用，，如<select resultMap="resultMap的id值"></p><p> type属性是期望转换成Java对象的全限定名称或别名。</p><p> 当列为主键使用id标签，非主键使用result字段，column是列名，property是属性名</p></li><li><p>在操作数据库如<select>等标签中，把resultType替换成resultMap</p></li></ol><p>例子：<br>DAO接口定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>映射文件内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;age&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudents&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;student&quot;</span> &gt;</span><br>    select id, name, email, age from student;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudent</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    List&lt;Student&gt; list = dao.selectStudents();<br>    <span class="hljs-keyword">for</span>(Student stu : list) &#123;<br>        System.out.println(stu);<br>    &#125;<br>    sqlSession.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201203184113423.png" alt="image-20201203184113423" style="zoom:50%;" /></p><h2 id="列名和属性名不相同的处理方法"><a href="#列名和属性名不相同的处理方法" class="headerlink" title="列名和属性名不相同的处理方法"></a>列名和属性名不相同的处理方法</h2><ol><li><p>第一种方法就是使用之前讲的resultMap标签来定义。</p></li><li><p>使用<code>select 列名 as 列别名</code>，将列别名设为和属性名一致。</p><p> 例如：</p><p> 定义Java代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Integer stuId;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> String email;<br><span class="hljs-keyword">private</span> Integer age;<br></code></pre></td></tr></table></figure><p> 映射文件中：</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudents&quot;</span>  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select id as StuId, name, email, age from student;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>如果要进行模糊查询，使用Like，有两种方式。跟MyBatis没有关系。就是sql语句，使用”%”进行查询。</p><p>一种是是在mapper文件中的sql语句中加入%，另一种就是调用方法传参数时加入”%”。</p><p>例子：<br>DAO接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudentsByName</span><span class="hljs-params">(String name)</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentsByName&quot;</span>  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select id as StuId, name, email, age from student where name like #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudentByName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">studentDao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    List&lt;Student&gt; list = studentDao.selectStudentsByName(<span class="hljs-string">&quot;%赵%&quot;</span>);<br>    <span class="hljs-keyword">for</span>(Student stu : list) &#123;<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201203192134193.png" alt="image-20201203192134193" style="zoom:50%;" /></p><p>另一种方式就是在测试代码中去掉%，在映射文件中加入%，并使用双引号或者单引号括起来，就是：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentsByName&quot;</span>  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select id as StuId, name, email, age from student where name like &quot;%&quot; #&#123;name&#125; &quot;%&quot;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-传参</title>
    <link href="/2022/05/11/MyBatis/4-%E4%BC%A0%E5%8F%82/"/>
    <url>/2022/05/11/MyBatis/4-%E4%BC%A0%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>从java代码中把数据传入mapper文件的sql语句，</strong>就是传入参数。</p><h2 id="parameterType"><a href="#parameterType" class="headerlink" title="parameterType"></a>parameterType</h2><p>parameterType是<select>、<insert>等标签的一个属性，用来表示DAO接口中对应方法参数的数据类型。</p><p>parameterType的值时java中数据类型的全限定类名或者是mybatis定义的别名。</p><p>例如：<code>parameterType = &quot;java.lang.Integer&quot;</code>、<code>parameterType = &quot;int&quot;</code></p><p>注意：parameterType不是必须的，mybatis能够通过反射机制发现接口参数的数据类型，所以可以没有。一般也不写。</p><h2 id="传入一个简单类型参数"><a href="#传入一个简单类型参数" class="headerlink" title="传入一个简单类型参数"></a>传入一个简单类型参数</h2><p>当DAO接口中的方法只有<strong>一个</strong>简单类型参数时(简单类型就是java的基本数据类型加上String)，那么占位符<code>#&#123;任意字符&#125;</code>获取参数值，括号中的名称和方法参数名无关。可以是任意字符。</p><p>例子：</p><p>DAO接口中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">selectStudentById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><p>映射文件的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select id, name, email, age from student where id = #&#123;studentId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到，接口中方法参数名是id，映射文件中是studentId，并不相同。</p><h2 id="多个参数-使用-Param-掌握"><a href="#多个参数-使用-Param-掌握" class="headerlink" title="多个参数-使用@Param(掌握)"></a>多个参数-使用@Param(掌握)</h2><p>当需要传入多个参数时，可以使用MyBatis提供的@Param注解。</p><p>使用方法：</p><ul><li>DAO接口定义的方法中，在形参定义之前加上@Param(“自定义形参数名”)</li><li>在映射文件中，占位符<code>#&#123;@Param定义的参数名&#125;</code>使用同样的名称来访问该参数</li></ul><p>非常简单。</p><p>例子：<br>在DAO接口中定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudentsByParams</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;studentName&quot;)</span> String name,</span><br><span class="hljs-params">                                            <span class="hljs-meta">@Param(&quot;studentId&quot;)</span> Integer id)</span>;<br></code></pre></td></tr></table></figure><p>在映射文件中编写具体sql语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentsByParams&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select id, name, email, age from student where name = #&#123;studentName&#125; or id = #&#123;studentId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看到占位符使用的名称和@Param定义的名称相同。</p><p>MyBatis推荐使用这种方法。</p><h2 id="多个参数-使用Java对象属性-掌握"><a href="#多个参数-使用Java对象属性-掌握" class="headerlink" title="多个参数-使用Java对象属性(掌握)"></a>多个参数-使用Java对象属性(掌握)</h2><p>传入多个参数另一种方法就是传入一个Java对象，该对象的多个属性是数据库实际参数。</p><p>使用对象语法：<code>#&#123;属性名，javaType=&quot;类型名称&quot;,jdbcType=&quot;数据类型&quot;&#125;</code></p><p>​        其中：</p><p>​                    属性名就是java对象中定义的变量名称；</p><p>​                    javaType是java中的属性数据类型；</p><p>​                    jdbcType是在数据库中的数据类型。</p><p>但是这样写，非常麻烦。</p><p>在实际开发中，一般采用简化模式：<code>#&#123;属性名&#125;</code>，javaType和jdbcType的值MyBatis可以通过反射获取。</p><p>这种方法在之前的例子中已经使用过了，在此不再提供例子。</p><h2 id="多个参数-使用位置-了解"><a href="#多个参数-使用位置-了解" class="headerlink" title="多个参数-使用位置(了解)"></a>多个参数-使用位置(了解)</h2><p>参数位置从0开始，引用参数的语法是：<code>#&#123;arg位置&#125;</code>，例如第一个参数是<code>#&#123;arg0&#125;</code>、第二个是<code>#&#123;arg1&#125;</code>，以此类推。</p><p>在MyBatis3.3之前版本使用<code>#&#123;0&#125;</code>、<code>#&#123;1&#125;</code>方式，从3.4使用<code>#&#123;arg0&#125;</code>方式。</p><p>例子：</p><p>接口方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudentsByParams</span><span class="hljs-params">(String name, Integer id)</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentsByParams&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select id, name, email, age from student where name = #&#123;arg0&#125; or id = #&#123;arg1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="多个参数-使用Map-了解"><a href="#多个参数-使用Map-了解" class="headerlink" title="多个参数-使用Map(了解)"></a>多个参数-使用Map(了解)</h2><p>Map集合可以存储多个值，使用Map向映射文件一次传入多个参数，Mao集合使用String类型的key，Object类型的值存储value。</p><p>mapper文件中使用<code>#&#123;key&#125;</code>来引用对应参数值。</p><p>例子：<br>DAO接口中方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudentsByParams</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudentsByParams&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select id, name, email, age from student where name = #&#123;StudentName&#125; or id = #&#123;StudentId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudentsByParams</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    <br>    Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;StudentName&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>    map.put(<span class="hljs-string">&quot;StudentId&quot;</span>, <span class="hljs-number">1004</span>);<br>    <br>    <br>    List&lt;Student&gt; list = dao.selectStudentsByParams(map);<br>    <span class="hljs-keyword">for</span>(Student stu : list) &#123;<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但这种方法不推荐使用，因为使用Map，不知道传入几个参数，也不知道每个参数的类型。</p><h2 id="和-两个占位符比较"><a href="#和-两个占位符比较" class="headerlink" title="#和$-两个占位符比较"></a>#和$-两个占位符比较</h2><h1 id="：占位符，是告诉MyBatis用实际参数值来代替。-代替sql语句中的”-”占位符，更安全，更迅速。"><a href="#：占位符，是告诉MyBatis用实际参数值来代替。-代替sql语句中的”-”占位符，更安全，更迅速。" class="headerlink" title="：占位符，是告诉MyBatis用实际参数值来代替。#{..}代替sql语句中的”?”占位符，更安全，更迅速。"></a>：占位符，是告诉MyBatis用实际参数值来代替。#{..}代替sql语句中的”?”占位符，更安全，更迅速。</h1><p>例如：<br>mapper文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span>&gt;</span><br>    select id, name, email, age from student where id=#&#123;studentId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在MyBatis内部执行其实使用的就是JDBC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select id, name, email age from student where id = ?&quot;</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> conn.preparedStatement(sql);<br>ps.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">1001</span>);<br></code></pre></td></tr></table></figure><p>所以where id = ? 就是 where id= #{studentId}</p><p>ps.setInt(1, 1001)，1001会替换#{studentId}</p><p>$：这个使用的是字符串拼接的原理。</p><p>注意:$是字符串拼接，所以在传入参数时，要使用单引号括起来，例如：</p><p><code>List&lt;Student&gt; list = dao.selectStudentsByParams(&quot;&#39;李四&#39;&quot;, 1004);</code></p><p>$是字符串拼接，内部使用Statement来执行sql语句。可能会发生SQL注入，是有风险的。</p><p>所以通常，$不用来替换参数值，而是用来替换表名、列名、不同列排序等操作。</p><p>例子：使用不同列来进行查询</p><p>DAO接口定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Student <span class="hljs-title function_">findByDiffField</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;col&quot;)</span> String colName, <span class="hljs-meta">@Param(&quot;value&quot;)</span> Object value)</span>;<br></code></pre></td></tr></table></figure><p>映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;findByDiffField&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select * from student where $&#123;col&#125; = #&#123;value&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFindByDiffField</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> dao.findByDiffField(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>    System.out.println(student);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用任何一列来进行查询。</p><h3 id="比较两种不同方法"><a href="#比较两种不同方法" class="headerlink" title="比较两种不同方法"></a>比较两种不同方法</h3><p>$它可以替换#。但是原理是完全不同的，#是占位符。在内部使用PreparedStatement来执行sql语句；</p><p>使用#的控制台日志：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201202124300046.png" alt="image-20201202124300046"></p><p>使用$的控制台日志：</p><p>​    <img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201202124240371.png" alt="image-20201202124240371"></p><p>可以看出区别，一个是?，一个直接把参数写入到了sql语句。</p><p>所以一个是占位符，一个是字符串拼接。</p><p>总上，#和$的区别：</p><ul><li><h1 id="使用-？能够在sql语句做占位符，使用PreparedStatement执行sql，效率高"><a href="#使用-？能够在sql语句做占位符，使用PreparedStatement执行sql，效率高" class="headerlink" title="使用 ？能够在sql语句做占位符，使用PreparedStatement执行sql，效率高"></a>使用 ？能够在sql语句做占位符，使用PreparedStatement执行sql，效率高</h1></li><li><h1 id="能够避免sql注入，更安全"><a href="#能够避免sql注入，更安全" class="headerlink" title="能够避免sql注入，更安全"></a>能够避免sql注入，更安全</h1></li><li>$不使用占位符，是字符串连接方法，使用Statement对象执行sql，效率低</li><li>$有sql注入的风险，缺乏安全性</li><li>$可以替换表名和列名</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-传统DAO和动态代理</title>
    <link href="/2022/05/11/MyBatis/3-%E4%BC%A0%E7%BB%9FDAO%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2022/05/11/MyBatis/3-%E4%BC%A0%E7%BB%9FDAO%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在之前使用MyBatis的时候，我们首先创建了实体类，接口，映射文件和主配置文件，然后在测试代码中加载主配置文件，然后调用SqlSession的方法来操作数据库，参数是sqlId，<strong>但是，我们可以发现，接口在整个过程中并没有发挥作用，我们只是将mapper的namespace设为接口的全限定名称，id是接口内的方法名，但这两个其实是自定义的，它并不和接口挂钩。</strong></p><p>那么为什么还要创建接口呢？</p><p>首先回顾一下传统DAO应该如何使用。</p><h2 id="传统DAO"><a href="#传统DAO" class="headerlink" title="传统DAO"></a>传统DAO</h2><p>这部分比较简单，不做例子分析。</p><p>在传统DAO中，首先创建出接口，映射文件和主配置文件，然后创建接口的实现类，实现接口的方法，其实就相当于把测试方法中的代码挪到实现类中的方法。然后创建实现类对象，调用方法来访问数据库。</p><p>也就是我们实际上是需要手动创建出接口的实现类的。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在映射文件中，规定了mapper的namespace必须是接口的全限定类名，id必须是接口的方法名。这么做是必要的。因为dao对象，类型是DAO接口，全限定类名和namespace一致，实现类的方法名称也和id值一致。</p><p>同时，dao中方法的返回值也可以确定SqlSession要调用的方法。</p><p>如果返回值是List，那么就调用selectList方法；如果是int，那么看mapper文件中insert、update标签，就会调用对应方法。</p><p>那么就可以使用MyBatis的动态代理，来让MyBatis框架创建出接口的实现类，而不需要手动创建，底层原理实际就是使用的反射。</p><p>MyBatis的动态代理：</p><p>mybatis根据dao的方法调用，获取执行sql语句的信息，mybatis根据dao接口，创建出一个dao接口的实现类，并创建这个类的对象，完成sqlSession调用方法，访问数据库。</p><p><strong>我们使用SqlSession的getMapper(Class)方法来获取接口的实现类对象，参数是class。</strong></p><p>例子：</p><p>改写之前的查询操作</p><p>映射文件和接口不需要修改，只需要在使用时，获取SqlSession对象后，调用它的getMapper方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudent</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> MyBatisUtils.getSqlSession();<br>    <span class="hljs-type">StudentDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> sqlSession.getMapper(StudentDao.class);<br>    List&lt;Student&gt; list = dao.selectStudents();<br>    <span class="hljs-keyword">for</span>(Student stu : list) &#123;<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从代码中可以看出，getMapper返回接口实现类，然后用该实现类去调用对应方法，那么MyBatis就会根据该类的全限定类名和调用的方法名去映射文件中找到对应sql语句，并执行它，返回结果。</p><p>实际开发中，这种用法是很常见的。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-MyBatis中常用的类</title>
    <link href="/2022/05/11/MyBatis/2-MyBatis%E4%B8%AD%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB/"/>
    <url>/2022/05/11/MyBatis/2-MyBatis%E4%B8%AD%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Resources"><a href="#Resources" class="headerlink" title="Resources"></a>Resources</h2><p>负责读取主配置文件的，<code>InputStream in = Resources.getResourceAsStram(&quot;mybatis.xml&quot;);</code></p><p>没有其他作用</p><h2 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h2><p>负责创建SqlSessionFactory对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br><span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> builder.build(in);<br></code></pre></td></tr></table></figure><h2 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h2><p>它是一个接口，用来获取SqlSession对象。是比较重量级的对象，程序创建该对象耗时较长，使用的资源多，在整个项目中，有一个就够用了。</p><p>使用该接口的openSession()方法来获取SqlSession对象，该方法有几种重载形式，常见有</p><ul><li>openSession()：获取一个非自动提交事务的SqlSession对象</li><li>openSession(boolean autoCommit)：参数是boolean，值为true，表示获取自动提交事务的SqlSession；false，表示非自动提交事务的SqlSession对象。</li></ul><h2 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h2><p>是一个接口，定义了操作数据的方法，常见有查询，插入，更新，删除操作。</p><p>但注意：SqlSession对象不是线程安全的，需要在方法内部使用，在执行sql语句之前，使用openSession()方法获取SqlSession对象，执行完sql语句后，执行SqlSession.close()关闭它。</p><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><p>可以把加载主配置文件，创建SqlSessionFactory等操作封装起来，创建一个工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisUtils</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">sqlSessionFactory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis.xml&quot;</span>;<br>            <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(config);<br>            sqlSessionFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>().build(in);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title function_">getSqlSession</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">SqlSession</span> <span class="hljs-variable">sqlSession</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span>(sqlSessionFactory != <span class="hljs-literal">null</span>) &#123;<br>            sqlSession = sqlSessionFactory.openSession();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> sqlSession;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-MyBatis基础</title>
    <link href="/2022/05/11/MyBatis/1-MyBatis%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/05/11/MyBatis/1-MyBatis%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>MyBatis框架是一个基于Java的持久层(数据访问层)框架，内部封装了JDBC,开发者只需要关注SQL语句本身，将处理加载驱动、创建连接、创建statement、关闭连接、资源等繁琐的过程全都交给MyBatis来处理。</p><p>MyBatis通过XML或注解两种方式将要执行的各种sql语句配置起来，并通过Java对象和sql的动态参数进行映射生成最终的sql语句，最后由MyBatis框架执行sql并将结果映射为java对象返回。</p><p>很重要的一个概念是映射，它的意思是数据库中每一行的数据都可以映射为一个Java对象，我们会创建对应的实体类，保持成员变量和表中属性一致。</p><p>创建数据库表<code>Student(id int, name varchar(255), email varchar(255), age int)</code></p><p>其中主键是id。</p><p>创建实体类Student，放在包org.example.domain中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <br>    <span class="hljs-comment">//set和get方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建StudentDao接口，放在包org.example.dao中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentDao</span> &#123;<br><br>    <span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在之后，都是以这个作为例子。</p><h2 id="使用MyBatis步骤"><a href="#使用MyBatis步骤" class="headerlink" title="使用MyBatis步骤"></a>使用MyBatis步骤</h2><h3 id="创建Mysql表"><a href="#创建Mysql表" class="headerlink" title="创建Mysql表"></a>创建Mysql表</h3><p>首先要在Mysql中创建相应表。</p><h3 id="创建对应实体类"><a href="#创建对应实体类" class="headerlink" title="创建对应实体类"></a>创建对应实体类</h3><p>在Java中创建实体类，使成员变量和表中属性一致</p><h3 id="创建持久层的DAO接口"><a href="#创建持久层的DAO接口" class="headerlink" title="创建持久层的DAO接口"></a>创建持久层的DAO接口</h3><p>在持久层创建该表的DAO接口，定义操作该表的方法</p><h3 id="创建sql映射文件"><a href="#创建sql映射文件" class="headerlink" title="创建sql映射文件"></a>创建sql映射文件</h3><p>这个是MyBatis使用的配置文件，是用来写sql语句的。一般，一个表一个sql映射文件。</p><p>该文件应和DAO接口放在同一文件中，文件名也和接口保持一致。</p><h3 id="创建主配置文件"><a href="#创建主配置文件" class="headerlink" title="创建主配置文件"></a>创建主配置文件</h3><p>这个配置文件是MyBatis的主配置文件，一个项目中只有一个主配置文件，它提供了数据库的连接信息和sql映射文件的位置信息。</p><h3 id="使用mybatis访问数据库-使用SqlSession，最简单的一种情况"><a href="#使用mybatis访问数据库-使用SqlSession，最简单的一种情况" class="headerlink" title="使用mybatis访问数据库(使用SqlSession，最简单的一种情况)"></a>使用mybatis访问数据库(使用SqlSession，最简单的一种情况)</h3><h4 id="设置主配置文件路径"><a href="#设置主配置文件路径" class="headerlink" title="设置主配置文件路径"></a>设置主配置文件路径</h4><p>使用一个字符串变量表示主配置文件路径</p><h4 id="获得主配置文件的输入流"><a href="#获得主配置文件的输入流" class="headerlink" title="获得主配置文件的输入流"></a>获得主配置文件的输入流</h4><p>使用MyBAtis框架中的<code>Resources.getResourceAsStream(config)</code>来获取配置文件输入流，定义InputStream变量来获得返回值。</p><h4 id="创建SqlSessionFactoryBuilder对象和SqlSessionFactory对象"><a href="#创建SqlSessionFactoryBuilder对象和SqlSessionFactory对象" class="headerlink" title="创建SqlSessionFactoryBuilder对象和SqlSessionFactory对象"></a>创建SqlSessionFactoryBuilder对象和SqlSessionFactory对象</h4><p>创建一个SqlSessionFactoryBuilder对象，它有一个build方法，将上述的输入流参数传入该方法，得到SqlSessionFactory对象，这个对象是用来生成数据库访问会话的。</p><h4 id="设置sql语句的id"><a href="#设置sql语句的id" class="headerlink" title="设置sql语句的id"></a>设置sql语句的id</h4><p>在sql映射文件中，有sql语句id，将namespace和id拼接形成的字符串作为sql语句的id</p><h4 id="使用session，会话执行SQL语句，返回结果"><a href="#使用session，会话执行SQL语句，返回结果" class="headerlink" title="使用session，会话执行SQL语句，返回结果"></a>使用session，会话执行SQL语句，返回结果</h4><p>调用factory的openSession()方法，打开一个会话session，调用会话的selectList方法，将上面的id传入该方法，作为参数。该方法执行查询并返回一个List集合，集合里元素类型就是sql映射文件中resultType类型。</p><p><strong>注意：上述的访问数据库的方法，只是其中一种，还有很多其他的重载方法可用。</strong></p><h2 id="SQL映射文件"><a href="#SQL映射文件" class="headerlink" title="SQL映射文件"></a>SQL映射文件</h2><p>该文件是用来写sql语句的，MyBatis框架会执行这些sql</p><p>​    </p><p>基本文件格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.example.dao.StudentDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    select * from Blog where id = #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中</p><ol><li><p>第一行是用来规定xml的版本和字符集。</p></li><li><p>mybatis-3-mapper.dtd是约束文件名称，拓展名为dtd。</p><p> 约束文件的作用：</p><p> ​        是用来限制、检查当前文件中出现的标签、属性是否符合MyBatis的要求。</p><p> 很多框架的配置文件中都会用到约束文件。</p></li><li><p>mapper</p><p> 是当前文件的根标签，是必须有的。</p><p> namespace：叫做命名空间，唯一值，可以是自定义的字符串，但是应该使用dao接口的全限定名称，例如StudentDao接口，那么namespace就应该等于”org.example.dao.StudentDao”</p></li></ol><p>在当前文件中，可以使用特定的标签来表示数据库的特定操作。</p><ul><li><code>&lt;select&gt;</code>：查询操作</li><li><code>&lt;update&gt;</code>：更新操作</li><li><code>&lt;insert&gt;</code>：插入操作</li><li><code>&lt;delete&gt;</code>：删除操作</li></ul><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><code>&lt;select&gt;</code>表示查询操作。</p><p>属性：</p><ul><li><p>id：要执行的sql语句的唯一标识，MyBatis会使用这个id的值来找到要执行的sql语句。相等于给这个操作语句起了个名。</p><p>  ​        可以自定义，但是要求使用接口中的方法名称。</p></li><li><p>resultType：表示结果类型，即数据库的每一行应该映射为什么Java类型。</p><p>  ​                        值是该类型的全限定名称。</p></li></ul><p>例子：</p><p>在DAO接口中定义查询方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>在映射文件中编写具体查询的sql语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudents&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>    select id, name, email, age from student;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用SqlSession的<code>selectList(String statement)</code>方法来进行查询，返回值是List集合。selectList有多种重载方法。</p><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>插入操作</p><p>语法格式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    insert into tablename values(#&#123;&#125;, #&#123;&#125;, #&#123;&#125;...)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span>    <br></code></pre></td></tr></table></figure><p>其中属性id是这个插入操作的唯一标识，应使用DAO接口的对应方法名。</p><p>语法格式：<code>#&#123;&#125;</code>代表访问传来的参数对象中的成员变量。</p><p>例如：</p><p>在DAO接口中定义插入数据方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">insertStudent</span><span class="hljs-params">(Student student)</span>;<br></code></pre></td></tr></table></figure><p>参数是Student对象，在映射文件中使用#{}来访问该对象中的成员变量作为实际插入的数据：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertStudent&quot;</span> &gt;</span><br>    insert into student values (#&#123;id&#125;, #&#123;name&#125;, #&#123;email&#125;, #&#123;age&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用SqlSession的<code>insert(String Statement, Object parameter)</code>来执行插入语句，第一个参数表示sqlId，第二个表示要传入的参数。insert有两种重载方法。另一种是<code>insert(String statement)</code>。</p><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><p>更新操作。</p><p>属性id 和上述一样。</p><p>其中同样使用<code>#&#123;&#125;</code>来访问参数对象的成员变量。</p><p>例子：</p><p>在DAO接口定义更新对象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateStudent</span><span class="hljs-params">(Student student)</span>;<br></code></pre></td></tr></table></figure><p>参数Student对象，在映射文件中定义具体sql语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateStudent&quot;</span> &gt;</span><br>    update student set age = #&#123;age&#125; where name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用SqlSession的<code>update(String statement, Object parameter)</code>对象执行更新操作。该方法有两种重载形式。另一种是<code>update(String statement)</code>。</p><p>执行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201202101656428.png" alt="image-20201202101656428" style="zoom:40%;" /></p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>删除操作</p><p>属性id 和上面一样。</p><p>同样使用<code>#&#123;&#125;</code>访问参数对象成员变量。</p><p>例子：<br>DAO接口增加删除方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteStudent</span><span class="hljs-params">(Student student)</span>;<br></code></pre></td></tr></table></figure><p>映射文件中编写具体删除的sql语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteStudent&quot;</span> &gt;</span><br>    delete from student where name = #&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用SqlSession的delete方法来执行删除操作。同样有两种重载类型：<code>delete(String statement, Object parameter)</code>和<code>delete(String statement)</code>。</p><p>执行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201202102209579.png" alt="image-20201202102209579" style="zoom:43%;" /></p><h2 id="主配置文件"><a href="#主配置文件" class="headerlink" title="主配置文件"></a>主配置文件</h2><p>基本格式为</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">  <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">  <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>主配置文件放在resources目录中，是xml文件，在头部使用约束文件。它的根元素是<configuration>,主要包含定义别名、配置数据源、mapper文件三个内容。</p><p>其中：</p><ul><li><p><code>&lt;environments&gt;</code>：表示环境配置，即数据库的连接信息。</p><p>  default属性的值必须和某个environment的id值一样，这个属性值告诉mybatis使用哪个数据库的连接信息</p></li><li><p><code>&lt;environment&gt;</code>：表示一个数据库的配置环境。属性id表示该数据库配置的名称，自定义，是一个唯一值</p></li><li><p><code>&lt;transactionManager&gt;</code>：表示mybatis使用的事务管理器</p><p>  type代表类型，有两个可取值:</p><ol><li>JDBC(表示使用JDBC中的Connection对象的commit、rollback)。默认情况下，MyBatis使用手动提交，即需要在程序中显式的对事务进行提交或回滚。</li><li>MANAGED：表示由容器来管理事务的整个生命周期(如Spring容器)。</li></ol></li><li><p><code>&lt;dataSource&gt;</code>：表示数据源，type代表数据源类型，有三种取值</p><ol><li>POOLED：使用连接池，MyBatis会创建PooledDataSource实例</li><li>UNPOOLED：MyBatis会创建UnPooledDataSource实例</li><li>JNDI：PooledDataSource会从JNDI服务上查找DataSource实例，然后返回使用。</li></ol></li><li><p><code>&lt;property&gt;</code>：表示连接的属性配置，有驱动，url，用户名，密码四个要素。</p><p>  属性name有driver、url、username、password取值，属性value表示实际的值</p></li></ul><p>此外，为了方便对数据库连接的管理，数据库连接的四要素一般放在专门的属性文件中，拓展名为properties。MyBatis需要从属性文件中读取这些数据。</p><p>同样把属性文件放在resources目录中，名称自定义。</p><p>例如: jdbc.properties，文件基本格式为</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">jdbc.driver<span class="hljs-operator">=</span><br>jdbc.url<span class="hljs-operator">=</span><br>jdbc.username<span class="hljs-operator">=</span><br>jdbc.password<span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><p>然后在主配置文件<configuration>标签下，加入<properties resource = "文件路径" />标签，加载该属性文件。</p><p><strong>然后在 <property>标签中的value属性，使用${key}语法格式来获得属性文件中的对应值。</strong></p><p>例如:$(jdbc.driver)即可获取驱动。</p><p><mappers>标签指定sql应设问句的位置，其中一个<mapper>标签指定一个文件的位置，属性resource就用来指定文件路径。</p><p>类路径，即编译后的target/classes目录下开始的路径。</p><p>也可以使用<package name="">用来指定包下的所有DAO接口</p><p>使<strong>用package的要求：</strong></p><ul><li><strong>mapper文件和dao接口文件名必须完全一样，包括大小写</strong></li><li><strong>mapper文件和dao接口必须在同一目录</strong></li></ul><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>根据之前创建的student表和Student实体类，来使用MyBatis框架访问数据库。</p><p>首先创建sql映射文件StudentDao.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.example.dao.StudentDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudents&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span> &gt;</span><br>        select id, name, email, age from student;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在resources目录中创建jdbc.properties属性文件和mybatis.xml主配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">driver=com.mysql.cj.jdbc.Driver<br>url=jdbc:mysql://localhost:3306/test?usrSSL=false&amp;serverTimezone=UTC<br>username=root<br>password=*******<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;jdbc.properties&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/example/dao/StudentDao.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在测试类中编写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-comment">//设置主配置文件路径</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mybatis.xml&quot;</span>;<br>      <span class="hljs-comment">//获取输入流</span><br>      <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> Resources.getResourceAsStream(config);<br>      <span class="hljs-comment">//创建sqlSessionFactoryBuilder对象，用该对象构建SqlSessionFactoryBuilder对象</span><br>      <span class="hljs-type">SqlSessionFactoryBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlSessionFactoryBuilder</span>();<br>      <span class="hljs-comment">//将输入流变量in传入，构建SqlSessionFactory</span><br>      <span class="hljs-type">SqlSessionFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> builder.build(in);<br>      <span class="hljs-comment">//调用factory方法打开一个会话</span><br>      <span class="hljs-type">SqlSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> factory.openSession();<br>      <span class="hljs-comment">//拼接namespace和id作为sql语句的id</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">sqlId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;org.example.dao.StudentDao&quot;</span> + <span class="hljs-string">&quot;.&quot;</span> + <span class="hljs-string">&quot;selectStudents&quot;</span>;<br><span class="hljs-comment">//将id传入执行方法获得结果List集合</span><br>      List&lt;Student&gt; list = session.selectList(sqlId);<br>      list.forEach(sql-&gt; System.out.println(sql));<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201201141739513.png" alt="image-20201201141739513" style="zoom:43%;" /></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p>默认情况下，Maven编译是不会加上xml、properties等文件的，如果要让Maven加上这些文件，要在pom.xml中的build标签中，加入一个插件：</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>          <span class="hljs-comment">&lt;!--扫描的目录--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><p>在mybatis.xml文件中加入如下代码，可以将数据库操作日志输出到控制台，方便来查看具体信息。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>MyBatis</tag>
      
      <tag>后端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-Spring常用注解</title>
    <link href="/2022/05/11/Spring/10-Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/"/>
    <url>/2022/05/11/Spring/10-Spring%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="10-Spring常用注解"><a href="#10-Spring常用注解" class="headerlink" title="10-Spring常用注解"></a>10-Spring常用注解</h1><h2 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h2><p>位置：一般用在类上</p><p>作用：表示该类作为一个配置类，配置一些内容</p><h2 id="Bean"><a href="#Bean" class="headerlink" title="@Bean"></a>@Bean</h2><p>位置：一般用在方法上，<strong>并且该方法所在类是配置类，即被@Configuration注解的类</strong></p><p>作用：表示把该方法返回的对象交给Spring容器管理</p><h2 id="Service"><a href="#Service" class="headerlink" title="@Service"></a>@Service</h2><p>位置：用在类上</p><p>作用：标注业务层组件</p><h2 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h2><p>位置：用在类上</p><p>作用：标注控制层组件</p><h2 id="Repository"><a href="#Repository" class="headerlink" title="@Repository"></a>@Repository</h2><p>位置：用在类上</p><p>作用：标注数据访问层组件，即DAO组件</p><h2 id="Compinent"><a href="#Compinent" class="headerlink" title="@Compinent"></a>@Compinent</h2><p>位置：用在类上</p><p>作用：泛指组件，当组件不好归类，就用该注解进行标注</p><h2 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h2><p>位置：用在类上</p><p>作用：当自动装配出现多个Bean候选者时，被注解@Primary的Bean将作为首选项。</p><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h2><p>位置：用在变量上</p><p>作用：默认按类型装配，当出现多个Bean，则再按名称，如还是有多个Bean，并且没有@Primary，那么就会出现错误</p><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h2><p>位置：用在变量上</p><p>作用：默认按名称装配</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-Spring和Web</title>
    <link href="/2022/05/11/Spring/9-Spring%E5%92%8CWeb/"/>
    <url>/2022/05/11/Spring/9-Spring%E5%92%8CWeb/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="9-Spring和Web"><a href="#9-Spring和Web" class="headerlink" title="9-Spring和Web"></a>9-Spring和Web</h1><p>在Web项目中使用Spring框架，首先要在web层(这里指Servlet)获取到Spring容器对象。只要获取到了Spring容器，就可以从该容器中获取到Service对象。</p><p>那么接下来就要思考在哪里创建Spring容器。</p><p>对于一个web应用来说，Spring容器对象只需要一个就可以了。所以很显然不能直接在Servlet中创建Spring容器，因为虽然Servlet是单例多线程，但多个Servlet都需要用到Spring容器，就会创建多个Spring容器。</p><p>我们想到，对于一个web应用，全局作用域对象ServletContext也只有一个，所以可以在创建全局作用域对象的时候创建Spring容器，并把Spring容器对象存入ServletContext中。</p><p>之前学到了全局作用域的监听器接口ServletContextListener，我们可以使用监听器监听全局作用域，当全局作用域创建的时候同时创建Spring容器，并放入全局作用域对象中。</p><p>可以自定义全局作用域监听器接口实现类，也可以使用spring的一个模块spring-web提供的实现类ContextLoaderListener。</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="加入依赖"><a href="#加入依赖" class="headerlink" title="加入依赖"></a>加入依赖</h3><p>首先加入spring-web依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="在web配置文件web-xml中注册监听器"><a href="#在web配置文件web-xml中注册监听器" class="headerlink" title="在web配置文件web.xml中注册监听器"></a>在web配置文件web.xml中注册监听器</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">  <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span><br>    org.springframework.web.context.ContextLoader<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="在web配置文件web-xml文件中指定spring配置文件路径"><a href="#在web配置文件web-xml文件中指定spring配置文件路径" class="headerlink" title="在web配置文件web.xml文件中指定spring配置文件路径"></a>在web配置文件web.xml文件中指定spring配置文件路径</h3><p>使用<context-param>标签来配置，语法格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring配置文件路径<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子标签<param-name>的值就是contextConfigLocation，固定不变。<param-value>就是spring配置文件的路径。</p><p>ContextLoaderListener会从ServletContext中获取该参数，然后创建spring容器。</p><p>注意，如果从ServletContext中获取web.xml初始参数，需要使用的方法是<code>getInitParameter(String name)</code>，而不是<code>getAttribute(String name)</code>。</p><p>如果没有使用<context-param>标签指定spring配置文件路径，那么会默认使用WEB-INF/applicationContext.xml这个路径。</p><h4 id="获取Spring容器对象"><a href="#获取Spring容器对象" class="headerlink" title="获取Spring容器对象"></a>获取Spring容器对象</h4><p>获取Spring容器对象有两种方法。</p><p>在之前的例子中，Spring容器对应类时ApplicationContext，在web应用中容器对应类时WebApplicationContext，它是ApplicationContext的子类。</p><h4 id="从ServletContext中获取"><a href="#从ServletContext中获取" class="headerlink" title="从ServletContext中获取"></a>从ServletContext中获取</h4><p>Spring容器对象在ServletContext中存放的key为<code>WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE。</code></p><p>可以通过这个key，调用ServletContext的<code>getAttribute(String name)</code>方法获取WebApplicationContext。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE&quot;</span>;<br><span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> (WebApplicationContext) <span class="hljs-built_in">this</span>.getServletContext().getAttribute(attr);<br></code></pre></td></tr></table></figure><h4 id="通过WebApplicationContextUtils获取"><a href="#通过WebApplicationContextUtils获取" class="headerlink" title="通过WebApplicationContextUtils获取"></a>通过WebApplicationContextUtils获取</h4><p>WebApplicationContextUtils是一个工具类，它有一个<code>getRequiredWebApplicationContext(ServletContext sc)</code>方法，传入ServletContext参数，返回值就是Spring容器对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> WebApplicationContextUtils.getRequiredWebApplicationContext(sc);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-Spring事务</title>
    <link href="/2022/05/11/Spring/8-Spring%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/05/11/Spring/8-Spring%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="8-Spring事务"><a href="#8-Spring事务" class="headerlink" title="8-Spring事务"></a>8-Spring事务</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>事务最开始是数据库中的概念，在DAO层。数据库中的事务指一组sql语句的集合，我们希望这些语句都成功或者都失败。</p><p>即执行是一致的。当涉及多个表或者多个sql语句的insert，update等，需要保证这些语句都成功，可以使用事务。</p><p>事务有四个特性：</p><ul><li><p>原子性：指事务不可分割，是一个整体</p></li><li><p>一致性：事务中的语句要么都执行，要么都不执行。保持一致</p></li><li><p>隔离性：该事务的执行不影响其他事务的执行</p></li><li><p>持久性：事务执行完以后，永久有效。</p></li></ul><p>但一般情况，需要将事务提升到业务层，即Service层。这样做是为了能够使用事务的特性来管理具体的业务。</p><p>Spring中，通常使用两种方式实现对事务的管理：</p><ul><li>使用Spring的事务注解管理事务</li><li>使用AspectJ的AOP配置管理事务</li></ul><p>事务处理应放在Service的业务方法上，因为业务方法要运行多个sql语句。</p><h2 id="之前数据库事务处理方式的不足"><a href="#之前数据库事务处理方式的不足" class="headerlink" title="之前数据库事务处理方式的不足"></a>之前数据库事务处理方式的不足</h2><ul><li>不同数据库访问技术，处理事务的对象、方法不同，JDBC和MyBatis、Hibernate的事务处理各不相同。</li><li>需要了解不同数据库访问技术使用事务的原理</li><li>掌握多种数据库事务的处理逻辑，什么时候提交事务，什么时候回滚事务</li><li>处理事务的多种方法</li></ul><p>大致总结就是：多种数据库的访问技术，有不同的事务处理的机制、对象和方法。</p><p>那么解决不足的方法就是：使用Spring提供的一种处理事务的统一模型，使用统一步骤、方法完成对不同数据库访问技术的事务处理。</p><h2 id="Spring事务管理"><a href="#Spring事务管理" class="headerlink" title="Spring事务管理"></a>Spring事务管理</h2><p>Spring使用事务管理器来管理事务。事务管理器是一个接口，它有众多的实现类。</p><p>接口：PlatformTransactionManager,定义了事务方法commit、rollback</p><p>实现类：spring把每一种数据库访问技术对应的事务处理类都创建好了。</p><p>DateSourceTransactionManager类：使用JDBC或MyBatis进行数据库操作</p><p>HibernateTransactionManager类：使用Hibernate进行持久化数据时使用</p><p>使用：我们需要告诉spring使用的是哪种数据库访问技术，就是在配置文件中使用<bean>标签声明，创建数据库访问技术对应的类。</p><h3 id="Spring回滚方式"><a href="#Spring回滚方式" class="headerlink" title="Spring回滚方式"></a>Spring回滚方式</h3><p>Spring事务的默认的回滚方式是：发生运行时异常和error时回滚，发生编译异常时提交。但是，对于编译异常，我们可以手动设置回滚方式。</p><p>复习一下错误和异常：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201206131613291.png" alt="image-20201206131613291" style="zoom:67%;" /></p><h3 id="事务定义接口"><a href="#事务定义接口" class="headerlink" title="事务定义接口"></a>事务定义接口</h3><p>在创建好<bean>标签后，还需要说明事务的类型。</p><p>事务定义接口TransactionDefinition中定义了事务描述相关的三类常量：事务隔离级别、事务传播行为和事务默认超时时限，及对它们的操作。</p><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p>事务的并发问题：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201206102734602.png" alt="image-20201206102734602" style="zoom:50%;" /></p><p>隔离级别就是用来处理这些问题。</p><p>可取五个值，但实际只有四种情况(这四种情况由上到下隔离级别越来越高)：</p><ul><li>DEFAULT：采用数据库默认事务隔离级别，MySQL默认为REPEATABLE_READ</li><li>READ_UNCOMMITED：读未提交，<strong>一个事务可以读取另一个未提交事务的数据</strong>，未解决任何并发问题</li><li>READ_COMMITED：读已提交，<strong>一个事务要等到另一个事务提交后，才能读取事务。</strong>解决读脏数据、存在不可重复读和幻读</li><li>REPEATABLE_READ：可重复读，<strong>就是在开始读取数据后，不允许修改数据。</strong>解决读脏数据、不可重复读，存在幻读</li><li>SERIALIZABLE：串行化，<strong>即事务串行化顺序执行</strong>，不存在并发问题。但是这种级别效率很低，很耗数据库性能，一般不使用</li></ul><h4 id="事务超时时间"><a href="#事务超时时间" class="headerlink" title="事务超时时间"></a>事务超时时间</h4><p>表示一个方法最长的执行时间，如果方法执行超过了该时间，事务就回滚。单位是秒，整数。默认为-1.</p><p>一般不去管它，使用默认值即可。</p><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务传播行为是指：处在不同事务的方法在相互调用时，执行期间事务的维护情况。例如：A事务中的方法doSome()调用B事务中的方法doOther()，在调用执行期间事务的维护情况，就是事务传播行为。事务传播行为行为是加在方法上的。</p><p>事务传播行为常量都是以PROPAGATION_开头，一共有其中情况</p><ul><li><strong>PROPAGATION_REQUIRED</strong></li><li><strong>PROPAGATION_REQUIRES_NEW</strong></li><li><strong>PROPAGATION_SUPPORTS</strong></li><li>PROPAGATION_MANDATORY</li><li>PROPAGATION_NESTED</li><li>PROPAGATION_NEVER</li><li>PROPAGATION_NOT_SUPPORTED</li></ul><p>其中前三个最为常用，只需掌握前三个即可。</p><h5 id="PROPAGATION-REQUIRED"><a href="#PROPAGATION-REQUIRED" class="headerlink" title="PROPAGATION_REQUIRED"></a><strong>PROPAGATION_REQUIRED</strong></h5><p>指定的方法必须在事务内执行，若当前存在事务，就加入到当前事务；若当前没有事务，则必须创建一个事务，然后加入到新创建的事务中。<strong>总而言之，指定了该传播行为的方法，必须在事务内执行。</strong></p><p>例如：如果该传播行为加在A方法上，在B方法中调用A方法。如果，B方法是在事务内执行的，那么A方法就加入到该事务；如果B方法没有在事务内执行，那么在A方法内会创建一个事务，并在其中执行。</p><h5 id="PROPAGATION-SUPPORTS"><a href="#PROPAGATION-SUPPORTS" class="headerlink" title="PROPAGATION_SUPPORTS"></a><strong>PROPAGATION_SUPPORTS</strong></h5><p>指定的方法支持当前事务，但如果没有事务，也可以以非事务方式执行。也就是说，指定了该传播行为的方法，如果执行时有事务，就在事务内执行，如果没有，同样可以在无事务下运行。</p><h5 id="PROPAGATION-REQUIRES-NEW"><a href="#PROPAGATION-REQUIRES-NEW" class="headerlink" title="PROPAGATION_REQUIRES_NEW"></a><strong>PROPAGATION_REQUIRES_NEW</strong></h5><p>总是新建一个事务，如果当前存在事务，就将该事务挂起，直到新事务执行完毕。</p><h3 id="Spring事务管理使用"><a href="#Spring事务管理使用" class="headerlink" title="Spring事务管理使用"></a>Spring事务管理使用</h3><p>管理事务的是事务管理器接口和它的实现类。</p><p>使用时，有以下几个步骤：</p><ul><li>指定要使用的事务管理器实现类，使用<bean>标签</li><li>指定哪些类的哪些方法需要加入事务的功能</li><li>指定隔离级别、传播行为和超时时间</li></ul><h3 id="使用注解管理事务"><a href="#使用注解管理事务" class="headerlink" title="使用注解管理事务"></a>使用注解管理事务</h3><p>通过使用@Transactional注解方式，该注解是spring框架提供的，可以将事务植入到相应public方法中，实现事务管理。</p><p>@Transactional注解的可选属性如下：</p><ul><li>propagation：用于设置事务传播属性，属性类型为Propagation枚举。默认值为PROPAGATION_REQUIRED</li><li>isolation：用于设置事务隔离级别，属性类型为Isolation枚举。默认值为ISLLATION_DEFAULT</li><li>readOnly：用于设置该方法对于数据库操作是否是只读的。属性为boolean，默认值为false。当查询操作时，可设为true</li><li>timeout：设置本操作与数据库连接的超时时限。单位为秒，类型为int，默认值为-1，即没有时限。</li><li>rollbackFor：指定需要回滚的异常类。即方法抛出这些异常类，就需要回滚。类型为Class[]，默认值为空数组。当只有一个异常类时，可以不使用数组。</li><li><p>rollbackForClassName：指定需要回滚的异常类类名，类型为String[]，默认值为空数组。当只有一个异常类时，可以不使用数组</p></li><li><p>noRollbackFor：指定不需要回滚的异常类，即抛出这些异常时，不需要回滚。类型为Class[]，默认值为空数组。当只有一个异常类时，可以不使用数组。</p></li><li>noRollbackForClassName：指定需要不回滚的异常类类名，类型为String[]，默认值为空数组。当只有一个异常类时，可以不使用数组</li></ul><p><strong>注意：</strong></p><p><strong>@Transactional注解</strong></p><ul><li><p><strong>若用在方法上，只能用在public方法上。对于非public方法，如果加上@Transactional注解，spring不会报错，但不会将指定事务植入到该方法。因为Spring会忽略掉所有非public方法的@Transactional注解。</strong></p></li><li><p><strong>若@Transactional注解用在类上，则表示该类的所有public方法都植入事务。</strong></p></li><li><p>rollbackFor：表示发生指定的异常一定回滚</p><p>  处理机制是：</p><ol><li>spring框架会首先检查抛出的异常是否在rollbackFor的属性值中，如果在，那么不管是什么类型异常，一定回滚</li><li><p>如果不在rollbackFor中，那么spring会判断异常是不是RuntimeException，如果是一定回滚。</p><p><strong>所以，rollbackFor其实只管编译时异常，而不需要管运行时异常。因为抛出运行时异常一定回滚。</strong></p></li></ol></li></ul><h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol><li><p>在配置文件中声明事务管理器，就是使用<bean>标签声明事务管理器对象，属性dataSource就是创建的数据源</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSourcce&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><ol><li><p>开启注解驱动，就是告诉spring框架，要使用注解的方式管理事务。</p><p> Spring使用AOP机制，创建@Transactional所在类的代理对象，给方法加入事务的功能。</p><p> 在业务方法执行之前，开启事务，业务方法之后，提交或回滚事务，使用的是AOP的环绕通知。</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p> 注意：这里有四个同名的annotation-driven对应的命名空间，应该选择这个</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;<br></code></pre></td></tr></table></figure></li></ol><ol><li><p>业务层public方法加上事务属性，即在方法上加上@Transactional注解</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">@Transactional(<br>        propagation = Propagation.REQUIRED,<br>        isolation = Isolation.DEFAULT,<br>        readOnly = false,<br>        rollbackFor = &#123;...&#125;<br>)<br></code></pre></td></tr></table></figure><p> 可以这样写，也可以直接写<code>@Transactional</code>，不加括号里的内容。则代表使用默认值，rollbackFor默认抛出运行时异常时回滚事务。</p></li></ol><h2 id="一个完整的例子"><a href="#一个完整的例子" class="headerlink" title="一个完整的例子"></a>一个完整的例子</h2><h3 id="创建两个表"><a href="#创建两个表" class="headerlink" title="创建两个表"></a>创建两个表</h3><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201206130953994.png" alt="image-20201206130953994" style="zoom:50%;" /></p><h3 id="加入pom依赖"><a href="#加入pom依赖" class="headerlink" title="加入pom依赖"></a>加入pom依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.13.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.annotation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.annotation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h3><p>两个实体类，Goods和Sale</p><p>Goods：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Goods</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer amount;<br>    <span class="hljs-keyword">private</span> Float price;<br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//set和get方法</span><br>&#125;    <br></code></pre></td></tr></table></figure><p>Sale：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sale</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> Integer gid;<br>    <span class="hljs-keyword">private</span> Integer nums;<br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//set和get方法</span><br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h3><p>同样有两个，操作Goods的GoodsDao接口，操作Sale的SaleDao接口。</p><p>GoodsDao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GoodsDao</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateGoods</span><span class="hljs-params">(Goods goods)</span>;<br>    Goods <span class="hljs-title function_">selectGoods</span><span class="hljs-params">(Integer goodsId)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>SaleDao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SaleDao</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">insertSale</span><span class="hljs-params">(Sale sale)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建映射文件"><a href="#创建映射文件" class="headerlink" title="创建映射文件"></a>创建映射文件</h3><p>一个接口一个映射文件</p><p>GoodsDao.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.example.dao.GoodsDao&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateGoods&quot;</span>&gt;</span><br>        update goods  set amount = amount - #&#123;amount&#125; where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectGoods&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Goods&quot;</span>&gt;</span><br>        select * from goods where id = #&#123;goodsId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>SaleDao.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.example.dao.SaleDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertSale&quot;</span>&gt;</span><br>        insert into sale(gid, nums) values (#&#123;gid&#125;,#&#123;nums&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><p>定义一个库存不足抛出的异常类NotEnoughException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NotEnoughException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotEnoughException</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NotEnoughException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建Service接口和实现类"><a href="#创建Service接口和实现类" class="headerlink" title="创建Service接口和实现类"></a>创建Service接口和实现类</h3><p>接口中只定义一个buy方法，代表买商品，需要操作两个表，在Sale中加入销售记录，更新Goods表中对应商品库存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BuyGoodsService</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> goodsId:购买商品的编号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums:购买商品的数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">(Integer goodsId, Integer nums)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BuyGoodsServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BuyGoodsService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> GoodsDao goodsDao;<br>    <span class="hljs-keyword">private</span> SaleDao saleDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setGoodsDao</span><span class="hljs-params">(GoodsDao goodsDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.goodsDao = goodsDao;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSaleDao</span><span class="hljs-params">(SaleDao saleDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.saleDao = saleDao;<br>    &#125;<br><br><br>    <span class="hljs-comment">//增加事务注解，也可以直接加上@Transactional，效果一样</span><br>    <span class="hljs-meta">@Transactional(</span><br><span class="hljs-meta">            propagation = Propagation.REQUIRED,</span><br><span class="hljs-meta">            isolation = Isolation.DEFAULT,</span><br><span class="hljs-meta">            readOnly = false,</span><br><span class="hljs-meta">            rollbackFor = &#123;NullPointerException.class, NotEnoughException.class&#125;</span><br><span class="hljs-meta">    )</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//这个方法先插入销售记录，而不是先判断存不存在该商品和商品库存，是为了更明显的显示事务回滚和提交</span><br>    <span class="hljs-comment">//如果没有该注解，那么当抛出异常，销售记录依然存在</span><br>    <span class="hljs-comment">//加上注解，抛出了异常，事务回滚，销售记录会删除</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">(Integer goodsId, Integer nums)</span> &#123;<br>        <span class="hljs-type">Sale</span> <span class="hljs-variable">sale</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sale</span>();<br>        sale.setGid(goodsId);<br>        sale.setNums(nums);<br>        saleDao.insertSale(sale);<br>        <span class="hljs-type">Goods</span> <span class="hljs-variable">goods</span> <span class="hljs-operator">=</span> goodsDao.selectGoods(goodsId);<br>        <span class="hljs-keyword">if</span>(goods == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;没有该商品&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(goods.getAmount() &lt; nums) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NotEnoughException</span>(<span class="hljs-string">&quot;商品库存不足&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-type">Goods</span> <span class="hljs-variable">buyGoods</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Goods</span>();<br>        buyGoods.setId(goodsId);<br>        buyGoods.setAmount(nums);<br>        goodsDao.updateGoods(buyGoods);<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写spring配置文件"><a href="#编写spring配置文件" class="headerlink" title="编写spring配置文件"></a>编写spring配置文件</h3><p>省略了mybatis配置文件和属性文件，因为非常简单。</p><p>spring配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.alibaba.com/schema/stat http://www.alibaba.com/schema/stat.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druid&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.maxActive&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druid&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis.xml&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.example.dao&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;buyGoodsService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.Service.impl.BuyGoodsServiceImpl&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;goodsDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;goodsDao&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;saleDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;saleDao&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--创建事务管理器对象--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druid&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-comment">&lt;!--事务驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> /&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h3><p>只测试抛出异常的情况。抛出两个异常，事务都会回滚，情况差不多，只测试一个</p><h4 id="抛出NotEnoughException异常"><a href="#抛出NotEnoughException异常" class="headerlink" title="抛出NotEnoughException异常"></a>抛出NotEnoughException异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testBuyGoodsService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;applicationContext.xml&quot;</span>;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(config);<br>    <span class="hljs-type">BuyGoodsService</span> <span class="hljs-variable">buyGoodsService</span> <span class="hljs-operator">=</span> (BuyGoodsService) applicationContext.getBean(<span class="hljs-string">&quot;buyGoodsService&quot;</span>);<br>    buyGoodsService.buy(<span class="hljs-number">1001</span>, <span class="hljs-number">10000</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>库存不够，运行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201206132520782.png" alt="image-20201206132520782" style="zoom:50%;" /></p><p>同时Sale表和Goods表并没有发生变化：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201206132559732.png" alt="image-20201206132559732" style="zoom:50%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201206132607728.png" alt="image-20201206132607728" style="zoom:50%;" /></p><h2 id="使用AspectJ的AOP配置管理事务"><a href="#使用AspectJ的AOP配置管理事务" class="headerlink" title="使用AspectJ的AOP配置管理事务"></a>使用AspectJ的AOP配置管理事务</h2><p>使用注解配置事务代理方式的不足是，当有很多类、很多方法需要配置时，需要大量的配置事务，非常麻烦。</p><p>这时候，使用@AspectJ的AOP来进行配置。在spring配置文件中声明类、方法需要的事务，使用这种方法，业务逻辑和事务配置完全分离。</p><p>适合大型项目。前面那一种适合中小型项目。</p><h3 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h3><h3 id="声明事务管理器对象"><a href="#声明事务管理器对象" class="headerlink" title="声明事务管理器对象"></a>声明事务管理器对象</h3><p>只要有事务管理，就要声明事务管理器对象，这个和前面是一样的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="配置事务属性"><a href="#配置事务属性" class="headerlink" title="配置事务属性"></a>配置事务属性</h3><p>因为不使用注解来配置事务，就需要在配置文件中进行配置。</p><p>使用<code>&lt;tx:advice&gt;</code>标签，事务通知来进行配置</p><p>语法格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中</p><p><code>&lt;tx:advice&gt;</code>的id属性用来标识该标签，是一个自定义的唯一值。</p><p>transaction-manager属性是事务管理器的id。</p><p><code>&lt;tx:attributes&gt;</code>中有<code>&lt;tx:method&gt;</code>标签，是用来给具体的方法配置事务，可以有多个，分别给不同方法设置事务属性。</p><p><code>&lt;tx:method&gt;</code>中：</p><ul><li>name：方法名称，值有两种类型<ol><li>完整的方法名称，不带包和类</li><li>使用通配符*表示任意字符</li></ol></li><li>propagation：事务传播行为</li><li>isolation：事务隔离级别</li><li>read-only：是否只读</li><li>no-rollback-for：回滚异常类，值是异常类的全限定类名，多个类用 <code>,</code>分开</li></ul><p>注意：如果使用通配符配置方法名称，应该设置同一类的方法名称有共同的单词，便于通配符设置。</p><h3 id="配置AOP"><a href="#配置AOP" class="headerlink" title="配置AOP"></a>配置AOP</h3><p>配置好不同方法事务属性后，可以发现我们并没有指定是哪个包哪个类的方法。就是说，如果有多个类都有同一个方法，应该使用哪个方法。</p><p>那么下面就需要配置AOP，来指定</p><p>语法格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution()&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中：<br><strong>标签<code>&lt;aop:pointcut&gt;</code>用来设置切入点，id用来唯一标识该切入点，expression属性就是切入点表达式。用来指定哪些包的哪些类使用事务。</strong></p><p><strong>标签<code>&lt;aop:advisor&gt;</code>用来将前面的事务通知标签<code>&lt;tx:advice&gt;</code>和切入点pointcut标签连接起来。两个属性值都是id值</strong></p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在之前的例子基础上，修改一下</p><h4 id="配置事务管理器对象"><a href="#配置事务管理器对象" class="headerlink" title="配置事务管理器对象"></a>配置事务管理器对象</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druid&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="配置事务通知"><a href="#配置事务通知" class="headerlink" title="配置事务通知"></a>配置事务通知</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="配置AOP-1"><a href="#配置AOP-1" class="headerlink" title="配置AOP"></a>配置AOP</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;service&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* *.*.service..*.*(..))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;advice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;service&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><p>切入点表达式代表，service之前有两个包，service之后的<code>..</code>代表service包和子包</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-Spring集成MyBatis</title>
    <link href="/2022/05/11/Spring/7-Spring%E9%9B%86%E6%88%90MyBatis/"/>
    <url>/2022/05/11/Spring/7-Spring%E9%9B%86%E6%88%90MyBatis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="7-Spring集成MyBatis"><a href="#7-Spring集成MyBatis" class="headerlink" title="7-Spring集成MyBatis"></a>7-Spring集成MyBatis</h1><h2 id="MyBatis使用步骤"><a href="#MyBatis使用步骤" class="headerlink" title="MyBatis使用步骤"></a>MyBatis使用步骤</h2><p>先来回顾以下MyBatis的使用步骤：</p><ol><li>创建DAO接口</li><li>创建实体类</li><li>创建映射文件</li><li>创建MyBatis主配置文件</li><li>使用SqlSessionFactory创建出SqlSession对象(也在主配置文件中)</li><li>使用SqlSession对象获得dao接口的实现类对象</li><li>执行数据库操作</li></ol><h2 id="集成到Spring后需要的改动"><a href="#集成到Spring后需要的改动" class="headerlink" title="集成到Spring后需要的改动"></a>集成到Spring后需要的改动</h2><p>那么将MyBatis集成到Spring中以后。需要改动的有：</p><ul><li>主配置文件中不再需要数据源的配置，数据源要交给Spring容器来管理，在spring配置文件中配置。</li><li>对mapper文件的注册，应该使用<package />标签，即只需要给出mapper映射文件所在的包。因为mapper文件的名称和DAO接口名称相同。因此使用这种方式的好处是，若有多个映射文件，配置也不需要修改。当然也可以使用原来的<resource />标签</li><li>SqlSessionFactory对象不需要我们来创建，也交给spring容器。</li><li>DAO对象同样交给spring容器。</li></ul><p>因此，需要让spring创建的对象有：</p><ul><li>独立的连接池类对象，不使用MyBatis默认的连接池，而使用阿里的Druid连接池</li><li>SqlSessionFactory对象</li><li>dao对象</li></ul><p><strong>注意：MyBatis集成到Spring后，默认是自动提交事务，不需要写<code>sqlSession.comit();</code>。</strong></p><h2 id="MyBAtis集成到Spring后使用步骤"><a href="#MyBAtis集成到Spring后使用步骤" class="headerlink" title="MyBAtis集成到Spring后使用步骤"></a>MyBAtis集成到Spring后使用步骤</h2><ol><li><p>新建Maven项目</p></li><li><p>加入maven依赖</p><ul><li>spring依赖</li><li>mybatis依赖</li><li>mybatis和spring集成的依赖</li><li>mysql驱动依赖</li><li>spring事务的依赖</li></ul></li><li><p>创建实体类</p></li><li><p>创建dao接口</p></li><li><p>创建mapper文件</p></li><li><p>创建myBatis主配置文件</p></li><li><p>创建Service接口和实现类，实现类成员变量是dao对象</p></li><li><p>创建spring配置文件：声明将mybatis的对象交给spring创建，有：</p><ul><li>数据源</li><li>SqlSessionFactory</li><li>DAO对象</li><li>自定义的Service对象</li></ul></li><li><p>编写测试代码，获取Service对象，通过service调用dao来操作数据库</p></li></ol><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>首先在spring配置文件applicationContext.xml文件中配置数据源，查询druid的github官网，可以看到通用配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc_url&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc_user&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc_password&#125;&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;filters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;stat&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;initialSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxWait&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;60000&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;timeBetweenEvictionRunsMillis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;60000&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;minEvictableIdleTimeMillis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;300000&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testWhileIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testOnBorrow&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testOnReturn&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;poolPreparedStatements&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxOpenPreparedStatements&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;asyncInit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中属性 <code>init-method=&quot;init&quot;</code>和<code>destory-method=&quot;close&quot;</code>是固定的，这两个方法是在DruidDataSource中写好的。</p><p>在上面的配置中，通常只需要配置url、username、password和maxActive。</p><p>其中maxActive是设置最大有多少连接数。</p><p>Druid会自动根据url识别驱动类名，所以不需要配置driver。</p><h2 id="创建SqlSessionFactory对象"><a href="#创建SqlSessionFactory对象" class="headerlink" title="创建SqlSessionFactory对象"></a>创建SqlSessionFactory对象</h2><p>在spring文件中配置SqlSessionFactory对象。</p><p>之前创建SqlSessionFactory对象，只需要MyBatis配置文件，但是现在把数据源的配置挪到了Spring配置文件中，所以需要两部分，一是Spring配置的数据源，二是mybatis配置文件。</p><p>格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中，第一个<property>的ref属性是上面配置数据源的id</p><p>第二个<property>标签，是指定mybatis配置文件路径的。<strong>但是需要使用value属性，并且要加上<code>classpath:</code></strong></p><p>在后面写上mybatis的配置文件路径。</p><h2 id="创建DAO接口对象"><a href="#创建DAO接口对象" class="headerlink" title="创建DAO接口对象"></a>创建DAO接口对象</h2><p>将创建dao接口对象也交给Spring容器，在配置文件中进行配置。</p><p>传统创建DAO对象，需要使用SqlSession对象，调用它的getMapper()方法，并把接口的类作为参数传给该方法。</p><p>那么在配置时，同样需要这几项。</p><p>使用MapperScannerConfigurer类：它会在内部多次调用getMapper生成多个dao接口的代理对象</p><p>语法格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>该bean不需要id属性。</strong></p><p>其中，第一个<property>标签， 指定的是SqlSessionFactory，值应该是之前创建的SqlSessionFactory的id</p><p>第二个<property>标签，指定的是DAO接口所在的包名，MapperScannerConfigurer会扫描这个包的每个接口，调用getMapper方法创建每个接口的代理对象，也就是DAO对象。</p><p><strong>创建的dao对象的名字是接口名的首字母小写。</strong></p><h2 id="创建Service接口和实现类"><a href="#创建Service接口和实现类" class="headerlink" title="创建Service接口和实现类"></a>创建Service接口和实现类</h2><p>在service包下，创建表的service接口。并在service.impl包下，创建对应实现类。在实现类里定义dao接口对象成员变量，然后不同方法对应数据库的操作。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>首先创建实体类Student：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-comment">//构造器</span><br>    <span class="hljs-comment">//set和get方法</span><br>&#125;    <br></code></pre></td></tr></table></figure><p>在dao包中创建DAO接口StudentDao</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentDao</span> &#123;<br><br>    Integer <span class="hljs-title function_">insertStudent</span><span class="hljs-params">(Student student)</span>;<br>    List&lt;Student&gt; <span class="hljs-title function_">selectStudent</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.example.dao.StudentDao&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertStudent&quot;</span>&gt;</span><br>        insert into student values (#&#123;id&#125;, #&#123;name&#125;, #&#123;email&#125;, #&#123;age&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectStudent&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;org.example.domain.Student&quot;</span>&gt;</span><br>        select * from student<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建MyBatis主配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--输出日志到控制台--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置别名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example.domain&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--映射文件配置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.example.dao&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>创建service接口和实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StudentService</span> &#123;<br><br>    Integer <span class="hljs-title function_">addStudent</span><span class="hljs-params">(Student student)</span>;<br>    List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StudentService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> StudentDao studentDao;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStudentDao</span><span class="hljs-params">(StudentDao studentDao)</span> &#123;<br>        <span class="hljs-built_in">this</span>.studentDao = studentDao;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">addStudent</span><span class="hljs-params">(Student student)</span> &#123;<br>        <span class="hljs-keyword">return</span> studentDao.insertStudent(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;Student&gt; <span class="hljs-title function_">selectStudents</span><span class="hljs-params">()</span> &#123;<br>        List&lt;Student&gt; list = studentDao.selectStudent();<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建spring配置文件applicationContext.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--配置数据源--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druid&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;*******&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;20&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--创建SqlSessionFactory对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;druid&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis.xml&quot;</span> /&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--创建dao接口代理对象--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.example.dao&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;studentService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.service.impl.StudentServiceImpl&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;studentDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;studentDao&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>编写测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSelectStudents</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;applicationContext.xml&quot;</span>;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(config);<br>    <span class="hljs-type">StudentService</span> <span class="hljs-variable">studentService</span> <span class="hljs-operator">=</span>(StudentService) applicationContext.getBean(<span class="hljs-string">&quot;studentService&quot;</span>);<br><br>    List&lt;Student&gt; list = studentService.selectStudents();<br>    <span class="hljs-keyword">for</span>(Student stu: list) &#123;<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAddStudent</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;applicationContext.xml&quot;</span>;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(config);<br>    <span class="hljs-type">StudentService</span> <span class="hljs-variable">studentService</span> <span class="hljs-operator">=</span>(StudentService) applicationContext.getBean(<span class="hljs-string">&quot;studentService&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">1012</span>, <span class="hljs-string">&quot;林冲&quot;</span>, <span class="hljs-string">&quot;linchong@qq.com&quot;</span>, <span class="hljs-number">35</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> studentService.addStudent(stu);<br>    System.out.println(<span class="hljs-string">&quot;影响行数为：&quot;</span> + num);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行查询操作，运行结果为：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201204155239728.png" alt="image-20201204155239728" style="zoom:50%;" /></p><p>执行插入操作，运行结果为：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201204155317439.png" alt="image-20201204155317439" style="zoom:50%;" /></p><h2 id="使用属性文件"><a href="#使用属性文件" class="headerlink" title="使用属性文件"></a>使用属性文件</h2><p>使用properties属性文件来配置数据库连接信息，在spring配置文件中引用配置文件。</p><p>首先加入在spring配置文件中加入命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br></code></pre></td></tr></table></figure><p>然后使用<code>&lt;context:property-placeholder location=&quot;classpath:&quot; /&gt;</code></p><p>标签来设置属性文件的路径</p><p>最后通过<code>$&#123;属性文件中设置的key&#125;</code>来进行访问</p><p>例子：</p><p>设置路径：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:jdbc.properties&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;druid&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;init&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;close&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.max&#125;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-动态代理AOP</title>
    <link href="/2022/05/11/Spring/6-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86AOP/"/>
    <url>/2022/05/11/Spring/6-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86AOP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="6-动态代理AOP"><a href="#6-动态代理AOP" class="headerlink" title="6-动态代理AOP"></a>6-动态代理AOP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​        AOP(Aspect Orient Programming)，面向切面编程，是一种可以通过运行期间动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重写性，同时提高了开发效率。</p><p>​        具体来说，面向切面编程就是将交叉业务逻辑封装成切面，利用AOP容器的功能将切面植入到主业务逻辑中，交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，例如日志，缓存，安全检查等。</p><p>​        AOP底层，采用的就是动态代理模式，采用了两种代理：jdk的动态代理，和CGLIB的动态代理。</p><p>​        AOP实际就是动态代理的规范化，把动态代理的实现步骤、方式定义好，开发人员使用统一的方式实现动态代理。</p><h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><p>​        使用jdk的Proxy、Method和InvocationHandler创建代理对象，<strong>jdk动态代理要求目标类必须实现接口。</strong></p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>​        是第三方的工具库，创建代理对象，原理是继承。<strong>通过继承目标类，来创建子类，子类就是代理对象。</strong>这种方式要求目标类不能是final，方法也不能是final。</p><h2 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h2><h3 id="一些术语"><a href="#一些术语" class="headerlink" title="一些术语"></a>一些术语</h3><ol><li><strong>Aspect：切面，表示增强的功能。一般是一个类，也叫作切面类。完成一个非业务功能。常见有日志，事务，权限验证。</strong></li><li>JoinPoint：连接点，连接业务方法和切面的位置，就是目标类的业务方法。</li><li><strong>Pointcut：切入点，指多个连接点方法的集合，多个方法。</strong><ul><li><strong>执行目标对象方法，动态的植入切面代码</strong></li><li><strong>通过切入点表达式，指定拦截哪些类的哪些方法，给指定的类在运行的时候植入切面类代码</strong></li></ul></li><li><strong>切入点表达式：指定哪些类的哪些方法被拦截，即被植入切面类代码</strong></li><li>目标对象：给哪个类增加功能，那么这个类就是目标对象</li><li>Advice：通知，通知表示切面功能指向的时间，在目标方法之前还是之后。</li></ol><h3 id="切面的三个关键要素"><a href="#切面的三个关键要素" class="headerlink" title="切面的三个关键要素"></a>切面的三个关键要素</h3><ol><li>切面的功能代码，也就是切面能干什么</li><li>切面的执行位置，使用Pointcut来表示，也就是切面代码在哪个位置</li><li>切面的执行时间，使用Advice表示时间，在目标方法之前还是之后。</li></ol><h2 id="AOP的实现"><a href="#AOP的实现" class="headerlink" title="AOP的实现"></a>AOP的实现</h2><p>AOP是动态代理的一个规范化。</p><p>AOP的技术实现框架：</p><ol><li>spring：spring在内部实现了AOP规范，Spring主要在事务处理中使用AOP，在项目开发中很少使用Spring的AOP实现，因为比较笨重。</li><li>AspectJ：一个开源的框架，专门做AOP。Spring框架中集成了aspectj框架，通过spring就可以使用aspectj的功能。</li></ol><p>aspectj框架实现AOP有两种方式：</p><ul><li>使用XML的配置文件</li><li>使用注解，常用。</li></ul><h2 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h2><h3 id="AspectJ中的几个常用类"><a href="#AspectJ中的几个常用类" class="headerlink" title="AspectJ中的几个常用类"></a>AspectJ中的几个常用类</h3><h4 id="JoinPoint接口"><a href="#JoinPoint接口" class="headerlink" title="JoinPoint接口"></a>JoinPoint接口</h4><p>JoinPoint是Aspectj框架的一个类，表示切入点，它包含被执行的方法的一些信息，例如参数，方法修饰符等等。</p><p>在使用通知注解拦截目标方法后，可以在被注解方法签名中加上该参数，来获取被拦截的方法的一些信息。</p><p>常用方法：</p><ul><li><code>Signature getSignature()</code>：获取封装了署名信息的对象，该对象可以获取到目标方法名，所属类的Class等信息</li><li><code>Object[] getArgs()</code>：获取传入目标方法的参数对象</li><li><code>Object getTarget()</code>：获取被代理的对象</li><li><code>Object getThis()</code>：获取代理对象</li></ul><h4 id="ProceedingJoinPoint接口"><a href="#ProceedingJoinPoint接口" class="headerlink" title="ProceedingJoinPoint接口"></a>ProceedingJoinPoint接口</h4><p>该接口是JoinPoint的子接口，只在环绕通知后的方法参数中使用。</p><p>除了上述方法，还有一个proceed的方法，用来执行目标方法。</p><h3 id="aspectj的切入点表达式"><a href="#aspectj的切入点表达式" class="headerlink" title="aspectj的切入点表达式"></a>aspectj的切入点表达式</h3><p>AspectJ定义了专门的表达式用于指定切入点，表达式的原型是：</p><p>​            <code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)  throws-pattern?)</code></p><p>​    解释：</p><ul><li>modifiers-pattern：访问权限类型</li><li><strong>ret-type-pattern：返回值类型</strong></li><li>declaring-type-pattern：包名类名</li><li><strong>name-pattern(param-pattern)：方法名(参数类型和参数个数)</strong></li><li>thorws-pattern：抛出异常类型</li></ul><p>​    ？代表可选的部分</p><p>​        加粗代表必须部分</p><p>用中文来表达就是：</p><p><code>execution(访问权限  方法返回值   方法声明(参数) 异常类型)</code></p><p>各部分使用空格分开，在其中可以使用以下符号</p><ul><li>*：0至多个任意字符</li><li>.. ：用在方法参数中，表示任意多个参数；用在包名后，表示当前包及其子包路径</li><li>+：用在类名后，表示当前类及其子类；用在接口后，表示当前接口及其实现类</li></ul><p>例子：</p><ul><li>execution(public <em> </em>(..))：指定切入点为：任意的公共方法</li><li>execution(<em> set</em>(..))：指定切入点为：任意一个以“set”开始的方法</li><li>execution(<em> com.exy.service. </em> . *(..))：指定切入点为com.exy.service包中任意一个类的任意一个方法</li></ul><h3 id="AspectJ通知注解"><a href="#AspectJ通知注解" class="headerlink" title="AspectJ通知注解"></a>AspectJ通知注解</h3><p>所有通知的方法都包含一个JoinPoint类型参数，就是一个切入点表达式。</p><h4 id="Before"><a href="#Before" class="headerlink" title="@Before"></a>@Before</h4><p>​        在目标方法执行之前执行。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201129143540935.png" alt="image-20201129143540935" style="zoom:50%;" /></p><h4 id="AfterReturning"><a href="#AfterReturning" class="headerlink" title="@AfterReturning"></a>@AfterReturning</h4><p>在目标方法执行之后执行，所以可以获取到目标方法的返回值。该注解的returning属性就是用于指定接收方法返回值的变量名的。所以被注解为后置通知的方法，除了可以包含JoinPoint参数(<strong>该参数必须放在被注解方法的第一个参数位置</strong>)外，还可以包含用于接收返回值的变量，该变量最好为Object类型。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201129143712141.png" alt="image-20201129143712141" style="zoom:50%;" /></p><h4 id="Around"><a href="#Around" class="headerlink" title="@Around"></a>@Around</h4><p>在目标方法之前或之后执行。<strong>被注解为环绕增强方法要有返回值，推荐使用Object类型，</strong>并且方法可以包含一个ProceedingJoinPoint类型的参数，接口ProceedingJoinPoint有一个proceed方法，用于执行目标方法，若目标方法有返回值，那么该方法的返回值就是目标方法返回值，最后环绕增强方法将返回值返回。该增强方法实际是拦截了目标方法的执行。</p><p>环绕通知实际就等同于是jdk的动态代理。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201129143222572.png" alt="image-20201129143222572" style="zoom:43%;" /></p><p>因为目标方法是在被注解方法中，调用ProceedingJoinPoint的proceed方法执行的，所以被注解方法可以影响目标方法的执行，例如只在参数等于某个值或不等于某个值时执行。</p><p>例子：</p><p>doAround方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">doAround</span><span class="hljs-params">(String name)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;执行doAround方法,name为:&quot;</span> + name);<br>    <span class="hljs-keyword">return</span> name;<br>&#125;<br></code></pre></td></tr></table></figure><p>切面类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Around(value = &quot;execution(* doAround(..))&quot;)</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">myAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>       Object[] args = pjp.getArgs();<br>       <span class="hljs-comment">//判断传入参数是否为空，并且长度是否大于零</span><br>       <span class="hljs-keyword">if</span>(args != <span class="hljs-literal">null</span> &amp;&amp; args.length &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) args[<span class="hljs-number">0</span>];<br>           <span class="hljs-comment">//如果等于Jack，那么就执行目标方法，否则额拦截该方法</span><br>           <span class="hljs-keyword">if</span>(name.equals(<span class="hljs-string">&quot;Jack&quot;</span>)) &#123;<br>               pjp.proceed();<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               System.out.println(<span class="hljs-string">&quot;方法被拦截，doAround方法没有执行!&quot;</span>);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201201094811143.png" alt="image-20201201094811143" style="zoom:33%;" /><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201201094837260.png" alt="image-20201201094837260"></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201201094857381.png" alt="image-20201201094857381" style="zoom:33%;" /></p><h4 id="AfterThrowing"><a href="#AfterThrowing" class="headerlink" title="@AfterThrowing"></a>@AfterThrowing</h4><p>在目标方法抛出异常后执行，该注解的throwing属性用于指定所发生的的异常类对象，被注解为异常通知的方法可以包含JoinPoint参数和Throwable参数，参数名称为thorwing指定的名称，表示发生异常的对象。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201129143432571.png" alt="image-20201129143432571" style="zoom:53%;" /></p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201129143504626.png" alt="image-20201129143504626" style="zoom:50%;" /></p><h4 id="After"><a href="#After" class="headerlink" title="@After"></a>@After</h4><p>无论方法是否抛出异常，该增强方法都会执行。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201129143808737.png" alt="image-20201129143808737" style="zoom:50%;" /></p><h3 id="Pointcut"><a href="#Pointcut" class="headerlink" title="Pointcut"></a>Pointcut</h3><p>​        当较多的通知增强方法使用相同的execution切入点表达式时，编写、维护比较麻烦。Aspectj提供了@Pointcut注解，来定义execution切入点表达式。</p><p>​        用法是，将@Pointcut注解在一个方法之上，<strong>以后所有的execution的value属性值都可以使用该方法名作为切入点</strong>，代表的就是@Pointcut定义的切入点，使用@Pointcut注解的方法一般使用private标识，没有实际作用。</p><p>​        实际上使用@Pointcut，就相当于定义了一个变量，可以重复使用。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(value = &quot;execution(* *..service.*.*(..))&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">mypointcut</span><span class="hljs-params">()</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>那么在之后使用切入点表达式就可以直接写<code>@After(value = &quot;mypointcut()&quot;)</code>即可。</p><h2 id="使⽤Spring-AOP开发步骤-Aspectj"><a href="#使⽤Spring-AOP开发步骤-Aspectj" class="headerlink" title="使⽤Spring AOP开发步骤(Aspectj)"></a>使⽤Spring AOP开发步骤(Aspectj)</h2><h3 id="引入AOP相关jar文件"><a href="#引入AOP相关jar文件" class="headerlink" title="引入AOP相关jar文件"></a>引入AOP相关jar文件</h3><ul><li>spring-aop—3.2.5.RELEASE.jar</li><li>aopalliance.jar</li><li>aspectjweaver.jar</li><li>aspectjrt.jar</li></ul><p>其实就是引入spring依赖和aspectj依赖。</p><h3 id="注解⽅式实现AOP编程"><a href="#注解⽅式实现AOP编程" class="headerlink" title="注解⽅式实现AOP编程"></a>注解⽅式实现AOP编程</h3><p>我们之前⼿动的实现AOP编程是需要⾃⼰来编写代理⼯⼚的，现在有了Spring，就不需要我们⾃⼰写代 理⼯⼚了。Spring内部会帮我们创建代理⼯⼚。也就是说，不⽤我们⾃⼰写代理对象了。 因此，我们只要关⼼<strong>切⾯类、切⼊点、编写切⼊表达式指定拦截什么⽅法就可以了！</strong></p><h4 id="创建切面类"><a href="#创建切面类" class="headerlink" title="创建切面类"></a>创建切面类</h4><p>​        其实就是普通类，需要在类上面加入<code>@Aspect</code>注解，来表明它是个切面类。</p><p>​        在类中定义方法，方法就是切面要执行的功能代码，在方法的上面加上aspectj的通知注解，例如<code>@Before</code>或者<code>@After</code>，并且需要指定切入点表达式execution()</p><p>​        其中在切面类中定义方法，该方法有限制：</p><ul><li><p>必须是公共方法，public</p></li><li><p>方法没有返回值，@Around除外</p></li><li><p>方法名称自定义</p></li><li><p>方法可以有参数，也可以没有</p><p>   如果有，那么参数不是自定义的，有几个参数类型可以使用</p><p>  上面已经写了通知注解，除了切入点表达式参数。</p><p>  如果有其他参数，那么被注解的方法也要有相应参数，</p><p>  例如注解<code>@AfterReturning(value = &quot;execution(* *(..))&quot;, returning=&quot;result&quot;)</code>，有一个returning参数，参数名为result，代表目标方法执行后的返回值，那么在被注解的方法签名中也要有参数<code>Object result</code>，参数名必须相同。</p><p>  其他例如异常通知也是这样。</p><p>  被注解方法本身还可以有JoinPoint参数。</p><p>  被注解的方法的参数不需要主动赋值，是aspectj框架自动赋值的。</p></li></ul><h4 id="创建spirng配置文件"><a href="#创建spirng配置文件" class="headerlink" title="创建spirng配置文件"></a>创建spirng配置文件</h4><p>​        在配置文件中声明对象，把对象统一交给容器管理。</p><p>​        声明对象可以用注解，也可以用XML配置。</p><p>​        并且声明aspectj框架中的自动代理生成器标签<code>&lt;aop:aspectj-autoproxy&gt;</code>，这个标签是用来完成代理对象的自动创建功能的。</p><p>​        工作原理是，<code>&lt;aop:aspectj-autoproxy&gt;</code>通过扫描找到@Aspect定义的切面类，再由切面类根据切入点找到目标类的目标方法，再由通知类型找到切入的时间点。</p><p><strong>注意：如果找不到对应的目标方法，那么就不会把代理代码植入到目标类的目标方法中，执行的就是原来代码。</strong></p><h4 id="使用ApplicationContext获取目标对象"><a href="#使用ApplicationContext获取目标对象" class="headerlink" title="使用ApplicationContext获取目标对象"></a>使用ApplicationContext获取目标对象</h4><p>这里的目标对象就是经过aspectj修改后的代理对象，也就是目标类对象。</p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>​        使用注解完成容器管理对象。</p><p>先创建接口有一个doSome方法，实现这个接口创建一个目标类，实现doSome方法，然后再创建切面类，实现在执行doSome方法之前，输出当前时间的功能。</p><p>创建接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SomeService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">(String name, Integer age)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;someService&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SomeService</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">(String name, Integer age)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;名字为 :&quot;</span> +name + <span class="hljs-string">&quot;, 年龄为：&quot;</span> + age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建切面类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component(&quot;myAspect&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br><br>    <span class="hljs-meta">@Before(&quot;execution(public void doSome(String, Integer))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myBefore</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;切面功能，输出执行时间：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test01</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;applicationContext.xml&quot;</span>;<br>    <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">applicationContext</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(config);<br>    <span class="hljs-type">SomeService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (SomeService) applicationContext.getBean(<span class="hljs-string">&quot;someService&quot;</span>);<br>    proxy.doSome(<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">21</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201129145426769.png" alt="image-20201129145426769" style="zoom:50%;" /></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>如果目标类有接口，那么Spring框架默认会使用jdk的动态代理，如果没有接口，那么spring会使用CGLIB代理。</p><p>但是如果希望在有接口的情况下，让Spring使用CGLIB动态代理，就需要在自动代理生成器标签中添加一个属性，<code>proxy-target-class = &quot;true&quot;</code></p><p>即<code>&lt;aop:aspectj-autoproxy  proxy-target-class=&quot;true&quot; /&gt;</code></p><p>就可以让Spring默认使用CGLIB代理。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-基于注解的DI实现</title>
    <link href="/2022/05/11/Spring/5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84DI%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/11/Spring/5-%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84DI%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="5-基于注解的DI实现"><a href="#5-基于注解的DI实现" class="headerlink" title="5-基于注解的DI实现"></a>5-基于注解的DI实现</h1><p>通过注解来配置信息是为了简化IOC容器的配置，注解可以把对象添加到IOC容器中、处理对象依赖关系。</p><h2 id="使用注解步骤"><a href="#使用注解步骤" class="headerlink" title="使用注解步骤"></a>使用注解步骤</h2><ol><li>加入maven的依赖spring-context，加入的同时，也加入了spring-aop的依赖，使用注解必须要使用spring-aop依赖</li><li>在类中加入spring的依赖</li><li>在spring配置文件中，加入一个组件扫描器的标签，来说明注解在项目中的位置</li></ol><h2 id="加入组件扫描器"><a href="#加入组件扫描器" class="headerlink" title="加入组件扫描器"></a>加入组件扫描器</h2><p>在配置文件中加入组件扫描器的标签 <code>&lt;context:component-scan base-package=&quot;&quot; /&gt;</code></p><p>属性：base-package，指定注解要扫描的包名</p><p>扫描器的工作方式：spring会扫描遍历base-package指定的包，递归的找到所有类中的注解，按照注解的功能创建对象或者给属性赋值。</p><p>context是指对应的命名空间，<code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code>。</p><h3 id="指定多个包的方式"><a href="#指定多个包的方式" class="headerlink" title="指定多个包的方式"></a>指定多个包的方式</h3><p>有三种方式</p><ol><li>使用多个<code>&lt;context:component-scan base-package=&quot;&quot; /&gt;</code>语句，指定不同的包</li><li>使用分隔符; 或 ,分割多个包名，例如<code>&lt;context:component-scan base-package=&quot;org.example.package1;org.example.package2&quot;</code></li><li>指定需要扫描的所有包的父包，例如package1和package2的父包是org.example，那么就直接指定这个包即可</li></ol><h2 id="主要学习的注解"><a href="#主要学习的注解" class="headerlink" title="主要学习的注解"></a>主要学习的注解</h2><p>有以下几个：</p><ul><li>@Component</li><li>@Respotory</li><li>@Service</li><li>@Controller</li><li>@Value</li><li>@Autowired</li><li>@Resource</li></ul><h3 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h3><p>这个注解用来创建对象，等同于标签bean，</p><p>属性：value，表示这个对象的名称，是唯一的。也可以省略value，直接写对象名称，必须加引号</p><p>如果不写这个属性，那么spring会使用默认的对象名称：类名的首字母小写，例如类名为Student，那么默认名称为student</p><p>位置：在类的上面</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.point1;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component(value = &quot;myStudent&quot;)</span> <span class="hljs-comment">//指定对象的唯一名称</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="与-Component用法类似的三个注解"><a href="#与-Component用法类似的三个注解" class="headerlink" title="与@Component用法类似的三个注解"></a>与@Component用法类似的三个注解</h3><ol><li>@Repository(用在持久层类上面)：放在DAO的实现类上面，表示创建DAO对象，DAO对象可以访问数据库</li><li>@Service(用在业务层类上面)：放在service的实现类上面，创建service对象，该对象是做业务处理，有事务等功能</li><li>@Controller(用在控制器上面)：放在控制器类上面，创建控制器对象，能够接受用户提交的参数，显示请求处理结果，如Servet</li></ol><p>这三个注解和@Comonent的用法大致相同。都可以创建对象，但是这三个注解还有额外的功能。</p><p>@Repository，@Service，@Controller是用来给项目对象分层的，它们可以赋予对象不同的角色。是比@Component的功能丰富的。</p><p>当一个类不是以上三个类型，或者不知道是不是这三个类，就可以使用@Component</p><h3 id="Value-简单类型的赋值"><a href="#Value-简单类型的赋值" class="headerlink" title="@Value(简单类型的赋值)"></a>@Value(简单类型的赋值)</h3><p>用来给简单类型的属性赋值</p><p>属性：value，String类型，表示简单类型的属性值。可不写value，直接写属性值。必须加引号</p><p>位置： </p><ol><li>在属性定义上面，不需要set方法，推荐使用这种</li><li>在set方法上面</li></ol><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;Jack&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;21&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当然也可以使用在set方法上，用的很少，不再举例了。</p><h3 id="引用类型的赋值"><a href="#引用类型的赋值" class="headerlink" title="引用类型的赋值"></a>引用类型的赋值</h3><p>两个注解@Autowired和@Resource都可以给引用类型赋值。</p><h4 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h4><p>实现引用类型的赋值，使用的是自动注入原理。支持byName、byType</p><p>@Autowired默认使用的是byType自动注入。</p><p>属性：required，布尔类型，默认为true</p><p>​            当required=ture：表示如果引用类型赋值失败，程序报错，并终止执行</p><p>​            当required=false：表示如果引用类型赋值失败，程序正常运行，引用类型为null</p><p><strong>推荐使用true。</strong></p><p>位置：</p><ol><li>在属性定义上面，无需set方法，推荐使用这个</li><li>在set方法上面，很少使用</li></ol><p>例子：</p><p>定义引用类型School：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;mySchool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;清华大学&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;北京海淀区&quot;)</span><br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;School&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, address=&#x27;&quot;</span> + address + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Student的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;Jack&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;21&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-comment">//使用Autowired来进行引用类型注入</span><br>    <span class="hljs-keyword">private</span> School school;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, school=&quot;</span> + school +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用byName方式"><a href="#使用byName方式" class="headerlink" title="使用byName方式"></a>使用byName方式</h5><p>如果要使用byName方式，那么还需要在属性上面加入@Qualifier(value=”bean的id”)：表示使用指定名称的bean完成赋值</p><p>位置</p><p>在上面代码@Autowired的上面或者下面加入<code>@Qualifier(value=&quot;mySchool&quot;)</code>，就可以实现byName方式赋值</p><h4 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h4><p>来自jdk的注解，spring框架提供了对这个注解的功能支持，可以使用它给引用类型赋值</p><p>使用的也是自动注入原理，支持byName、byType，默认使用byName</p><p>属性：name：当使用byName方法时，指定bean的id，<strong>name不能省略</strong>；使用byType方法，不需要这个属性</p><p>位置：</p><ol><li>在属性定义上面，无需set方法，推荐</li><li>在set方法上面</li></ol><p><strong>注意：</strong></p><ul><li><p><strong>如果没有指定name属性，会使用byType；如果指定了name属性，那么使用byName，如果找不到，会报错</strong></p></li><li><p><strong>这个注解在javax包，也就是java的拓展包里，在java 11以后，jdk不再包括javax，所以需要在pom.xml中手动导入。</strong></p></li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;Jack&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@Value(&quot;21&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> School school;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, age=&quot;</span> + age +<br>                <span class="hljs-string">&quot;, school=&quot;</span> + school +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，@Resource没有使用name属性，但是程序可以运行成功，就是因为byName失败后，自动使用byType赋值。</p><p>​    </p><h2 id="配置文件和注解两种方式"><a href="#配置文件和注解两种方式" class="headerlink" title="配置文件和注解两种方式"></a>配置文件和注解两种方式</h2><p>这两种方式都可以使用，但是更多的是使用注解。注解为主，配置文件为辅。</p><p>但是如果修改较多的话，那么就可以使用配置文件。</p><p>如果不需要怎么改变修改的，就可以使用注解。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-配置文件</title>
    <link href="/2022/05/11/Spring/4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2022/05/11/Spring/4-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4-配置文件"></a>4-配置文件</h1><p>在实际项目开发过程中，常使用多个配置文件。</p><p>多个配置文件的优势：</p><ul><li>每个文件的大小比单独一个文件要小很多，读取保存快，效率高</li><li>避免多人协作，竞争带来的冲突。</li></ul><p>配置文件分类有也很多种方式：</p><ul><li><p>按模块分类，一个模块一个配置文件</p></li><li><p>按业务分类，例如数据访问层一个配置文件，服务层一个配置文件</p><p>  . . .</p></li></ul><h2 id="包含关系的多配置文件"><a href="#包含关系的多配置文件" class="headerlink" title="包含关系的多配置文件"></a>包含关系的多配置文件</h2><p>当有多个配置文件时，可以使用一个总的配置文件来把这些配置文件都包含起来。</p><p>例如有student.xml和teacher.xml配置文件，那么可以有一个total.xml文件来把前两个配置文件包含在一起</p><p>语法为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;其他配置文件的路径&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>关键词：”classpath:” 表示类路径，在spring的配置文件中要指定其他文件位置，需要使用classpath，告诉spring去哪里加载读取文件。</p><p>主配置文件中一般不包含bean，它只是用来包含其他配置文件的。</p><p>上面的例子可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;classpath:student.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;classpath:teacher.xml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">import</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当然实际上，其他配置文件会在其他目录里，这里只是演示。</p><p>在使用ClassPathApplicationContext读取这个总配置文件时，就会将包含的两个配置文件一块读取。</p><h3 id="使用通配符"><a href="#使用通配符" class="headerlink" title="使用通配符"></a>使用通配符</h3><p>在包含关系的配置文件中，可以使用通配符(*：表示任意字符)</p><p>例如有两个配置文件：spring-student.xml、spring-teacher.xml</p><p>那么在总配置文件中引入是可以这样写：<br><code>&lt;import resource=&quot;classpath:spring-*.xml&quot; /&gt;</code>，这样就可以将两个配置文件都导入</p><p><strong>注意：</strong></p><ul><li>总的配置文件名称不能包含在通配符的范围里面，否则会造成死循环。例如上面例子，总配置文件不能起名叫spring-*.xml</li><li>要使用通配符匹配的所有配置文件要在一个目录里，不同目录没法匹配</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-基于XML的DI实现</title>
    <link href="/2022/05/11/Spring/3-%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI%E5%AE%9E%E7%8E%B0/"/>
    <url>/2022/05/11/Spring/3-%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="3-基于XML的DI实现"><a href="#3-基于XML的DI实现" class="headerlink" title="3-基于XML的DI实现"></a>3-基于XML的DI实现</h1><p>依赖注入(DI)：表示创建对象后，给对象的属性赋值。</p><p>DI有两种实现方法：</p><ul><li>在spring配置文件中，使用标签和属性完成，叫做基于XML的DI实现。</li><li>使用spring的注解，完成属性赋值，叫做基于注解的DI实现。</li></ul><p>DI的语法分类：</p><ul><li>set注入(设值注入)：spring调用类的set方法，来完成属性赋值</li><li>构造注入：spring调用类的有参数构造器，完成属性赋值。</li></ul><p>先讲基于XML的DI实现。</p><p>创建一个User类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="set注入-设值注入"><a href="#set注入-设值注入" class="headerlink" title="set注入(设值注入)"></a>set注入(设值注入)</h2><p>先来明确一个概念：简单类型。</p><p>Java 的简单类型包括基本数据类型和String。其他的都是引用数据类型。</p><p>使用XML配置文件进行设值注入的语法格式为：</p><p>上面是简单类型赋值，如果类里面包括引用类型，例如User里包括一个定义类Person，变量值为person，应这样定义：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.Person&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.User&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;person&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;person&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>也就是需要在配置文件中，定义一个Person对象，然后使用ref标签来指向这个对象。这个Person对象也可以在定义在User代码后面。</p><p><strong>注意：</strong></p><ul><li><p><strong>如果要使用设值注入，那么属性必须有对应的set方法。并且spring只是调用对应set方法，至于set方法里面语句，spring不关心。</strong></p></li><li><p><strong>只要类里有set方法，那么就可以正常执行。也就是说，即使没有定义成员变量，只要有set方法就可以执行。</strong></p><p>  例如，User中没有定义email变量，但是有<code>public void setEmail(String email)</code>这个set方法，那么在配置文件中也可以正常去调用，不会报错。</p></li><li><p><strong>赋值发生在调用无参数构造器创建对象之后。</strong></p></li></ul><h3 id="bean一些其他属性"><a href="#bean一些其他属性" class="headerlink" title="bean一些其他属性"></a>bean一些其他属性</h3><ul><li>```xml<br>  <bean id="" class="" ><pre><code class="hljs">  &lt;property name=&quot;属性名字&quot; value=&quot;属性的值&quot;&gt;&lt;/property&gt;</code></pre>  &lt;/bean&gt;<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">  <br>    **其中bean标签还有一个属性为scope，它指定这个对象是单例还是多例，值分别为singleton/prototype**<br>  <br>    **当使用单例，那么每次ApplicationContext返回的都是同一个对象；如果使用多例，那么每次返回都是不同对象。**<br>  <br>    **并且，当使用单例，对象在创建IOC容器时创建；使用多例，对象在使用时才创建。**<br><br>- lazy-init属性：它只对singleton的对象有效，默认为<span class="hljs-keyword">false</span>。即在IOC容器创建时创建该对象。如果指定为<span class="hljs-keyword">true</span>，那么该对象会在使用它时才创建出来<br><br>- init-<span class="hljs-keyword">method</span>和destory-<span class="hljs-keyword">method</span>：想要在对象创建之后，执行某个方法，指定init-<span class="hljs-keyword">method</span>属性；<br>  <br>    想要在IOC容器销毁后，执行某个方法，指定destory-<span class="hljs-keyword">method</span>属性<br><br>## 构造注入<br><br>构造注入和设值注入语法差别不大。<br><br>语法为：<br><br>```<span class="hljs-type">xml</span><br>&lt;bean id=&quot;&quot; <span class="hljs-keyword">class</span>=&quot;&quot;&gt;<br>    &lt;constructor-arg <span class="hljs-keyword">index</span>=&quot;&quot; <span class="hljs-type">name</span>=&quot;&quot; <span class="hljs-keyword">value</span>=&quot;&quot;&gt;&lt;/constructor-arg&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure></li></ul><p>参数解释：</p><ul><li>index：表示构造方法参数的位置，从左到右，从0开始计数</li><li>name：构造函数的形参名</li><li>value：如果是简单数据类型，赋值使用value</li><li>ref：如果是引用数据类型，赋值使用ref</li></ul><p>Index和name属性有一个就可以；两个可以都不写，但是标签的顺序需要和构造方法参数的顺序一致。</p><h2 id="引用类型自动注入（对于引用类型赋值的简化）"><a href="#引用类型自动注入（对于引用类型赋值的简化）" class="headerlink" title="引用类型自动注入（对于引用类型赋值的简化）"></a>引用类型自动注入（对于引用类型赋值的简化）</h2><p>在实际开发中，有大量的引用类型，如果每一个赋值都要用<code>&lt;property-name&gt;</code>标签，name代码会又臭又长。</p><p>引用类型的自动注入就是 spring框架可以根据某些规则自动给引用类型赋值，不再需要手动赋值了。</p><p>最常用的规则是byName、byType。</p><ul><li><p>byName(按名称注入)：<strong>Java类中引用类型变量的名称 和 配置文件中<bean>标签的id名称一样，并且数据类型也一致，那么容器中的bean，就可以赋值给引用类型</strong></p><p>   语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span>&gt;</span><br>    简单类型属性赋值<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  其中autowire属性，是指 引用类型按照 名称自动注入。</p><p>  例子：</p><p>  定义User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer id;<br>     <span class="hljs-keyword">private</span> Address address;<span class="hljs-comment">//这个变量名称</span><br><br>     ...<br>&#125;<br></code></pre></td></tr></table></figure><p>  配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.point2.User&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byName&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;21&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;address&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.point2.Address&quot;</span>&gt;</span><span class="hljs-comment">&lt;!--这个id名称--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;addressId&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;addressName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;河北&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  这个例子中，User对象并没有赋值address的语句，但是因为User中定义Address引用类型变量的名称和id=”address”一样，所以会自动赋值给User的address变量。</p><p>  运行过程：spring在读取属性autowire后，知道按名字来注入，会先去User中拿到引用类型的名称address，然后和配置文件中所有bean的id比对，找到id一致的，并且数据类型相同，那么赋值给User的address引用变量。</p></li><li><p>byType(按类型注入)：<strong>Java类引用类型的数据类型和配置文件中bean标签的class属性是同源关系，这样的bean就可以赋值给引用类型</strong></p><p>  同源：</p><ul><li><p>java类中引用类型和bean的class一致</p></li><li><p>java类中引用类型和bean的class是父子类关系</p></li><li><p>java类中引用类型和bean的class是接口和实现类关系</p><p>语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>&gt;</span><br>  简单类型赋值<br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.point2.User&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;21&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Jack&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Myaddress&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.example.point2.Address&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;addressId&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;addressName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;河北&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>可以看出bean的id值并不是address，但是因为是按类型注入，所以也可以实现自动赋值。</p><p><strong>注意：在按类型注入时，bean只能有一个符合条件的，多于一个就会出现错误。</strong></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-IOC</title>
    <link href="/2022/05/11/Spring/2-IOC/"/>
    <url>/2022/05/11/Spring/2-IOC/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="2-IOC"><a href="#2-IOC" class="headerlink" title="2-IOC"></a>2-IOC</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>​        控制反转(IOC)，是一种概念，一种思想。指将传统上由程序代码直接操纵的对象的调用权交给容器，通过容器来实现对象的装配和管理。控制反转指的就是 对对象控制权的转移，从程序代码本身反转到了外部容器。通过容器实现对象的创建、属性赋值、依赖的管理。</p><p>IOC是一种思想，它的实现方法有很多，比较流行的是依赖注入(Dependency Injection) ，也叫DI，应用广泛。</p><p>如何理解IOC(截取知乎上一篇文章的核心部分):</p><blockquote><p>ioc的思想最核⼼的地⽅在于，资源不由使⽤资源的双⽅管理，⽽由不使⽤资源的第三⽅管理，这<br>可以带来很多好处。第⼀，资源集中管理，实现资源的可配置和易管理。第⼆，降低了使⽤资源<br>双⽅的依赖程度，也就是我们说的耦合度。<br>也就是说，甲⽅要达成某种⽬的不需要直接依赖⼄⽅，它只需要达到的⽬的告诉第三⽅机构就可<br>以了，⽐如甲⽅需要⼀双袜⼦，⽽⼄⽅它卖⼀双袜⼦，它要把袜⼦卖出去，并不需要⾃⼰去直接<br>找到⼀个卖家来完成袜⼦的卖出。它也只需要找第三⽅，告诉别⼈我要卖⼀双袜⼦。这下好了，<br>甲⼄双⽅进⾏交易活动，都不需要⾃⼰直接去找卖家，相当于程序内部开放接⼝，卖家由第三⽅<br>作为参数传⼊。甲⼄互相不依赖，⽽且只有在进⾏交易活动的时候，甲才和⼄产⽣联系。反之亦<br>然。这样做什么好处么呢，甲⼄可以在对⽅不真实存在的情况下独⽴存在，⽽且保证不交易时候<br>⽆联系，想交易的时候可以很容易的产⽣联系。甲⼄交易活动不需要双⽅⻅⾯，避免了双⽅的互<br>不信任造成交易失败的问题。因为交易由第三⽅来负责联系，⽽且甲⼄都认为第三⽅可靠。那么<br>交易就能很可靠很灵活的产⽣和进⾏了。这就是ioc的核⼼思想。⽣活中这种例⼦⽐⽐皆是，⽀付<br>宝在整个淘宝体系⾥就是庞⼤的ioc容器，交易双⽅之外的第三⽅，提供可靠性可依赖可灵活变更<br>交易⽅的资源管理中⼼。另外⼈事代理也是，雇佣机构和个⼈之外的第三⽅。<br>=update=<br>在以上的描述中，诞⽣了两个专业词汇，依赖注⼊和控制反转所谓的依赖注⼊，则是，甲⽅开放<br>接⼝，在它需要的时候，能够讲⼄⽅传递进来(注⼊)所谓的控制反转，甲⼄双⽅不相互依赖，交易<br>活动的进⾏不依赖于甲⼄任何⼀⽅，整个活动的进⾏由第三⽅负责管理。</p></blockquote><h3 id="什么是依赖"><a href="#什么是依赖" class="headerlink" title="什么是依赖"></a>什么是依赖</h3><p>classA中有classB的实例，那么在classA中调用classB的方法完成实例，那么classA对classB有依赖。</p><p>依赖注入：是指，在程序运行过程中，若需要调用另一个对象协助时，无须再代码中创建，而是依赖于外部容器，由外部容器创建后传递给程序。</p><p>Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对象之间依赖关系的管理。</p><p>IOC的另一个体现是在使用Servlet时，没有创建过Servlet对象，而是由Tomcat来创建，所以也叫Tomcat容器。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>在spring中，把Java对象叫做bean。</p><p>在使用maven管理项目时，在main目录下，创建resources目录，在该目录下创建spring的配置文件beans.xml。</p><p>在这个配置文件中，配置spring需要创建的类对象。格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>声明bean，就代表告诉spring创建某个类的对象，id是该对象的自定义名称，是唯一值，spring通过id找到这个对象；</p><p>一个bean标签声明一个对象。</p><p><strong>这种设置下，spring创建对象调用的是类的无参数构造器，所以如果要想让spring自动创建某个类的对象，该类必须有无参数构造器。后面会学到，添加标签和属性，spring可以调用有参构造器。</strong></p><p>class是对应类的全限定名称(不能是接口，只能是类)。</p><p>在spring框架中，有一个map，存放创建的对象，key和value分别是id和创建的对象。</p><p>例如有一个org.example.Test类，要让Spring去自动创建它，在配置文件beans.xml中应这样写：</p><p><code>&lt;bean id=&quot;test&quot; class=&quot;org.example.Test&quot; /&gt;</code></p><h2 id="创建容器对象ApplicationContext"><a href="#创建容器对象ApplicationContext" class="headerlink" title="创建容器对象ApplicationContext"></a>创建容器对象ApplicationContext</h2><p>spring帮我们创建好对象后，我们要使用ApplicationContext来获取对象，进行使用，它就表示spring容器。ApplicationContext是一个接口，最常用的实现类是ClassPathXmlApplicationContext，创建该类对象时有一个参数，是配置文件的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;beans.xml&quot;</span>;<br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(config);<br></code></pre></td></tr></table></figure><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201024172618382.png" alt="image-20201024172618382" style="zoom:50%;" /></p><p>这是例子项目的目录结构，beans.xml在resources目录下，在编译后，会在classes目录下，也就是类的根目录，所以变量config直接写”beans.xml”即可。</p><p>在创建ApplicationContext时，读取beans.xml文件时当读取到一个bean标签，就会创建一个对象。</p><p>然后使用该对象的getBean()方法来获取要使用的对象。该方法有多种重载形式，可以使用对象id作为参数来获取对象。并进行类型强制转换。</p><p>这种方法在后面慢慢就不会使用，但刚开始需要这样来获取。</p><h2 id="使用容器对象获取对象信息"><a href="#使用容器对象获取对象信息" class="headerlink" title="使用容器对象获取对象信息"></a>使用容器对象获取对象信息</h2><p>可以使用ApplicationContext的方法来获取对象信息</p><h3 id="获取创建的对象数量"><a href="#获取创建的对象数量" class="headerlink" title="获取创建的对象数量"></a>获取创建的对象数量</h3><p>使用getBeanDefinitionCount()方法来获取，返回值是int类型</p><h3 id="获取创建对象的名称-ID"><a href="#获取创建对象的名称-ID" class="headerlink" title="获取创建对象的名称(ID)"></a>获取创建对象的名称(ID)</h3><p>使用getBeanDefinitionNames()来获取，返回值是String数组</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-Spring简述</title>
    <link href="/2022/05/11/Spring/1-Spring%E7%AE%80%E8%BF%B0/"/>
    <url>/2022/05/11/Spring/1-Spring%E7%AE%80%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-Spring简述"><a href="#1-Spring简述" class="headerlink" title="1-Spring简述"></a>1-Spring简述</h1><p>Spring全家桶有很多东西，包括Spring Boot、Spring Cloud、Spring MVC等等。Spring Framework是最基本的Spring 框架。</p><p>Spring帮助开发人员创建对象、管理对象之间的关系。spring的核心技术IOC、AOP，能实现模块之间，类之间的解耦合。</p><p>简单来说，IOC解决的是 对象管理和对象依赖的问题。</p><p>AOP解决的是 非业务代码抽取的问题。</p><p>Spring分为六大模块：</p><ul><li>Spring Core：核心功能，IOC容器，解决对象创建和依赖关系</li><li>Spring Web：Spring对web模块的支持<ul><li>可以和struts整合，让struts的action创建交给spring</li><li>spring mvc模式</li></ul></li><li>Spring DAO：Spring对JDBC操作对的支持</li><li>Spring ORM：spring对ORM的支持<ul><li>既可以和Hibernate整合</li><li>也可以使用spring的Hibernate操作的封装</li></ul></li><li>Spring AOP：切面编程</li><li>SpringEE：spring对JavaEE其他模块的支持</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>后端</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内置对象</title>
    <link href="/2022/05/11/JavaWeb/JSP/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/05/11/JavaWeb/JSP/%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是内置对象"><a href="#什么是内置对象" class="headerlink" title="什么是内置对象"></a>什么是内置对象</h2><p>JSP引擎在调用JSP对应jspServlet时，会传递或者创建9个与web开发相关的对象供jspServlet使用。</p><p>JSP技术设计者便于开发人员在编写JSP页面时获得这些web对象的引用，定义了9个响应变量，我们通过这些变量就可以快速获得这9大变量的引用。</p><p>9个内置对象：</p><ul><li>pageContext</li><li>page</li><li>config</li><li>request</li><li>response</li><li>session</li><li>application</li><li>exception</li><li>out</li></ul><h2 id="out对象"><a href="#out对象" class="headerlink" title="out对象"></a>out对象</h2><h3 id="out对象API"><a href="#out对象API" class="headerlink" title="out对象API"></a>out对象API</h3><ul><li>int getBufferSize()：得到缓存⼤⼩</li><li>int getRemaining()：得到未使⽤缓存的⼤⼩</li><li>boolean isAutoFlush()</li><li>void println()</li><li>void flush()</li><li>void close()</li><li>void clearBuffer()</li><li>void clear()</li></ul><p>out对象用于向浏览器输出数据，与之对应的是Serblet的PrintWriter对象。然后这个out对象的类型并不是PrintWriter，是JspWriter</p><p>简单理解就是JspWriter就是带缓存的PrintWriter</p><p>out对象的原理为：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200824141612.png" alt="image-20200824141605176"></p><p>只有向out对象中写入了内容。并且满足以下任何一个条件，out对象才会去调用getWriter方法。并且通过该方法返回的PrintWriter对象将out对象的缓冲区中的内容真正写入到Servlet引擎的缓冲区：</p><ul><li>设置page指令的buffer属性关闭了out对象的缓存功能</li><li>out对象的缓冲区满了</li><li>整个JSP页面结束</li></ul><p>一般在JSP页面输出使用表达式&lt;%=%&gt;，所以out对象用的不多</p><h2 id="request对象"><a href="#request对象" class="headerlink" title="request对象"></a>request对象</h2><p>就是HttpServletRequest对象</p><h2 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h2><p>就是HttpServletResponse对象</p><h2 id="config对象"><a href="#config对象" class="headerlink" title="config对象"></a>config对象</h2><p>就是ServletConfig对象</p><h2 id="session对象"><a href="#session对象" class="headerlink" title="session对象"></a>session对象</h2><p>就是Session对象</p><p>注意：在page指令下配置如下代码，session就不可用</p><p>&lt;%@page session=”false” %&gt;</p><h2 id="application对象"><a href="#application对象" class="headerlink" title="application对象"></a>application对象</h2><p>就是ServletContext对象</p><h2 id="page对象"><a href="#page对象" class="headerlink" title="page对象"></a>page对象</h2><p>内置对象page是HttpJspPage对象，page对象代表当前的JSP页面，是当前JSP编译后Servlet类的对象。就是：page对象相当于java类的tihs</p><h2 id="exception对象"><a href="#exception对象" class="headerlink" title="exception对象"></a>exception对象</h2><p>exception是java.lang.Exception类的对象，exception封装了JSP页面抛出的异常信息。exception经常用来处理错误页面。</p><p>一个小例子：模拟空指针错误，打印出现的异常</p><p>1.jsp代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> errorPage=<span class="hljs-string">&quot;error.jsp&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页头&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>我是页头<br>&lt;%<br>    <span class="hljs-comment">//模拟空指针异常</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sss</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    sss.length();<br>%&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>error.jsp代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> isErrorPage=<span class="hljs-string">&quot;true&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;<br>    &lt;%<br>    <span class="hljs-comment">//使用out对象的print方法打印出现的异常</span><br>        out.print(<span class="hljs-string">&quot;程序出现异常，异常为&quot;</span> + exception);<br>    %&gt;<br>&lt;/center&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h2 id="pageContext对象"><a href="#pageContext对象" class="headerlink" title="pageContext对象"></a>pageContext对象</h2><p>pageContext是最重要的一个对象，它代表JSP页面编译后的内容(即JSP页面的运行环境)。</p><h3 id="pageContext获取8个内置对象"><a href="#pageContext获取8个内置对象" class="headerlink" title="pageContext获取8个内置对象"></a>pageContext获取8个内置对象</h3><p>通过pageContext可以获取到其他八个内置对象</p><p>直接使用pageContext提供的方法即可获取</p><h3 id="pageContext作为域对象"><a href="#pageContext作为域对象" class="headerlink" title="pageContext作为域对象"></a>pageContext作为域对象</h3><p>类似request,session,ServletContext 作为域对象而言，都有一下三个方法：</p><ul><li>setAttribute(String name, Object o)</li><li>getAttribute(String name)</li><li>removeAttribute(String name)</li></ul><p>所以，pageContext也同样有这三种方法。</p><ul><li>pageContext本质代表的就是当前JSP页面编译后的内容，作为域对象而言，它就代表当前JSP页面，也就是page。也就是说：pageContext域对象只在page范围内有效，超出page范围就无效了。</li></ul><p>pageContext本质代表编译后JSP后的内容。pageContext还封装了访问其他域的方法，</p><ul><li><p>上面pageContext默认是page范围的，但是pageContext对象重载了set，get和remove这三个方法。</p><ul><li>setAttribute(String name, Object value, int scope)</li><li>getAttribute(String name, int scope)</li><li><p>removeAttribute(String name, int scope)</p><p>多了一个设置域范围的一个参数，如果不指定默认是page，当然，pageContext把request，session，application，page这几个域对象封装了静态变量供使用。</p></li><li><p>PageContext.APPLICATION_SCOPE</p></li><li>PageContext.SESSION_SCOPE</li><li>PageContext.REQUEST_SCOPE</li><li><p>PageContext.PAGE_SCOPE</p><p>没有使用这些重载方法时，PageContext是不能获取到request域对象的属性的。</p></li></ul></li></ul><p>例子：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs jsp"><span class="hljs-comment">//1.jsp代码</span><br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页头&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>我是页头<br>&lt;%<br>    <span class="hljs-comment">//设置属性</span><br>    request.setAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;Hello World&quot;</span>);<br>%&gt;<br>&lt;jsp:forward page=<span class="hljs-string">&quot;2.jsp&quot;</span>&gt;&lt;/jsp:forward&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br><br><span class="hljs-comment">//2.jsp代码</span><br><br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页尾&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;%<br>        request.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>    <span class="hljs-comment">//使用重载方法获取request设置的属性</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) pageContext.getAttribute(<span class="hljs-string">&quot;name&quot;</span>, PageContext.REQUEST_SCOPE);<br>    %&gt;<br>获取到的参数为:&lt;%=name%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><ul><li><p>PageContext还有一个方法：findAttribute(String name)</p><p>  该方法会查找各个域的属性，从小到大开始寻找，也就是page-&gt;request-&gt;session-&gt;application</p></li></ul><h3 id="引入和跳转"><a href="#引入和跳转" class="headerlink" title="引入和跳转"></a>引入和跳转</h3><p>PageContext类定义了一个forward和两个include方法分别简化和代替RequestDispatcher.forward方法和include方法</p><ul><li>pageContext.forward(String url)</li><li>pageContext.include(String url)</li></ul><h2 id="四种属性范围"><a href="#四种属性范围" class="headerlink" title="　四种属性范围"></a>　四种属性范围</h2><p>目前为止，有４种属性范围。</p><ul><li>page：只在一个页面中保存属性，跳转页面无效</li><li>request：在一次请求中保存属性，服务器跳转有效，浏览器跳转无效</li><li>session：在一次会话范围中保存属性，无论何种跳转均有效，关闭浏览器后无效</li><li>application：在整个服务器中保存，所有用户都可以使用</li></ul><p>四个内置对象都支持一下方法：</p><ul><li>setAttribute(String name, Object o)</li><li>getAttribute(String name)</li><li>removeAttribute(String name)</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol><li>request：如果客户向服务器发请求，产生数据，用户看完后没用了，那么这种数据就可以存在request域。</li><li>session：如果客户向服务器发请求，产生数据，用户用完等一会还有用，这种数据就存在session域中</li><li>servletContext：如果客户向服务器发请求，产生数据，用户用完，其他用户还要用，就存在servletContext域中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>JSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>EL表达式</title>
    <link href="/2022/05/11/JavaWeb/JSP/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2022/05/11/JavaWeb/JSP/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是EL表达式"><a href="#什么是EL表达式" class="headerlink" title="什么是EL表达式"></a>什么是EL表达式</h2><p>表达式语言(Expression Language, EL) ,EL表达式是用”${}” 括起来的脚本，用来更方便的读取对象。EL表达式主要用来读取数据，进行内容显示。</p><h2 id="为什么使用EL-表达式"><a href="#为什么使用EL-表达式" class="headerlink" title="为什么使用EL 表达式"></a>为什么使用EL 表达式</h2><p>使用EL表达式，可以更简洁的读取对象中的属性，提交的参数、JavaBean、甚至集合。</p><p>例如在1.jsp中session设置了一个名为 name的属性</p><p>那么在2.jsp中间可以使用 <code>$&#123;name&#125;</code>来读取该参数。</p><h2 id="EL表达式作用"><a href="#EL表达式作用" class="headerlink" title="EL表达式作用"></a>EL表达式作用</h2><p>首先EL表达式语法为：</p><p>${标识符}</p><p><strong>EL表达式如果找不到相应的对象属性，返回的是一个空白字符串””,而不是null，这是EL表达式最大的特点。</strong></p><h3 id="获取各类数据"><a href="#获取各类数据" class="headerlink" title="获取各类数据"></a>获取各类数据</h3><h4 id="获取域对象数据"><a href="#获取域对象数据" class="headerlink" title="获取域对象数据"></a>获取域对象数据</h4><p>在1.jsp中设置ServletContext属性(就是application)</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br><span class="hljs-comment">//向ServletContext设置⼀个属性</span><br>application.setAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;向application设置了⼀个属性&quot;</span>);<br>%&gt;<br></code></pre></td></tr></table></figure><p>在2.jsp中获取该属性</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%<br>$&#123;name&#125;<br>%&gt;<br></code></pre></td></tr></table></figure><p>之前讲ServletContext对象时讲过一个方法findAttribute(String name)，EL表达式语句执行时会调用该方法，用标识符作为关键词分别从page、request、session、application四个域中查找相应对象。</p><p>查找顺序就是从小到大，上图所写顺序。</p><h4 id="获取JavaBean的属性"><a href="#获取JavaBean的属性" class="headerlink" title="获取JavaBean的属性"></a>获取JavaBean的属性</h4><p>之前在JSP页面获取JavaBean属性需要先获取该对象，然后再访问该对象属性。使用EL表达式就很简单。</p><p>例如在1.jsp中定义了一个person对象，那么在2.jsp中直接使用<code>$&#123;person.age&#125;</code>就可以访问person的age属性。</p><h2 id="获取集合数据"><a href="#获取集合数据" class="headerlink" title="获取集合数据"></a>获取集合数据</h2><p>EL表达式可以方便读取Collection和Map集合的内容。</p><p>例如，在1.jsp中设置session的属性，session属性的值为List集合，List集合装载Person对象</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> errorPage=<span class="hljs-string">&quot;error.jsp&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页头&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;%<br>    List&lt;Person&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person1.setUserName(<span class="hljs-string">&quot;mike&quot;</span>);<br>    person1.setAge(<span class="hljs-number">25</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person2.setUserName(<span class="hljs-string">&quot;smith&quot;</span>);<br>    person2.setAge(<span class="hljs-number">55</span>);<br>    list.add(person1);<br>    list.add(person2);<br>    session.setAttribute(<span class="hljs-string">&quot;list&quot;</span>, list);<br>%&gt;<br>&lt;jsp:forward page=<span class="hljs-string">&quot;2.jsp&quot;</span>/&gt;&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>在2.jsp中使用EL表达式，读取list集合内容</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页尾&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;%--取出person对象的属性--%&gt;<br>对象person1的用户名为：$&#123;list[<span class="hljs-number">0</span>].userName&#125;,年龄为：$&#123;list[<span class="hljs-number">0</span>].age&#125;&lt;br&gt;<br>对象person2的用户名为：$&#123;list[<span class="hljs-number">1</span>].userName&#125;,年龄为：$&#123;list[<span class="hljs-number">1</span>].age&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>再使用Map集合</p><p>在1.jsp中session属性存储了Map集合，Map集合的关键词是字符串，值是Person对象</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> errorPage=<span class="hljs-string">&quot;error.jsp&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页头&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;%<br>    Map&lt;String,Person&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person1.setUserName(<span class="hljs-string">&quot;mike&quot;</span>);<br>    person1.setAge(<span class="hljs-number">18</span>);<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person2.setUserName(<span class="hljs-string">&quot;smith&quot;</span>);<br>    person2.setAge(<span class="hljs-number">78</span>);<br>    map.put(<span class="hljs-string">&quot;aa&quot;</span>, person1);<br>    map.put(<span class="hljs-string">&quot;bb&quot;</span>, person2);<br>    session.setAttribute(<span class="hljs-string">&quot;map&quot;</span>, map);<br>%&gt;<br>&lt;jsp:forward page=<span class="hljs-string">&quot;2.jsp&quot;</span>/&gt;&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>在2.jsp中进行读取</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页尾&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>对象person1的用户名为：$&#123;map.aa.userName&#125;,年龄为：$&#123;map.aa.age&#125;&lt;br&gt;<br>对象person2的用户名为：$&#123;map.bb.userName&#125;,年龄为：$&#123;map.bb.age&#125;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>如果Map集合存储键值不是字符串，而是一个数字，就不能使用”.”号运算符了，可以这样：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">$&#123;map[<span class="hljs-string">&quot;1&quot;</span>].userName&#125;<br>$&#123;map[<span class="hljs-string">&quot;2&quot;</span>].userName&#125;<br></code></pre></td></tr></table></figure><h2 id="EL运算符"><a href="#EL运算符" class="headerlink" title="EL运算符"></a>EL运算符</h2><p>EL表达式支持简单运算符：加减乘除取模，逻辑运算符，empty运算符(判断是否为null)和三目运算符</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200908100149.png" alt="image-20200908093738083"></p><h2 id="EL表达式11个内置对象"><a href="#EL表达式11个内置对象" class="headerlink" title="EL表达式11个内置对象"></a>EL表达式11个内置对象</h2><p>EL表达式主要用来对内容显示，为了显示方便，EL表达式提供了11个内置对象。</p><ol><li>pageContext：对应JSP页面的pageContext对象</li><li>pageScope：代表page域中保存属性的Map对象</li><li>requestScope：代表request域中保存属性的Map对象</li><li>sessionScope：代表session域中保存属性的Map对象</li><li>applicationScope：代表application域中保存属性的Map对象</li><li>param：表示一个保存了所有请求参数的Map对象</li><li>paramValues表示了一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[]</li><li>header：表示一个保存了所有http请求头字段的Map对象</li><li>headValues：同上，返回string[]数组</li><li>cookie：表示一个保存了所有cookie的Map对象</li><li>initParam：表示一个保存了一个所有web应用初始化参数的map对象</li></ol><p>注意事项：</p><ul><li>测试headerValues时，如果头里面有“-”，例如Accept-Encoding，则要headValues[“Accept-Encoding”]</li><li>测试cookie时，例如<code>$&#123;cookie.key&#125;</code>取的是cooike对象，如果要访问cookie的名称和值，需要<code>$&#123;cookie.key.name&#125;</code>或者${cookie.key.value}</li><li>测试initParam时，初始化参数要的web.xml中的配置Context的，仅仅是jsp的参数是获取不到的</li><li>对于param和paramValues内置对象一般都是别的页面带数据来的，如表单、地址栏。</li></ul><h2 id="EL表达式回显数据"><a href="#EL表达式回显数据" class="headerlink" title="EL表达式回显数据"></a>EL表达式回显数据</h2><p>EL表达式最大特点就是如果获取到的数据为null，输出空白字符串””,这个特点可以让我们数据回显。</p><p>在1.jsp中模拟一下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> errorPage=<span class="hljs-string">&quot;error.jsp&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页头&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br><br>&lt;%<br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>    person.setUserName(<span class="hljs-string">&quot;male&quot;</span>);<br>    <span class="hljs-comment">//回显数据</span><br>    request.setAttribute(<span class="hljs-string">&quot;person&quot;</span>, person);<br>%&gt;<br>&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;sex&quot;</span> value=<span class="hljs-string">&quot;male&quot;</span> $&#123;person.userName==<span class="hljs-string">&#x27;male&#x27;</span> ? <span class="hljs-string">&#x27;checked&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>&#125;&gt;女<br>&lt;input type=<span class="hljs-string">&quot;radio&quot;</span> name=<span class="hljs-string">&quot;sex&quot;</span> value=<span class="hljs-string">&quot;female&quot;</span> $&#123;person.userName==<span class="hljs-string">&#x27;female&#x27;</span> ? <span class="hljs-string">&#x27;checked&#x27;</span> : <span class="hljs-string">&#x27;&#x27;</span>&#125;&gt;男<br><br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>JSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaBean</title>
    <link href="/2022/05/11/JavaWeb/JSP/JavaBean/"/>
    <url>/2022/05/11/JavaWeb/JSP/JavaBean/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是JavaBean"><a href="#什么是JavaBean" class="headerlink" title="什么是JavaBean"></a>什么是JavaBean</h2><p>JavaBean就是普通的java类，也称为简单java对象，是Java程序设计中一种设计模式，是一种基于java平台的软件组件思想</p><p>JavaBean遵循特定写法，通常有如下规则：</p><ul><li>有无参的构造函数</li><li>成员属性私有化</li><li>封装的属性如果需要被外所操作，必须编写public类型的setter，getter方法</li></ul><p>JavaBean实际非常简单。下面就是按照规则编写的一个JavaBean对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">private</span> String username ;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> username;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;<br><span class="hljs-built_in">this</span>.username = username;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="为什么需要使用JavaBean"><a href="#为什么需要使用JavaBean" class="headerlink" title="为什么需要使用JavaBean"></a>为什么需要使用JavaBean</h2><p>简单来说就是：封装，重写，可读！</p><p>引用一段回答：</p><p> JaveBean你可以理解为⼀辆货⻋，在你的java端和web⻚⾯进⾏数据传递的载体，你当然可以每<br>个变量单独传递，或者使⽤集合传递，但是javabean可以使你的数据更有可读性，⽅便开发时明<br>确变量的意义，也使其他阅读你代码的⼈能直接你的意图。</p><p>如果把bean类和数据库联合使用，那么可以一张表使用一个bean类，使代码更加简洁高效，易于理解。现在大多数框架都会使用这种机制。</p><h2 id="JSP行为-JavaBean"><a href="#JSP行为-JavaBean" class="headerlink" title="JSP行为-JavaBean"></a>JSP行为-JavaBean</h2><p>JSP技术提供了三个关于JavaBean组件的动作元素，即JSP行为(标签)，分别为：</p><ul><li>jsp:useBean：在JSP页面中查找JavaBean对象或者实例化JavaBean对象</li><li>jsp:setProperty：设置JavaBean属性</li><li>jsp:getProperty：获取JavaBean属性</li></ul><h3 id="jsp-useBean"><a href="#jsp-useBean" class="headerlink" title="　jsp:useBean"></a>　jsp:useBean</h3><p><jsp:useBean> 标签用于在指定域范围内查找指定名称的JavaBean对象</p><ul><li>存在则直接返回该JavaBean对象的引用</li><li>不存在则实例化一个新的JavaBean对象并将它以指定名称存储到指定域范围中。</li></ul><p>语法：</p><jsp:useBean id="实例化对象的名称" class="类的全名" scope=“保存范围” /><p>如果JSP不支持这个行为，那么要使用Persion类是这样：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--这⾥需要导⼊Person类--%&gt;<br>&lt;%@ page <span class="hljs-keyword">import</span>=<span class="hljs-string">&quot;domain.Person&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;%<br><span class="hljs-comment">//new出对象</span><br><span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person.setName(<span class="hljs-string">&quot;zhongfucheng&quot;</span>);<br>System.out.println(person.getName());<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>我们使用jsp:useBean就非常简洁，不需要导包，不用new对象</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;jsp:useBean id=<span class="hljs-string">&quot;person&quot;</span> class=<span class="hljs-string">&quot;domain.Person&quot;</span> scope=<span class="hljs-string">&quot;page&quot;</span>/&gt;<br>&lt;%<br>person.setName(<span class="hljs-string">&quot;zhongfucheng&quot;</span>);<br>System.out.println(person.getName());<br>%&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>要想使用这个行为，对应类必须有无参的构造函数，因为在内部中new对象时是没有传递参数的。</p><h3 id="jsp-setProperty"><a href="#jsp-setProperty" class="headerlink" title="jsp:setProperty"></a>jsp:setProperty</h3><p>语法：</p><jsp:setProerty name="对象名称" property="属性名" param="参数名" value="值"><p>语法上分为四种模式：</p><ul><li><jsp:setProperty name="对象名称 "  property="*" /> ：自动匹配</li><li><jsp:setProperty name="对象名称 "  property="属性名称" />：指定属性</li><li><jsp:setProperty name="对象名称 "  property="属性名称" param="参数名称" />：指定参数(很少用)</li><li><jsp:setProperty name="对象名称 "  property="属性名称" param="参数名称"  value="内容"/>：指定内容(很少用)</li></ul><p>例子：</p><p>例如表单代码为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/zhongfucheng/1.jsp&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>⽤户名：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>年龄：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text &quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>处理表单提交过来数据的jsp代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;person&quot;</span> class=<span class="hljs-string">&quot;domain.Person&quot;</span> scope=<span class="hljs-string">&quot;page&quot;</span>/&gt;<br>&lt;%<br><span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> Integer.parseInt(request.getParameter(<span class="hljs-string">&quot;age&quot;</span>));<br>person.setAge(age);<br>System.out.println(person.getAge());<br>%&gt;<br></code></pre></td></tr></table></figure><p>这样可以完成，表单提交过来的数据填充到person对象中，但是比较麻烦。</p><p>使用jsp:setProperty：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;person&quot;</span> class=<span class="hljs-string">&quot;domain.Person&quot;</span> scope=<span class="hljs-string">&quot;page&quot;</span>/&gt;<br>&lt;%--指定属性名称为age--%&gt;<br>&lt;jsp:setProperty name=<span class="hljs-string">&quot;person&quot;</span> property=<span class="hljs-string">&quot;age&quot;</span>/&gt;<br>&lt;%<br>System.out.println(person.getAge());<br>%&gt;<br></code></pre></td></tr></table></figure><p>也可以完成，并且代码更少。<strong>无需去指定属性，它会去自动进行匹配。但是需要Persion的属性名称和表单的name属性名称是一模一样的。就可以自动完成匹配。</strong></p><p>再来一个：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:useBean id=<span class="hljs-string">&quot;person&quot;</span> class=<span class="hljs-string">&quot;domain.Person&quot;</span> scope=<span class="hljs-string">&quot;page&quot;</span>/&gt;<br>&lt;%--property的值设置为*就代表⾃动匹配--%&gt;<br>&lt;jsp:setProperty name=<span class="hljs-string">&quot;person&quot;</span> property=<span class="hljs-string">&quot;*&quot;</span>/&gt;<br>&lt;%<br>System.out.println(person.getAge());<br>System.out.println(person.getName());<br>%&gt;<br></code></pre></td></tr></table></figure><p>只要在设置property的值为*，就可自动匹配。</p><p>我们不需要进行类型转换，内部会自动帮我们进行转换。</p><h3 id="jsp-getProperty"><a href="#jsp-getProperty" class="headerlink" title="jsp:getProperty"></a>jsp:getProperty</h3><p>语法：</p><jsp:getProperty name="对象名" property="属性名" /><p>该jsp行为很简单，直接使用该行为输出就可以</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%--使⽤&lt;jsp:getProperty&gt;输出--%&gt;<br>&lt;jsp:getProperty name=<span class="hljs-string">&quot;person&quot;</span> property=<span class="hljs-string">&quot;username&quot;</span>/&gt;<br>&lt;jsp:getProperty name=<span class="hljs-string">&quot;person&quot;</span> property=<span class="hljs-string">&quot;age&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>JSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSP入门</title>
    <link href="/2022/05/11/JavaWeb/JSP/JSP%E5%85%A5%E9%97%A8/"/>
    <url>/2022/05/11/JavaWeb/JSP/JSP%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JSP全称为Java Server Pages，java服务器页面，特点是HTML代码和Java代码共同存在。</p><h2 id="为什么需要JSP"><a href="#为什么需要JSP" class="headerlink" title="为什么需要JSP"></a>为什么需要JSP</h2><p>Servlet输出HTML比较麻烦，代码量比较多，很不方便，JSP就是替代Servlet输出HTML的。</p><h2 id="JSP工作原理"><a href="#JSP工作原理" class="headerlink" title="JSP工作原理"></a>JSP工作原理</h2><p>Tomcat访问任何资源其实都是在访问Servlet，JSP也不例外。JSP本身就是一种Servlet，为什么呢？其实JSP在第一次被访问时会被编译成HttpJspPages类，是HttpServlet的一个子类。</p><p>编译过程是：浏览器第一次请求jsp文件时，Tomcat会将jsp文件转换为java一个类，然后编译为class文件，然后再运行class文件来响应浏览器请求。</p><p>以后在访问该jsp文件就不会重新编译了，直接调用class文件，如果tomcat检测出jsp页面改动的话，就会重新编译。</p><p>JSP是一个Servlet，那么jsp页面中html是如何发送到浏览器的呢》其实就是使用write方法发送的。所以JSP就是封装了Servlet的java程序而已。</p><p>那么JSP的代码服务器是怎么执行的呢？HttpJspPages类中有一个方法叫_jspService()，由jsp转换的java代码就在该方法中。</p><p>JSP之所以比Servlet更方便简单的一个原因是：JSP内置了9个对象：out、session、response、request、config、page、application、pageContext、exception。</p><h2 id="JSP生命周期"><a href="#JSP生命周期" class="headerlink" title="JSP生命周期"></a>JSP生命周期</h2><p>JSP也是一个Servlet，运行时也只有一个实例，JSP初始化和销毁时会调用Servlet的init和destroy方法。另外，JSP还有自己初始化和销毁的方法。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200821142742.png" alt="image-20200821142735578"></p><h2 id="JSP基本语法"><a href="#JSP基本语法" class="headerlink" title="JSP基本语法"></a>JSP基本语法</h2><p>JSP代码分为两部分：</p><ul><li>HTML代码</li><li>元素：JSP页面中的java代码、JSP指令、JSP标签</li></ul><h3 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h3><p>JSP脚本就是java代码，也叫做scriptlet。JSP的脚本必须使用&lt;%%&gt;括起来，不然JSP文件无法识别。</p><p>JSP脚本有三种方式：</p><ul><li>&lt;%%&gt;：定义局部变量，编写语句</li><li>&lt;%!%&gt;：定义类或方法，<strong>但是没有人这样用</strong></li><li>&lt;%=%&gt;：表达式输出输出各种类型变量，例如&lt;%=num1%&gt;，就是输出num1变量</li></ul><h3 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h3><p>JSP指令用来声明JSP页面相关属性，例如编码方式，文档类型等。</p><p>JSP指令的语法格式为：</p><p>&lt;%@ 指令 属性=”值” %&gt;</p><p>例如，page指令常见的属性：</p><ul><li>language=”java”</li><li>extends=”package.class”</li><li>import=”{package.class | package.*},…”</li><li>session=”true | false”</li><li>buffer=”none | 8kb | size kb”</li><li>autoFlush=”true | false”</li><li>info=”text”</li><li>errorPage=”relatice_url”</li><li>isErrorPage=”true ｜false”</li><li>contentPage=”mineType; charset=charracterSet” | “text/html”;charset=ISO-8859-1”</li><li>pageEncoding=”characterSet  | ISO-8859-1”</li><li>isELIgnored=”true | false”</li></ul><p>一般在高级开发工具上例如IDEA开发，只需要在page指令中指定contentType=”text/html;charset=utf-8”,就不会出现中文乱码问题。当然contentType不仅可以指定以text/html方式显示出来，还可以使用其他形式。</p><p>使用errorPage属性可以指定如果当前页面出错，要跳转到哪个页面，isErrorPage指定该页面是否为要跳转的错误页面。例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;!--index.jsp代码--&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> errorPage=<span class="hljs-string">&quot;error.jsp&quot;</span> %&gt;&lt;!--指定出错后，跳转到error页面--&gt;<br>&lt;%<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> / <span class="hljs-number">0</span>;<span class="hljs-comment">//这是出错位置</span><br>%&gt;<br>变量num3的值为：&lt;%=result%&gt;&lt;br&gt;<br><br>&lt;!--error.jsp代码--&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> isErrorPage=<span class="hljs-string">&quot;true&quot;</span> %&gt;&lt;!--指定该页面为错误页面--&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;center&gt;<br>        &lt;font style=<span class="hljs-string">&quot;color: red; font-size: 40px&quot;</span>&gt;您访问的页面出错啦出错啦～～～&lt;/font&gt;<br>    &lt;/center&gt;<br><br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>执行结果为：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200821150012.png" alt="image-20200821150012375"></p><p>但是发现，地址栏并没有改变，说明这次跳转是在服务器内发生的。</p><p>但是，这样一个一个jsp去设置错误页面太麻烦了，我们可以在web.xml文件中去指定全局错误页，无论哪个jsp发生错误，都会转到该页。</p><p>代码为：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;error-page&gt;&lt;!--这个错误页面标签指定当发生<span class="hljs-number">404</span>错误代码时，跳转到error.jsp页面--&gt;<br>&lt;error-code&gt;<span class="hljs-number">404</span>&lt;/error-code&gt;<br>&lt;location&gt;/error.jsp&lt;/location&gt;<br>&lt;/error-page&gt;<br><br>&lt;error-page&gt;&lt;!--这个错误页面标签指定当发生空指针异常时，跳转到error.jsp页面--&gt;<br>&lt;exception-type&gt;java.lang.NullPointerException&lt;/exception-type&gt;<br>&lt;location&gt;/error.jsp&lt;/location&gt;<br>&lt;/error-page&gt;<br></code></pre></td></tr></table></figure><h4 id="将HTML代码和Java代码混合使用"><a href="#将HTML代码和Java代码混合使用" class="headerlink" title="将HTML代码和Java代码混合使用"></a>将HTML代码和Java代码混合使用</h4><p>例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;%<br>    <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>;<br>%&gt;<br><br>&lt;%<br>    <span class="hljs-keyword">if</span>(age &gt;= <span class="hljs-number">15</span>) &#123;<br>%&gt;<br>&lt;font style=<span class="hljs-string">&quot;color:red; font-size: 40px&quot;</span>&gt;欢迎光临&lt;/font&gt;<br>&lt;%<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>%&gt;<br>&lt;font style=<span class="hljs-string">&quot;color:red; font-size: 40px&quot;</span>&gt;谢绝入内&lt;/font&gt;<br>&lt;%<br>    &#125;<br>%&gt;<br></code></pre></td></tr></table></figure><p>多个&lt;%%&gt;可以看成是一个&lt;%%&gt;标签，使用if else语句来进行选择输出。</p><p>再例如使用for循环：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;%<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;afgdhshsg&quot;</span>;<br>%&gt;<br><br>&lt;%<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>%&gt;<br>    &lt;h1&gt;&lt;%=s.charAt(i)%&gt;&lt;/h1&gt;<br>&lt;%<br>    &#125;<br>%&gt;<br></code></pre></td></tr></table></figure><h4 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h4><p>在学request对象时，曾经使用request.getRequestDispatcher(String url).include(request, response)来对页头和页尾进行包括。</p><p>include指令也是相同的作用。</p><p>include指令是静态包含，意思就是：比文件的代码内容都包含进来，再进行编译。</p><p>例如：</p><p>1.jsp文件和2.jsp文件分别为：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;!--<span class="hljs-number">1.</span>jsp--&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页头&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>我是页头<br>&lt;/body&gt;<br>&lt;/html&gt;<br><br>&lt;!--<span class="hljs-number">2.</span>jsp--&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;我是页尾&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>我是页尾<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>然后index.jsp为：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>    &lt;body&gt;<br>        &lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">&quot;1.jsp&quot;</span>%&gt;<br>        &lt;%<span class="hljs-meta">@include</span> file=<span class="hljs-string">&quot;2.jsp&quot;</span>%&gt;<br>    &lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>输出内容为前两个文件的内容。</p><h4 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h4><p>JSP支持标签技术，要使用标签技术就要先声明标签库和标签前缀，taglib指令就是用来指明JSP页面内使用标签库技术。</p><p>后面再细说。</p><h3 id="JSP行为"><a href="#JSP行为" class="headerlink" title="　JSP行为"></a>　JSP行为</h3><p>JSP行为是一组内置的标签，只需要书写少量标记代码就能够使用JSP提供的丰富功能。JSP行为是对常用的JSP功能的抽象和封装。</p><p>这些其实就是标签。但之所以把这些内置标签称为行为，是因为要把JSTL标签区分开。当然，也可以直接把它称之为JSP标签。</p><h4 id="include行为"><a href="#include行为" class="headerlink" title="include行为"></a>include行为</h4><p>刚才说了，include指令是静态包含，include行为是动态包含。include行为就是封装了request.getRequestDispatcher(String url).include(request, response)</p><p>include行为语法格式为：<jsp:include page="" /></p><p>现在有静态包含和动态包含，但是推荐使用动态包含。</p><p>原因是：动态包含可以向被包含的页面传递参数（但是用处不大），并且分别处理包含页面(就是先将包含页面编译再写入)，如果有相同名称的参数，使用静态包含就会报错(因为静态包含是先写入再编译)，使用动态包含就不会出错。</p><h4 id="param行为"><a href="#param行为" class="headerlink" title="param行为"></a>param行为</h4><p>当使用jsp:include和jsp:forward行为引入或请求转发其他资源时，可以使用jsp:param行为向这个资源传递参数</p><h4 id="forward行为"><a href="#forward行为" class="headerlink" title="forward行为"></a>forward行为</h4><p>学习request对象时，使用request.getRequestDispatcher(String url).forward(request, response)进行跳转，forward行为就是对其进行封装。</p><p>语法为：</p><jsp:forward page="" /><p>如果要传递参数，就需要在forward行为嵌套param行为</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;jsp:forward page=<span class="hljs-string">&quot;2.jsp&quot;</span>&gt;<br>    &lt;jsp:param name=<span class="hljs-string">&quot;username&quot;</span> value=<span class="hljs-string">&quot;hhhh&quot;</span> /&gt;<br>&lt;/jsp:forward&gt;    <br></code></pre></td></tr></table></figure><p>在2.jsp页面中获取到传递的参数</p><p>&lt;%</p><p>​        String ss = request.getParameter(“username”);</p><p>%&gt;</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>JSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ajax</title>
    <link href="/2022/05/11/JavaWeb/AJAX/1-Ajax%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/05/11/JavaWeb/AJAX/1-Ajax%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Ajax是用来做局部刷新的，即在不重新加载刷新整个页面的同时，只更新页面的一部分数据。局部刷新使用的核心对象是异步对象：XMLHttpRequest，这个异步对象是存在在浏览器的内存中的。使用JS语法来创建该对象。</p><h2 id="AJAX异步实现步骤"><a href="#AJAX异步实现步骤" class="headerlink" title="AJAX异步实现步骤"></a>AJAX异步实现步骤</h2><ol><li><p>创建对象方式</p><p> <code>var xmlHttp = new XMLHttpRequest();</code></p></li><li><p>给异步对象绑定事件：onreadystatechange</p><p> 当异步对象发起了请求，获取了数据都会触发这个事件，这个事件指定一个函数，处理状态的变化。</p><p> <code>xmlHttp.onreadystatechange=function()&#123;&#125;</code></p></li><li><p>初始化异步请求对象</p><p> 异步对象有一个open方法，<code>xmlHttp.open(请求方式 get |post, 访问地址，同步|异步请求(默认为true，即异步))</code></p><p> 例如<code>xmlHttp.open(&quot;get&quot;, &quot;loginServlet?name=zxpwd=123&quot;, true);</code></p></li><li><p>使用异步对象发送请求</p><p> xmlHttp.send(str)：当用POST方式发请求会使用str参数</p></li><li><p>获取服务端返回的数据，使用异步对象的属性：responseText</p></li></ol><p>XMLHttpRequest有三个重要属性：</p><ol><li>onreadystatechange属性：一个函数，每当readyState属性改变时，会调用该函数</li><li>readyState属性：表示XMLHttpRequest请求的状态，从0到4发生变化<ul><li>0：请求未初始化，创建异步请求对象</li><li>1：初始化异步请求对象，xmlHttp.open(请求方式，请求地址，true)</li><li>2：异步对象发送请求，xmlHttp.send()</li><li>3：异步对象介绍应答数据，从服务器端返回数据，XMLHttpRequest内部处理</li><li>4：异步对象已经将数据解析完毕，此时才可读取数据</li></ul></li><li>status属性：<ul><li>200：‘OK’</li><li>404：未找到页面</li></ul></li></ol><p><strong>注意：open函数的URL请求的地址是不加/的servlet名称，例如Servlet1的url-pattern为/one，则参数填one即可</strong></p><p><strong>注意：如果使用POST请求向服务端传参数，那么必须设置RequestHeader，为httpRequest.setRequestHeader(“Content-type”, “application/x-www-form-urlencoded”);，如果没有，那么后台就无法获取参数，并且设置请求头要在open函数执行完后</strong></p><p><strong>注意：open方法的最后一个参数，true代表异步请求：即使用异步对象发起请求后，不需要等待数据的返回，即可进行其他操作</strong></p><h2 id="使用JSON格式传递数据"><a href="#使用JSON格式传递数据" class="headerlink" title="使用JSON格式传递数据"></a>使用JSON格式传递数据</h2><p>有四种处理JSON的工具库，分别为Gson(Google的)，fastjson(阿里巴巴的)，Jackson，还有一个忘了。</p><p>我用的是jackson。</p><p>首先将jackson的jar导入项目依赖。</p><h3 id="将Java对象转换为Json格式的字符串"><a href="#将Java对象转换为Json格式的字符串" class="headerlink" title="将Java对象转换为Json格式的字符串"></a>将Java对象转换为Json格式的字符串</h3><ol><li>创建ObjectMapper对象：<code>ObjectMapper om = new ObjectMapper()</code></li><li>使用该对象的  String writeValueAsString(Object value)方法将Java对象转换为json格式的字符串，Java对象的对应变量名称为json中的key，实际值就为json格式的value</li><li>设置响应头的Content-type为“application/json;charset=utf-8”</li><li>然后使用响应头的PrintWriter将该字符串写入</li></ol><h3 id="在js中解析该字符串"><a href="#在js中解析该字符串" class="headerlink" title="在js中解析该字符串"></a>在js中解析该字符串</h3><p>使用js中JSON的prase解析该字符串，返回一个json对象，使用 . 运算符 后面跟json的name即可访问对应value</p><p>或使用js的eval函数，前后分别加”(“和”)”，例如 var jsonObj = eval(“()” + json + “)”);，返回一个json对象</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>AJAX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-JQuery使用Ajax</title>
    <link href="/2022/05/11/JavaWeb/JQuery/5-JQuery%E4%BD%BF%E7%94%A8Ajax/"/>
    <url>/2022/05/11/JavaWeb/JQuery/5-JQuery%E4%BD%BF%E7%94%A8Ajax/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>使用Jquery来发送异步请求。有几个常用的方法：<code>load()</code>、<code>get()</code>、<code>post()</code>等。</p><h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><p>JQuery的load方法是从服务器中加载数据，并把返回的数据放入到被选元素中。</p><p>语法：<br><code>$(selector).load(url, data, callback)</code></p><p>参数：</p><ul><li>url：规定希望加载的URL</li><li>data：与请求一同发送的字符串键值对集合，格式为<code>&#123;key:value,...&#125;</code></li><li>callback：是load方法完成后执行的函数名称</li></ul><p>其中可选参数callback是load方法完成后的回调函数，可以设置不同参数：</p><ul><li>responseTxt：调用成功后返回结果内容</li><li>statusTXT：调用的状态</li><li>xhr：包含XMLHttpRequest对象</li></ul><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>get方法通过GET请求给服务器发起请求。</p><p>语法：<br><code>$(selector).get(url, data, success(response, status, xhr), dataType)</code></p><p>参数：</p><ul><li>url：访问地址</li><li>data：可选，连同请求发送到服务器的数据，键值对集合</li><li>success：请求发送成功后运行的函数，额外的参数有：<ul><li>response：来自请求的结果数据</li><li>status：请求状态</li><li>xhr：XMLHttpRequest对象</li></ul></li><li>dataType：期望服务器返回的数据类型，如果不指定JQuery会智能判断，可能的类型<ul><li>“xml”</li><li>“html”</li><li>“text”</li><li>“script”</li><li>“json”</li><li>“jsonp”</li></ul></li></ul><p>例子：<br>使用get方法发送一个异步请求。返回json数据。</p><p>js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;some.do&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;姓名:&quot;</span> + data.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;, 年龄:&quot;</span> + data.<span class="hljs-property">age</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>控制器方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/some.do&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> mapper.writeValueAsString(student);<br>    response.setContentType(<span class="hljs-string">&quot;application/json;charset=utf-8&quot;</span>);<br>    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> response.getWriter();<br>    pw.println(json);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>输出：<br><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201216113930625.png" alt="image-20201216113930625" style="zoom:50%;" /></p><h2 id="post方法"><a href="#post方法" class="headerlink" title="post方法"></a>post方法</h2><p>和get方法，用法参数都一样，不讲解。</p><h2 id="ajax方法"><a href="#ajax方法" class="headerlink" title="ajax方法"></a>ajax方法</h2><p>这个方法是JQuery的底层AJAX实现。其他所有的ajax方法，如刚才讲的get，post都是在这个方法的基础上，进行封装。</p><p>可以调用该方法来设置关于异步请求的所有参数。</p><p>该方法有一个键值对集合参数settings，在这个集合中设置异步请求配置。</p><p>集合中常用参数：</p><ul><li>url：请求地址</li><li>type：请求方式</li><li>data：请求携带的参数，键值对集合</li><li>dataType：期望返回的数据类型</li><li>contentType：发送信息至服务器的内容编码类型，默认为”application/x-www-form-urlencoded”</li><li>success：请求成功后的回调函数</li><li>async：Boolean类型，默认值为true。即所有请求为异步请求。false为同步请求</li><li>timeout：设置请求超时时间，单位为毫秒。此设置将覆盖全局设置</li><li>cache：Boolean类型，是否 缓存页面。默认为true，即缓存页面</li></ul><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">url</span>:<span class="hljs-string">&quot;some.do&quot;</span>,<br>    <span class="hljs-attr">type</span>:<span class="hljs-string">&quot;get&quot;</span>,<br>    <span class="hljs-attr">dataType</span>:<span class="hljs-string">&quot;json&quot;</span>,<br>    <span class="hljs-attr">success</span>:<span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-title function_">alert</span>(data);<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20201216115230833.png" alt="image-20201216115230833" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-JQuery遍历</title>
    <link href="/2022/05/11/JavaWeb/JQuery/4-JQuery%E9%81%8D%E5%8E%86/"/>
    <url>/2022/05/11/JavaWeb/JQuery/4-JQuery%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过JQuery遍历，可以从当前元素开始，在家族树向上移动(祖先)，向下移动(子孙)，水平移动(同胞)。这种移动被称为对DOM进行遍历。</p><p>JQuery提供了多种遍历方法。遍历方法中最大种类是树遍历。</p><h2 id="祖先"><a href="#祖先" class="headerlink" title="祖先"></a>祖先</h2><p>通过遍历DOM树，可以查找该元素的父元素，后者叫祖先。</p><p>有三个方法：</p><ul><li>parent()</li><li>parents()</li><li>parentsUntil()</li></ul><h3 id="parent-方法"><a href="#parent-方法" class="headerlink" title="parent()方法"></a>parent()方法</h3><p>该方法会返回被选元素的直接父元素。</p><p>该方法只会向上一级对DOM树进行遍历。</p><h3 id="parents-方法"><a href="#parents-方法" class="headerlink" title="parents()方法"></a>parents()方法</h3><p>该方法返回被选元素的所有祖先元素，它会一路向上直到文档的根元素html。</p><p>也可以使用可选的参数来过滤对祖先元素的搜索。</p><p>例如：<code>$(&quot;span&quot;).parents(&quot;ul&quot;);</code>就选择了span元素的是ul元素的祖先</p><h3 id="parantsUntil-方法"><a href="#parantsUntil-方法" class="headerlink" title="parantsUntil()方法"></a>parantsUntil()方法</h3><p>该方法返回介于两个给定元素之间的所有祖先元素。</p><p>例如：<code>$(&quot;span&quot;).parentsUntil(&quot;div&quot;);</code>返回了介于span和div元素之间，span的祖先元素，不包括div。</p><h2 id="后代"><a href="#后代" class="headerlink" title="后代"></a>后代</h2><p>两个用于遍历DOM树的JQuery方法：</p><ul><li>children()</li><li>find()</li></ul><h3 id="children-方法"><a href="#children-方法" class="headerlink" title="children()方法"></a>children()方法</h3><p>该方法会返回被选元素的<strong>所有</strong>直接子元素</p><p>该方法只会向下一级对DOM树进行遍历。</p><p>也可以使用可选参数来过滤对子元素的搜索，例如： <code>$(&quot;div&quot;).children(&quot;p.1&quot;);</code></p><p>返回类名为1的所有p元素，并且是div的直接子元素。</p><h3 id="find-方法"><a href="#find-方法" class="headerlink" title="find()方法"></a>find()方法</h3><p>该方法返回被选元素的所有后代元素，一路向下直到最后一个后代。</p><p>有一个参数。</p><p>例如：想选择div后代中所有的span元素：<code>$(&quot;div&quot;).find(&quot;span&quot;);</code></p><p>再例如：返回div所有的后代：<code>$(&quot;div&quot;).find(&quot;*&quot;);</code></p><h2 id="同胞"><a href="#同胞" class="headerlink" title="同胞"></a>同胞</h2><p>同胞有相同的父元素，有以下几个方法可以进行水平遍历：</p><ul><li>siblings()：返回被选元素的所有同胞元素，可以使用可选参数过滤</li><li>next()：返回被选元素的下一个同胞元素</li><li>nextAll()：返回被选元素后面的所有同胞元素</li><li>nextUntil()：返回介于两个给定参数之间所有跟随的同胞元素，不包括给定元素</li></ul><p>prev()、prevAll()、prevUntil()与上面用法相同，但是方向相反。</p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>有几个过滤方法，他们允许鉴于在一组元素的位置来选择特定元素。</p><h3 id="first-方法"><a href="#first-方法" class="headerlink" title="first()方法"></a>first()方法</h3><p>first()方法返回被选元素的首个元素。</p><p>例子：选取首个div元素内部的第一个p元素</p><p><code>$(&quot;div p&quot;).first();</code></p><h3 id="last方法"><a href="#last方法" class="headerlink" title="last方法"></a>last方法</h3><p>返回被选元素的最后一个元素。</p><p>例子：选取首个div元素内部的最后一个p元素</p><p><code>$(&quot;div p&quot;).last();</code></p><h3 id="eq-方法"><a href="#eq-方法" class="headerlink" title="eq()方法"></a>eq()方法</h3><p>该方法返回必选元素带有指定索引号的元素，索引号从0开始。</p><p>例子：选取第二个p元素，索引号为1</p><p><code>$(&quot;p&quot;).eq(1);</code></p><h3 id="filter-方法"><a href="#filter-方法" class="headerlink" title="filter()方法"></a>filter()方法</h3><p>该方法允许规定一个标准，不匹配这个标准的元素会被从集合中删除，匹配的元素会返回。</p><p>例子：返回类名为“url”的所有p元素</p><p><code>$(&quot;p&quot;).filter(&quot;.url&quot;);</code></p><h3 id="not方法"><a href="#not方法" class="headerlink" title="not方法"></a>not方法</h3><p>该方法返回不匹配标准的所有元素，not方法和filter方法相反</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-JQuery DOM操作</title>
    <link href="/2022/05/11/JavaWeb/JQuery/3-JQuery%20DOM%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/05/11/JavaWeb/JQuery/3-JQuery%20DOM%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JQuery提供了一系列与DOM相关的方法，可以访问和操作HTML元素和属性。</p><h2 id="获取内容和属性"><a href="#获取内容和属性" class="headerlink" title="获取内容和属性"></a>获取内容和属性</h2><p>三个实用的用于获取内容的JQuery方法(<strong>设置时，有参数；返回时，无参数</strong>)：</p><ul><li>text()：设置或返回所选元素的文本内容</li><li>html()：设置或返回所选元素的内容(包括HTML标记)</li><li>val()：设置或返回表单字段的值，即value属性的值</li></ul><p>获取属性的方法：</p><ul><li><p>attr(属性名称)：返回对应属性的值</p><p>  例如获取超链接中href的值：$(“#a”).attr(“href”)，就是获取id为a的超链接元素的href属性对应的值</p></li></ul><h2 id="设置元素内容"><a href="#设置元素内容" class="headerlink" title="设置元素内容"></a>设置元素内容</h2><p>同样适用上面三个获取内容的方法：text()，html()，val()。</p><ul><li><p>可以直接将希望设置的值传入该方法的参数，进行设置。</p></li><li><p>它们拥有回调函数，回调函数有两个参数：<strong>被选元素列表中当前元素的下标(因为每个JQuery对象都是数组，索引从0开始)，以及原始值</strong>(旧值)，然后使用return返回您希望使用的字符串，即函数新值。</p><p>  例子：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><br>    $(<span class="hljs-string">&quot;#change&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        $(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">i, oldText</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;索引值为:&quot;</span> + i + <span class="hljs-string">&quot;，旧文本为:&quot;</span> + oldText;<br>        &#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>  将原来的段落内容改为打印对应索引并再次输出旧文本，结果为：</p><p>  <img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200922181854.png" alt="image-20200922181846914"></p></li></ul><h2 id="设置属性内容"><a href="#设置属性内容" class="headerlink" title="设置属性内容"></a>设置属性内容</h2><p>上述的attr方法同样可以设置/改变属性值</p><ul><li><p>可以直接向attr方法传入指定值，例如：<code>$(&quot;button&quot;).click(function()&#123; $(&quot;#baidu&quot;).attr(&quot;href&quot;, &quot;http://www.baidu.com&quot;)&#125;    )</code>，设置了id为baidu的超链接元素的href属性的值为百度的网站</p></li><li><p>attr方法也允许设置多个属性：</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    $(<span class="hljs-string">&quot;#baidu&quot;</span>).<span class="hljs-title function_">attr</span>(&#123;<br>        <span class="hljs-string">&quot;href&quot;</span> : <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>,<br>        <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;百度网址&quot;</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><p>attr()也提供回调函数，回调函数有两个参数：<strong>被选元素列表当前元素的下标，以及原始(旧)的值</strong>，新值用return返回</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  $(<span class="hljs-string">&quot;#runoob&quot;</span>).<span class="hljs-title function_">attr</span>(<span class="hljs-string">&quot;href&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">i,origValue</span>)&#123;<br>    <span class="hljs-keyword">return</span> origValue + <span class="hljs-string">&quot;/jquery&quot;</span>; <br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><p>有四种添加新元素的JQuery方法</p><ul><li>append()：在被选元素结尾插入内容</li><li>prepend()：在被选元素开头插入内容</li><li>after()：在被选元素之后插入内容</li><li>before()：在被选元素之前插入内容</li></ul><h3 id="append-方法"><a href="#append-方法" class="headerlink" title="append()方法"></a>append()方法</h3><p>该方法在被选元素的结尾插入内容(仍然在该元素的内部)。</p><h3 id="prepend-方法"><a href="#prepend-方法" class="headerlink" title="prepend()方法"></a>prepend()方法</h3><p>该方法在被选元素的开头插入内容。</p><p>可以通过前两个方法添加若干个新元素，append和perpend方法可以通过参数接收无限数量的新元素。</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">appendText</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> txt1=<span class="hljs-string">&quot;&lt;p&gt;文本-1。&lt;/p&gt;&quot;</span>;              <span class="hljs-comment">// 使用 HTML 标签创建文本</span><br>    <span class="hljs-keyword">var</span> txt2=$(<span class="hljs-string">&quot;&lt;p&gt;&lt;/p&gt;&quot;</span>).<span class="hljs-title function_">text</span>(<span class="hljs-string">&quot;文本-2。&quot;</span>);  <span class="hljs-comment">// 使用 jQuery 创建文本</span><br>    <span class="hljs-keyword">var</span> txt3=<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;p&quot;</span>);<br>    txt3.<span class="hljs-property">innerHTML</span>=<span class="hljs-string">&quot;文本-3。&quot;</span>;               <span class="hljs-comment">// 使用 DOM 创建文本 text with DOM</span><br>    $(<span class="hljs-string">&quot;body&quot;</span>).<span class="hljs-title function_">append</span>(txt1,txt2,txt3);        <span class="hljs-comment">// 追加新元素</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="after-方法和before-方法"><a href="#after-方法和before-方法" class="headerlink" title="after()方法和before()方法"></a>after()方法和before()方法</h3><p>after方法在被选元素之后插入内容。</p><p>before方法在被选元素之前插入新元素</p><h3 id="append-prepend和after-before的区别"><a href="#append-prepend和after-before的区别" class="headerlink" title="append/prepend和after/before的区别"></a>append/prepend和after/before的区别</h3><p>用append:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;p&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s1&quot;</span>&gt;</span>s1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/p&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">$(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;&lt;span class=&quot;s2&quot;&gt;s2&lt;/span&gt;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//结果是：</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s1&quot;</span>&gt;</span>s1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s2&quot;</span>&gt;</span>s2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>用after:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;p&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s1&quot;</span>&gt;</span>s1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&lt;/p&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">$(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">after</span>(<span class="hljs-string">&#x27;&lt;span class=&quot;s2&quot;&gt;s2&lt;/span&gt;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><br><span class="hljs-comment">//结果是这样的:</span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s1&quot;</span>&gt;</span>s1<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;s2&quot;</span>&gt;</span>s2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>append/prepend是在被选择的元素内部嵌入</li><li>after/before是在元素外面追加</li></ul><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>可以使用以下两个JQuery方法来删除元素：</p><ul><li>remove：删除被选元素和子元素</li><li>empty：删除被选元素的子元素，也就是清空被选元素。</li></ul><p>remove方法也可以接受一个参数，允许对被删除的元素进行过滤，该参数可以是任何JQuery选择器的语法。</p><p>例如：删除class=’inalic’的p元素</p><p>$(“p”).remove(“.inalic”)；</p><h2 id="获取并设置CSS类"><a href="#获取并设置CSS类" class="headerlink" title="获取并设置CSS类"></a>获取并设置CSS类</h2><p>JQuery有很多对CSS操作的方法：</p><ul><li>addClass()：向被选元素添加一个或多个类</li><li>removeClass()：从被选元素删除一个或多个类</li><li>toggleClass()：对被选元素进行 添加/删除类的切换操作</li><li>css()：设置或 返回样式属性</li></ul><p>先在css文件中定义两个类：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.important</span> &#123;<br><span class="hljs-attribute">color</span>:brown;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">30px</span><br>&#125; <br><span class="hljs-selector-class">.unimportant</span> &#123;<br><span class="hljs-attribute">color</span>:red;<br><span class="hljs-attribute">font-size</span>:<span class="hljs-number">15px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在就有important和unimportant两个类了。</p><h3 id="addClass-方法"><a href="#addClass-方法" class="headerlink" title="addClass()方法"></a>addClass()方法</h3><p>该方法可以给多个元素添加多个css类，可以接受多个css类参数</p><p>例子：给h1和h2添加important类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    $(<span class="hljs-string">&quot;h1,h2&quot;</span>).<span class="hljs-title function_">addClass</span>(<span class="hljs-string">&quot;important&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200926094734.gif" alt="1"></p><h3 id="removeClass-方法"><a href="#removeClass-方法" class="headerlink" title="removeClass()方法"></a>removeClass()方法</h3><p>删除指定的class属性。</p><p>例子：删除上述元素的important类属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#remove&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    $(<span class="hljs-string">&quot;h1, h2&quot;</span>).<span class="hljs-title function_">removeClass</span>(<span class="hljs-string">&quot;important&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200926100652.gif" alt="2"></p><h3 id="toggleClass-方法"><a href="#toggleClass-方法" class="headerlink" title="toggleClass()方法"></a>toggleClass()方法</h3><p>该方法对被选元素进行添加/删除类的切换操作：</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    $(<span class="hljs-string">&quot;h1,h2&quot;</span>).<span class="hljs-title function_">toggleClass</span>(<span class="hljs-string">&quot;important&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200926102152.gif" alt="3"></p><h3 id="css-方法"><a href="#css-方法" class="headerlink" title="css()方法"></a>css()方法</h3><p>css方法设置或者返回被选元素的一个或多个样式属性。</p><h4 id="返回CSS属性"><a href="#返回CSS属性" class="headerlink" title="返回CSS属性"></a>返回CSS属性</h4><p>语法为： <code>css(&quot;propertyname&quot;);</code></p><p>例子：<code>$(&quot;p&quot;).css(&quot;background-color&quot;);</code></p><h4 id="设置CSS属性"><a href="#设置CSS属性" class="headerlink" title="设置CSS属性"></a>设置CSS属性</h4><p>语法：<code>css(&quot;propertyname&quot;, &quot;value&quot;);</code></p><p>例子：<code>$(&quot;p&quot;).css(&quot;background-color&quot;, &quot;yellow&quot;);</code></p><h4 id="设置多个CSS属性"><a href="#设置多个CSS属性" class="headerlink" title="设置多个CSS属性"></a>设置多个CSS属性</h4><p>语法：<code>css(&#123;&quot;propertyname&quot;:&quot;value&quot;, &quot;propertyname&quot;:&quot;value&quot;,...&#125;);</code></p><p>例子：<code>$(&quot;p&quot;).css(&#123;&quot;background-color&quot;:&quot;yellow&quot;, &quot;font-size&quot;:&quot;200%&quot;&#125;)</code></p><h2 id="JQuery尺寸方法"><a href="#JQuery尺寸方法" class="headerlink" title="JQuery尺寸方法"></a>JQuery尺寸方法</h2><p>JQuery提供了很多处理尺寸的方法</p><ul><li>width()</li><li>height()</li><li>innerWidth()</li><li>innerHeight()</li><li>outerWidth()</li><li>outerHeight()</li></ul><h3 id="width和height方法"><a href="#width和height方法" class="headerlink" title="width和height方法"></a>width和height方法</h3><p>width方法用来设置或者返回元素的宽度(不包括内边距，边框或外边距)</p><p>height方法用来设置或返回元素的高度(不包括内边距，边框或外边距)</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 200px;height: 200px; padding: 10px; border: 5px;background-color:burlywood&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;div&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;button&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;显示尺寸&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>js代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    $(<span class="hljs-string">&quot;#button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>       <span class="hljs-keyword">let</span> width = $(<span class="hljs-string">&quot;#div&quot;</span>).<span class="hljs-title function_">width</span>();<br>       <span class="hljs-keyword">let</span> height = $(<span class="hljs-string">&quot;#div&quot;</span>).<span class="hljs-title function_">height</span>();<br>       <span class="hljs-keyword">let</span> text = <span class="hljs-string">&quot;&lt;p&gt;该div元素的宽度为：&quot;</span> + width  + <span class="hljs-string">&quot;&lt;br&gt;该div元素的高度为：&quot;</span> + height + <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>;<br>       $(<span class="hljs-string">&quot;#div&quot;</span>).<span class="hljs-title function_">html</span>(text);<br>    &#125;);<br><br>&#125;)<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200926103743.gif" alt="4"></p><h3 id="innerWidth和innerHeight方法"><a href="#innerWidth和innerHeight方法" class="headerlink" title="innerWidth和innerHeight方法"></a>innerWidth和innerHeight方法</h3><p>分别返回元素的高度和宽度(包括内边距)</p><h3 id="outerWidth和outerHeight方法"><a href="#outerWidth和outerHeight方法" class="headerlink" title="outerWidth和outerHeight方法"></a>outerWidth和outerHeight方法</h3><p>分别返回元素的宽度和高度(包括内边距和边框)</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-JQuery效果</title>
    <link href="/2022/05/11/JavaWeb/JQuery/2-JQuery%E6%95%88%E6%9E%9C/"/>
    <url>/2022/05/11/JavaWeb/JQuery/2-JQuery%E6%95%88%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JQuery有很多效果，例如隐藏，显示，切换，滑动，淡入淡出，以及动画等等。</p><h2 id="隐藏和显示"><a href="#隐藏和显示" class="headerlink" title="隐藏和显示"></a>隐藏和显示</h2><p>隐藏和显示效果分别使用hide()和show()方法。</p><p>语法:</p><p>$(<em>selector</em>).hide(<em>speed,callback</em>);</p><p>$(<em>selector</em>).show(<em>speed,callback</em>);</p><p>上面两个参数都是可选的</p><p>speed参数规定隐藏/显示的速度，可以取以下值：”slow”，”fast”或毫秒</p><p>callback参数是隐藏或者显示<strong>完成后执行</strong>的函数名称，也叫回调函数</p><p>使用toggle()方法可以来切换hide()和show()方法，如果元素已经隐藏，那么该方法会显示元素，反之亦然。该方法同样有两个可选参数。</p><h2 id="淡入淡出"><a href="#淡入淡出" class="headerlink" title="淡入淡出"></a>淡入淡出</h2><p>淡入：fadeIn()</p><p>淡出：fadeOut()</p><p>切换淡入淡出：fadeToggle()</p><p>渐变为给定的不透明度：fadeTo()</p><h3 id="fadeIn-方法"><a href="#fadeIn-方法" class="headerlink" title="fadeIn()方法"></a>fadeIn()方法</h3><p>该方法用于淡入隐藏的元素。</p><p>语法：$(<em>selector</em>).fadeIn(<em>speed,callback</em>);</p><p>可选的参数speed规定效果时长，可取值与上述一致，不再重复</p><p>可选的参数callback参数是fading完成后执行的函数名称</p><h3 id="fadeOut-方法"><a href="#fadeOut-方法" class="headerlink" title="fadeOut()方法"></a>fadeOut()方法</h3><p>该方法用于淡出可见的元素。</p><p>语法：$(<em>selector</em>).fadeOut(<em>speed,callback</em>);</p><p>可选的参数speed规定效果时长，可取值与上述一致，不再重复</p><p>可选的参数callback参数是fading完成后执行的函数名称</p><h3 id="fadeToggle-方法"><a href="#fadeToggle-方法" class="headerlink" title="fadeToggle()方法"></a>fadeToggle()方法</h3><p>该方法用于可以在fadeIn和fadeOut方法之间切换，如果元素已经淡出，那么该方法会添加淡入效果，反之亦然。</p><p>语法：$(<em>selector</em>).fadeToggle(<em>speed,callback</em>);</p><p>可选的参数speed规定效果时长，可取值与上述一致，不再重复</p><p>可选的参数callback参数是fading完成后执行的函数名称</p><h3 id="fadeTo方法"><a href="#fadeTo方法" class="headerlink" title="fadeTo方法"></a>fadeTo方法</h3><p>该iafangfayunxu渐变为给定的不透明度(值介于0与1之间)</p><p>语法：$(<em>selector</em>).fadeTo(<em>speed,opacity,callback</em>);</p><p><strong>必需的speed参数规定效果时长，可取值与上述一致，不再重复</strong></p><p>必需的opacity擦书将淡入淡出效果设置为给定的不透明度，0到1之间</p><p>可选的参数callback参数是fading完成后执行的函数名称</p><h2 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h2><p>向下滑动：slideDown()</p><p>向上滑动：slideUp()</p><p>切换向上和向下滑动：slideToggle()</p><h3 id="slideDown-方法"><a href="#slideDown-方法" class="headerlink" title="slideDown()方法"></a>slideDown()方法</h3><p>该方法可向下滑动指定元素。</p><p>语法：$(selector).slideDown(speed, callback);</p><p>可选的参数speed规定效果时长，可取值与上述一致，不再重复</p><p>可选的参数callback参数是滑动完成后执行的函数名称</p><h3 id="slideUp-方法"><a href="#slideUp-方法" class="headerlink" title="slideUp()方法"></a>slideUp()方法</h3><p>该方法可向上滑动指定元素。</p><p>语法：$(selector).slideUp(speed, callback);</p><p>可选的参数speed规定效果时长，可取值与上述一致，不再重复</p><p>可选的参数callback参数是滑动完成后执行的函数名称</p><h3 id="slideToggle-方法"><a href="#slideToggle-方法" class="headerlink" title="slideToggle()方法"></a>slideToggle()方法</h3><p>该方法可以在slideDown和slideUp方法中进行切换，如果元素已经向下滑动了，那么slideTogge会向上滑动，反之亦然。</p><p>语法：$(selector).slideUp(speed, callback);</p><p>可选的参数speed规定效果时长，可取值与上述一致，不再重复</p><p>可选的参数callback参数是滑动完成后执行的函数名称</p><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p>JQuery的animate()方法允许创建自定义动画</p><p>语法：$(<em>selector</em>).animate({<em>params</em>}<em>,speed,callback</em>);</p><p><strong>必需的params参数定义形成动画的CSS属性</strong></p><p>可选的参数speed规定效果时长，可取值与上述一致，不再重复</p><p>可选的参数callback参数是动画完成后执行的函数名称</p><p>实例1：将div元素向右移动250个像素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">animate</span>(&#123;<span class="hljs-attr">left</span>:<span class="hljs-string">&#x27;250px&#x27;</span>&#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>实例2：操作多个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">animate</span>(&#123;<br>    <span class="hljs-attr">left</span>:<span class="hljs-string">&#x27;250px&#x27;</span>,<span class="hljs-comment">//将元素向右挪动250个像素</span><br>    <span class="hljs-attr">opacity</span>:<span class="hljs-string">&#x27;0.5&#x27;</span>,<span class="hljs-comment">//不透明度变为0.5</span><br>    <span class="hljs-attr">height</span>:<span class="hljs-string">&#x27;150px&#x27;</span>,/高度为150px<br>    <span class="hljs-attr">width</span>:<span class="hljs-string">&#x27;150px&#x27;</span><span class="hljs-comment">//宽度为150px</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>实例3：使用相对值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">animate</span>(&#123;<br>    <span class="hljs-attr">left</span>:<span class="hljs-string">&#x27;250px&#x27;</span>,<span class="hljs-comment">//向右挪动250px，使用绝对值</span><br>    <span class="hljs-attr">height</span>:<span class="hljs-string">&#x27;+=150px&#x27;</span>,<span class="hljs-comment">//以当前高度为基准，再增加高度150px</span><br>    <span class="hljs-attr">width</span>:<span class="hljs-string">&#x27;+=150px&#x27;</span><span class="hljs-comment">//以当前宽度为基准，再增加宽度150px</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>实例4：使用预定义的值</p><p>可以把属性的动画中设置为show，hide或者toggle</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  $(<span class="hljs-string">&quot;div&quot;</span>).<span class="hljs-title function_">animate</span>(&#123;<br>    <span class="hljs-attr">height</span>:<span class="hljs-string">&#x27;toggle&#x27;</span><span class="hljs-comment">//toggle是预定义的值，在这里意思是如果显示了该div元素，就隐藏如果隐藏了，那么就显示</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>实例5：使用队列功能</p><p>JQuery提供针对动画的队列功能，意思是如果编写多个animate调用，那么JQuery会创建这些方法调用的内部队列，然后逐一运行这些调用。</p><p><strong>注意：animate方法几乎可以操作任何CSS属性，但是，当使用animate时，必须用Camel标记法书写所有属性名，就是有”-“的要去掉，例如padding-left要写成paddingLeft,margin-right要写成marginLeft；并且，色彩动画不包含在核心JQuery库中，要使用，需要下早颜色动画插件。</strong></p><h2 id="停止动画"><a href="#停止动画" class="headerlink" title="停止动画"></a>停止动画</h2><p>stop方法用来停止动画或者效果，在它们完成之前。stop方法适用所有JQuery效果函数包括滑动，淡入淡出和自定义动画。</p><p>语法：$(<em>selector</em>).stop(<em>stopAll,goToEnd</em>);</p><p>可选的stopAll采纳数规定是否应该清除动画队列，默认为false：即停止活动的动画，允许任何排入队列的动画向后执行</p><p>可选的goToEnd参数规定是否立即完成当前动画，默认为false</p><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>许多JQuery函数有回调函数参数，包括动画函数。</p><p>回调函数在当前动画完成后执行。</p><p>例子：</p><p>有回调函数：警告框会在隐藏后显示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  $(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">hide</span>(<span class="hljs-string">&quot;slow&quot;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;段落现在被隐藏了&quot;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>无回调函数：警告框会在隐藏效果完成前弹出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;button&quot;</span>).<span class="hljs-title function_">click</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>  $(<span class="hljs-string">&quot;p&quot;</span>).<span class="hljs-title function_">hide</span>(<span class="hljs-number">1000</span>);<br>  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;段落现在被隐藏了&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="Chaining-链"><a href="#Chaining-链" class="headerlink" title="　Chaining(链)"></a>　Chaining(链)</h2><p>链允许在一条语句中运行多个JQuery方法(在相同的元素上)。</p><p>语法是在一个方法后直接再使用 “.”来链接下一个方法。</p><p>例如把slideDown方法和slideUp方法链接到一起：<code>$(&quot;#p1&quot;).slideUp().slideDown();</code></p><p>可以添加很多个方法调用，语句很长时，可以使用换行缩进，JQuery会抛掉多余空格。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-JQuery介绍</title>
    <link href="/2022/05/11/JavaWeb/JQuery/1-JQuery%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/05/11/JavaWeb/JQuery/1-JQuery%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>JQuery是js的一个工具库，封装了js代码。简化了开发流程。</p><h2 id="JQuery的基本语法"><a href="#JQuery的基本语法" class="headerlink" title="　JQuery的基本语法"></a>　JQuery的基本语法</h2><p>JQuery语法是通过选取HTML元素来执行一些操作。</p><p>基础语法：$(selector).action()</p><p>使用美元符号 “$”来进行选取，选择符selector查询和查找HTML元素，action执行对元素的操作</p><p>选择器和CSS差不多，有这么几种</p><ul><li>标签元素选择器：使用标签名称来获取元素数组，例如 $(“p”) ，表示获取所有<p></li><li>id选择器：使用唯一的id来选取指定元素，例如 $(“#test”)，表示获取id为test的元素，<strong>注意 “#”</strong></li><li>.class选择器：使用类选择器来选取元素，例如 $(“.test”)，获取所有class为test的元素，<strong>注意”.”</strong></li><li>括号中可以直接填DOM对象，例如 <code>var Obj = document.getElementById(&quot;test&quot;);$(Obj).hide()</code></li></ul><p>除此之外，还可以通过属性来选取，</p><p>$(“[attr]”)：表示获取所有 有attr属性的元素</p><p>更多实例：</p><ul><li>$(“*”)：选取所有元素</li><li>$(“this”)：选取当前元素</li><li>$(“p.intro”)：选择class为intro的p元素</li><li>$(“p:first”)：选择第一个p元素</li><li>$(“[href]”)：选取带有href属性的元素</li><li>$(“a[target=’_blank’]”)：选取所有target属性值为”_blank”的<a>元素</li><li>$(“a[target!=’_blank’]”)：选取所有target属性值不为”_blank”的<a>元素</li><li>$(“:button”)：选取所有type=”button”的<input>元素和<button>元素</li></ul><h2 id="DOM对象和JQuery对象"><a href="#DOM对象和JQuery对象" class="headerlink" title="DOM对象和JQuery对象"></a>DOM对象和JQuery对象</h2><p>使用js语法创建的对象就是DOM对象，使用JQuery语法创建的对象叫做JQuery对象。<strong>注意：JQuery表示的对象都是数组。即使某些数组只有一个元素。</strong></p><p>DOM对象和JQuery对象可以互相转换：</p><p>DOM对象转为JQuery对象：语法，$(DOM对象)</p><p>JQuery对象转为DOM对象：语法，从数组中获取第一个对象，第一个对象就是DOM对象，使用[0]或者get[0]</p><p>转换是为了使用指定对象的属性和方法。</p><h2 id="入口函数的几种写法"><a href="#入口函数的几种写法" class="headerlink" title="入口函数的几种写法"></a>入口函数的几种写法</h2><p>在js中，要将js代码写在<code>window.onload() = function()&#123;&#125;</code>中，类似的，在JQuery中，也有几种写法。</p><ul><li>使用<code>$(document).ready(function()&#123;&#125;)</code>，将代码写到function函数中，用$符号将document转换为JQuery对象，使用该对象的ready方法，类似window.onload</li><li>是上面的简洁写法，即<code>$(function()&#123;&#125;)</code>，一般使用这种多一些</li></ul><p>除此之外，<code>jQuery(function()&#123;&#125;)</code>和<code>window.jQuery(function(&#123;&#125;))</code>也是等价的。</p><h3 id="jQuery入口函数和JavaScript入口函数的区别"><a href="#jQuery入口函数和JavaScript入口函数的区别" class="headerlink" title="jQuery入口函数和JavaScript入口函数的区别"></a>jQuery入口函数和JavaScript入口函数的区别</h3><ul><li>jQuery的入口函数是在html所有标签都加载之后，就会去执行，可以执行多次，不会被覆盖</li><li>JavaScript的window.onload时间是等到所有内容，包括外部图片之外的文件夹在完后，才会去执行，只能执行一次，如果执行第二次，第一次的执行会被覆盖</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11-过滤器</title>
    <link href="/2022/05/11/JavaWeb/Servlet/12-%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    <url>/2022/05/11/JavaWeb/Servlet/12-%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="　介绍"></a>　介绍</h2><p>首先来看，过滤器在整个Ｗｅｂ流程的哪里：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200815085902.png" alt="image-20200815085855245"></p><p>从上面的图，我们可以看出来，当浏览器发送请求给服务器时，会先执行过滤器，再访问Web资源；服务器响应Response时，也会先执行过滤器，再发送请求资源给浏览器。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>拦截Http服务器，帮助Http服务器检测当前请求合法性</li><li>拦截Http服务器，对当前请求进行增强操作</li></ul><p>例如，在没有过滤器时，如果要处理中文乱码情况，需要在每个Sevlet中都设定编码，但是这样，代码重复率很高；有了过滤器，情况就不一样了，只要在过滤器中指定了编码，那么就可以使全站的Web资源都是使用该编码。</p><p>当然，过滤器的作用很多，还可以过滤一些敏感的字符串，权限验证(规定只有带Session或Cookie的浏览器才能访问web资源)等等。</p><h3 id="Filter接口-过滤器接口"><a href="#Filter接口-过滤器接口" class="headerlink" title="Filter接口(过滤器接口)"></a>Filter接口(过滤器接口)</h3><ul><li>来自于Sevlet规范下接口</li><li>Filter接口实现类由开发人员提供，Http服务器不提供实现</li></ul><h4 id="Filter接口开发类步骤"><a href="#Filter接口开发类步骤" class="headerlink" title="Filter接口开发类步骤"></a>Filter接口开发类步骤</h4><ul><li>创建一个Java类实现Filter接口</li><li>重写Filter接口中的doFilter方法</li><li>在web.xml文件中将过滤器接口实现类注册到Http服务器</li></ul><h2 id="Filter接口-API"><a href="#Filter接口-API" class="headerlink" title="Filter接口 API"></a>Filter接口 API</h2><p>Filter接口有三个方法</p><ul><li>void init(FilterConfig filterconfig)</li><li>void destroy()</li><li>void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</li></ul><p>前两个方法很好理解，它们只在Web服务器加载和销毁时被执行，且只会被执行一次。</p><p>比较重要的是doFilter方法：有三个参数，前面两个参数和doGet，doPost方法参数一样，请求参数和响应参数，ServletRequest是HttpServletRequest的父接口。</p><p>第三个参数FilterChain类型，也是一个接口，该接口只有一个方法：doFilter(ServletRequest var1, ServletResponse var2)。</p><p>感觉有点糊涂了，怎么有一个doFilter方法。</p><p>可以这样理解：过滤器不止一个，那么就需要管理这些过滤器，在Java中使用了链式结构，把所有的过滤器都放在了FilterChain中，如果符合条件，就执行下一个过滤器，一直到没有符合条件的过滤器，就执行目标资源。</p><p>简单来说，FilterChain掌管着所有过滤器，执行完一个，由FilterChain去判断是否还有符合条件的下一个过滤器，如果有，继续执行下一个过滤器，没有，就执行目标资源。</p><h2 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h2><p>首先写一个简单的过滤器：设置当浏览器访问timg.jpg图片资源时，如果年龄小于等于40，就可以访问，大于40，就不能访问，并输出提示信息。</p><p>WebFilter代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><br>        <span class="hljs-comment">//获得年龄参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> servletRequest.getParameter(<span class="hljs-string">&quot;age&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(Integer.valueOf(age) &lt;= <span class="hljs-number">40</span>) &#123;<br>            filterChain.doFilter(servletRequest, servletResponse);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//如果年龄大于40，就输出提示信息，没执行filterChain.doFilter方法，就会直接返回给浏览器</span><br>            servletResponse.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> servletResponse.getWriter();<br>            out.print(<span class="hljs-string">&quot;&lt;h1&gt;你不能查看此资源!&lt;h1&gt;&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后需要在web.xml文件中进行注册：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>webFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>filter.WebFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>webFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/timg.jpg<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个例子中，希望过滤器当浏览器访问timg.jpg文件时，进行拦截。</p><p><strong>filter标签中有：</strong></p><ul><li><p><strong>filter-name：用于为过滤器设置一个名字</strong></p></li><li><p><strong>filter-class：是过滤器实现类的完整限定类名</strong></p></li><li><p><strong>init-param：该元素用于为过滤器指定初始化参数，它的子元素param-name指定参数名字，param-value指定参数的值，在过滤器中可以使用FilterConfig接口对象来访问初始化参数</strong></p></li></ul><p><strong>filter-mapping：是用来设置当浏览器访问哪些资源时，哪个过滤器需要进行拦截</strong></p><p><strong>可以有两种方式来指定：Sevlet名称，资源访问的请求路径</strong></p><p><strong>filter-mapping标签中有：</strong></p><ul><li><strong>filter-name：写上需要使用的过滤器名字，该值必须是在filter中声明过的</strong></li><li><strong>url-pattern：设置filter所拦截的请求路径</strong></li><li><strong>servlet-name：指定过滤器所拦截的Servlet名称</strong></li><li><strong>dispatcher：指定当用户以什么样的方式访问资源时，过滤器需要拦截，有四个可取值：REQUEST,INCLUDE,FORWORD,ERROR， 默认为REQUEST，用户可以设置多个<dispatcher>标签子元素来指定Filter对资源的多种调用方式进行拦截。</strong><ul><li>REQUEST：当用户直接访问页面时，Web容器将会调用此过滤器。如果目标资源是通过RequestDispatcher的include()或forword方法访问时，那么该过滤器就不会被调用</li><li>INCLUDE:如果目标资源是通过RequestDispatcher的include方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用</li><li>FORWORD：如果该目标资源是通过RequestDispatcher的forword方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。</li><li>ERROR：如果目标资源使用过声明式异常处理机制被调用时，那么该过滤器将被调用，除此之外，过滤器不会被调用</li></ul></li></ul><h2 id="过滤器的执行顺序"><a href="#过滤器的执行顺序" class="headerlink" title="过滤器的执行顺序"></a>过滤器的执行顺序</h2><p>首先看一个测试:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>    System.out.println(<span class="hljs-string">&quot;准备放行&quot;</span>);<br><br>    filterChain.doFilter(servletRequest, servletResponse);<br><br>    System.out.println(<span class="hljs-string">&quot;放行成功&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果为：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200815143154.png" alt="image-20200815143152988"></p><p>完整的执行流程为：客户端发送请求给Http服务器，服务器执行过滤器，先打印”准备放行”，接着执行doFilter方法，服务器发现没有其他过滤器，就执行目标资源，执行完以后，再回到过滤器，继续执行代码，打印”放行成功”。</p><p>再看一个测试：</p><p>有两个过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Filter1</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Filter1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        System.out.println(<span class="hljs-string">&quot;开始执行Filter1&quot;</span>);<br><br>        filterChain.doFilter(servletRequest, servletResponse);<br><br>        System.out.println(<span class="hljs-string">&quot;Filter1执行结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//Filter2</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Filter2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;开始执行Filter2&quot;</span>);<br><br>        filterChain.doFilter(servletRequest, servletResponse);<br><br>        System.out.println(<span class="hljs-string">&quot;Filter2执行结束&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试的Servlet的doGet方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>    System.out.println(<span class="hljs-string">&quot;执行Servlet代码&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果为：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200815144016.png" alt="image-20200815144016042"></p><p>由该执行结果可知，执行顺序为：先执行Filter1，然后执行Filter1的doFilter方法，就转到下一个过滤器Filter2，等Filter2执行完后，再回到Filter1继续执行。</p><p><strong>其中，过滤器之间的执行顺序是看在web.xml文件中mapping的先后顺序的，放在前面的先执行。</strong></p><h2 id="Filter的简单应用"><a href="#Filter的简单应用" class="headerlink" title="Filter的简单应用"></a>Filter的简单应用</h2><p>filter有三种典型应用：</p><ul><li>可以在filter中根据条件来决定是否调用filterChain.doFilter()方法，即是否让目标资源继续执行</li><li>在让目标资源执行之前，可以对request\response作预处理，再让目标资源执行</li><li>在目标资源执行之后，可以捕获目标资源执行结果，从而实现一些特殊功能</li></ul><h2 id="过滤器拦截地址-url-pattern-格式"><a href="#过滤器拦截地址-url-pattern-格式" class="headerlink" title="过滤器拦截地址 url-pattern 格式"></a>过滤器拦截地址 url-pattern 格式</h2><p>在web.xml文件中，以下语法用来定义映射：</p><ul><li>以  “/“ 和  “/*” 结尾的是用来做路径映射</li><li>以前缀  “*.” 开头的是用来做 拓展映射</li><li>“/” 是用来定义default servlet映射的</li><li>剩下的都是用来定义详细映射的，比如：/aa/bb/cc.jpg</li></ul><p>有几种情况：</p><ul><li>在调用某一具体文件时，拦截格式：<url-pattern>/img/test.jpg&lt;/url-pattern&gt;</li><li>在调用某一文件下的资源文件时，拦截格式：<url-pattern>/img/*&lt;/url-pattern&gt;</li><li>在调用任意文件夹下某种类型文件时，拦截格式：<url-pattern>*.jpg&lt;/url-pattern&gt;<!--注意，没有 “/”--></li><li>在调用网站任意文件时，拦截格式：<url-pattern>/*&lt;/url-pattern&gt;</li></ul><p><strong>注意：定义例如 “/*.action”是错误的，因为这既属于路径映射，又属于拓展映射，服务器无法分辨</strong></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-监听器</title>
    <link href="/2022/05/11/JavaWeb/Servlet/11-%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <url>/2022/05/11/JavaWeb/Servlet/11-%E7%9B%91%E5%90%AC%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="　介绍"></a>　介绍</h1><p>监听器设计三个组件：事件源，事件对象，事件监听器</p><p>三者关系为：事件监听器监听事件源的方法，当触发事件源的事件时，事件监听器就调用对应的方法，同时将该事件对象作为参数传递给该方法。</p><p>事件源可以通过事件对象获得。</p><p>事件源需要注册监听器对象（简单来说，就是告诉监听器你要监听哪个事件源）。</p><h2 id="Servlet监听器"><a href="#Servlet监听器" class="headerlink" title="Servlet监听器"></a>Servlet监听器</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><ul><li>它们是一组来自Servlet规范下的接口，共有8个</li><li>Http服务器没有提供实现类，需要开发人员手动实现</li><li>监听器接口用于监控作用域对象生命周期变化时刻和作用域对象共享数据变化时刻</li></ul><p>在Servlet规范中定义了多种类型监听器，他们用于监听的事件源分别为：</p><ul><li>ServletContext：全局作用域对象</li><li>HttpSession：会话作用域对象</li><li>ServletRequest：请求作用域对象</li></ul><p>对应的监听器对象分别为ServletContextListener，HttpSessionListener和ServletRequestListener。</p><p>不过和其他事件监听器不同的是，Servlet监听器的注册不是直接注册在事件源上，而是由WEB容器负责注册，开发人员需要在web.xml文件中使用<listener>标签配置好监听器。</p><h3 id="监听类接口实现类开发规范"><a href="#监听类接口实现类开发规范" class="headerlink" title="监听类接口实现类开发规范"></a>监听类接口实现类开发规范</h3><p>共分三步：</p><ul><li>根据监听实际情况，选择对应监听器接口进行实现</li><li>重写监听器接口声明(即监听事件处理方法)</li><li>在web.xml文件中将监听器接口实现类注册到Http服务器</li></ul><h2 id="监听器监听对象的创建和销毁"><a href="#监听器监听对象的创建和销毁" class="headerlink" title="监听器监听对象的创建和销毁"></a>监听器监听对象的创建和销毁</h2><p>HttpSessionListener、ServletContextListener、ServletRequestListener分别监控着Session、<br>Context、Request对象的创建和销毁。</p><p>每个接口都定义了两个方法，分为为对象创建和销毁的方法</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200814092651.png" alt="20200813204102"> </p><p>监听器可以监听到ServletContext的初始化和销毁，Session的创建。(服务器关闭，不代表Session被销毁，Session创建在服务器内存中，所以看不到Session被销毁)</p><h2 id="监听对象属性变化"><a href="#监听对象属性变化" class="headerlink" title="监听对象属性变化"></a>监听对象属性变化</h2><p>ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener<br>分别监听着Context、Session、Request对象属性的变化。</p><p>三个接口都定义了三个方法来处理被监听对象中的属性增加，删除和替换的事件，同一个事件在这三个接口中对应方法名称完全相同，只是接受参数类型不同。</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200814111221.png" alt="image-20200814111213577"></p><p>只演示Context对象，其他都可依此类推。</p><p>监听器对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Listener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ServletContextAttributeListener</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Listener</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attributeAdded</span><span class="hljs-params">(ServletContextAttributeEvent scae)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Ｃｏｎｔｅｘｔ对象增加了属性&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attributeRemoved</span><span class="hljs-params">(ServletContextAttributeEvent scae)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Ｃｏｎｔｅｘｔ对象删除了属性&quot;</span>);<br>        <br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attributeReplaced</span><span class="hljs-params">(ServletContextAttributeEvent scae)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Ｃｏｎｔｅｘｔ对象更新了属性&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用于测试Servlet对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> request.getServletContext();<br>        servletContext.setAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;哈哈哈ce&quot;</span>);<br>        servletContext.setAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;哈哈哈哈&quot;</span>);<br>        servletContext.removeAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果为：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200814112021.png" alt="image-20200814112021198"></p><h2 id="监听Session内的对象"><a href="#监听Session内的对象" class="headerlink" title="监听Session内的对象"></a>监听Session内的对象</h2><p>除了上述六种Listener，还有两种Listener监听Session内的对象，分别是HttpSessionBindingListener和HttpSessionActivationListener，实现这两个接口不需要在web.xml文件中注册。</p><ul><li>实现HttpSessionBindingListener接口，JavaBean对象可以感知自己被绑定到Session中和从Session中删除的事件(和HttpSessionAttributeListener的作用差不多)</li><li>实现HttpSessionActivationListener接口，JavaBean对象可以感知自己被活化和钝化的事件(当服务器关闭的时候，会将Session的内容保存在硬盘上，称为钝化；服务器开启时，会将Session的内容在硬盘上重新加载，称为活化)</li></ul><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/20200814141343.png" alt="image-20200814141343471"></p><p>如果想要测试Session的硬化和钝化，需要修改Tomcat配置。在META-INF目录下的context.xml文件中添加代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Manager</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.session.PersistentManager&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">maxIdleSwap</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Store</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.session.FileStore&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">directory</span>=<span class="hljs-string">&quot;zhongfucheng&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Manager</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="监听器的简单应用"><a href="#监听器的简单应用" class="headerlink" title="监听器的简单应用"></a>监听器的简单应用</h2><h3 id="加快程序运行速度"><a href="#加快程序运行速度" class="headerlink" title="加快程序运行速度"></a>加快程序运行速度</h3><p>例如在之前做的在线考试管理系统中，用户注册需要连接数据库，插入数据，其中Connection的创建和销毁非常消耗时间，所以需要在服务器启动时就创建一批Connection，即数据库连接池，那么程序如何知道Tomcat服务器什么时候启动呢，就可以使用全局作用域对象ServletContext对象的监听器，其中的初始化方法，服务器在启动时，一定会创建ServletContext对象，就可以编写监听器对象方法，在这个方法中，创建一批Connection对象，即可加快程序运行速度</p><h3 id="统计网站在线人数"><a href="#统计网站在线人数" class="headerlink" title="统计网站在线人数"></a>统计网站在线人数</h3><p>在网站中使用Session来标识用户是否登录，如果登录了，就在Session域中保存相应属性，如果没有登录，那么Session属性就为空。</p><p>要统计网站在线人数，应该这样做：监听是否有新的Session创建了，如果有，那么在线人数就+1，这个在线人数是针对整个网站的，所以需要使用Context全局作用域对象来保存</p><p>所以思路就是：</p><ul><li>监听Session是否被创建，如果被创建了，那么在Context的域对象的值就加1</li><li>如果Session从内存中被移除了，那么在Context的域对象中的值-1</li></ul><p>监听器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Listener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpSessionListener</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Listener</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sessionCreated</span><span class="hljs-params">(HttpSessionEvent se)</span> &#123;<br><br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> se.getSession().getServletContext();<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (Integer) servletContext.getAttribute(<span class="hljs-string">&quot;num&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-literal">null</span>) &#123;<br>            servletContext.setAttribute(<span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            num++;<br>            servletContext.setAttribute(<span class="hljs-string">&quot;num&quot;</span>, num);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sessionDestroyed</span><span class="hljs-params">(HttpSessionEvent se)</span> &#123;<br><br>        <span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> se.getSession().getServletContext();<br><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> (Integer) servletContext.getAttribute(<span class="hljs-string">&quot;num&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(num == <span class="hljs-literal">null</span>) &#123;<br>            servletContext.setAttribute(<span class="hljs-string">&quot;num&quot;</span>, <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            num--;<br>            servletContext.setAttribute(<span class="hljs-string">&quot;num&quot;</span>, num);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-Session</title>
    <link href="/2022/05/11/JavaWeb/Servlet/10-Session/"/>
    <url>/2022/05/11/JavaWeb/Servlet/10-Session/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是Session"><a href="#什么是Session" class="headerlink" title="什么是Session"></a>什么是Session</h2><p>Session是另外一种记录浏览器状态的机制，不同的是Cookie保存在浏览器中，Session保存在服务器中。用户使用浏览器访问服务器时，服务器会把用户的信息以某种形式记录在服务器中。</p><p>如果把Cookie比做 检查用户带来的通行证来确认用户身份，那么Session就是通过检查服务器上的“客户信息表”来确认用户身份信息，Session相当于在服务器中建立了一份“客户明细表”。</p><h2 id="为什么使用Session技术"><a href="#为什么使用Session技术" class="headerlink" title="为什么使用Session技术"></a>为什么使用Session技术</h2><p>Session比Cookie使用方便，Session可以解决Cookie解决不了的事，适用范围更广，例如Session可以存储对象，但是Cookie只能存储字符串。</p><h2 id="Seesion-API"><a href="#Seesion-API" class="headerlink" title="Seesion API"></a>Seesion API</h2><ul><li>long getCreationTime()：获取Seesion被创建的时间</li><li><strong>String getId()：获取Session的id</strong></li><li>long getLastAccessedTime()：返回Session最后活跃的时间</li><li>ServletContext getServletContext()：获取ServletContext对象</li><li><strong>void setMaxInactiveInterval(int var1)：设置Session超时时间</strong></li><li><strong>int getMaxInactiveInterval()：获取Session超时时间</strong></li><li><strong>Object getAttribute(String var1)：获取Session属性</strong></li><li>Eumeration getAttributeName()：获取Session所有的属性名</li><li><strong>void setAttribute(String var1, Object var2)：设置Session属性</strong></li><li><strong>void removeAttribute(String var1)：移除Session属性</strong></li><li><strong>void invalidate()：销毁该Session</strong></li><li>boolean isNew()：该Session是否为新的</li></ul><h2 id="HttpSession接口"><a href="#HttpSession接口" class="headerlink" title="HttpSession接口"></a>HttpSession接口</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>HttpSession接口来自于Servlet规范下的一个接口，实现类由Http服务器提供</li><li>如果两个Servlet来自于同一个网站，并且为同一个浏览器/用户提供服务，那么此时可以通过HttpSession对象进行数据共享</li><li>习惯上将HttpSession接口修饰对象称为ie会话作用域对象</li></ul><p>可以看出，Session有着和request和ServletContext类似的方法，Session作为一种记录浏览器状态的机制，只要Session没有被销毁，Servlet之间就可以直接通过Session对象实现通讯。</p><p>简单例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Servlet1代码</span><br><br><span class="hljs-comment">//得到Session对象</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br><span class="hljs-comment">//设置Session属性</span><br>session.setAttribute(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;哈哈哈哈哈哈&quot;</span>);<br><br><span class="hljs-comment">//Servlet2代码</span><br><br><span class="hljs-comment">//获取从Servlet1的Session存进去的值</span><br><span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (String) session.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(value);<br><br></code></pre></td></tr></table></figure><p>一般来讲，当我们要存进去的是用户级别的数据就用Session，用户级别就是：只要浏览器不关闭，希望数据还在，就是用Seesion保存。</p><h2 id="Session的实现原理"><a href="#Session的实现原理" class="headerlink" title="Session的实现原理"></a>Session的实现原理</h2><p><strong>当浏览器访问某个网页时，会在服务器端内存开辟一块内存，这块内存就叫做Session，，这个内存是和浏览器关联在一起的，这个浏览器指的是浏览器窗口，或者是浏览器的子窗口，意思是：只允许当前这个session对应的浏览器访问，就算再在同一个机器上启动新的一个浏览器也是无法访问的，而另外一个浏览器也需要记录Session的话，服务器就会再创建一个属于这个浏览器的session。</strong></p><p><strong>简单来说，一个客户端的一个处于打开状态的浏览器对应一个Session。</strong></p><p><strong>需要注意的是，例如，谷歌浏览器访问一个网站，在不关闭前一个浏览器的情况下，再打开一个谷歌浏览器窗口打开同一个网站，访问的是一个Session。但是如果关闭了前一个浏览器，再打开该浏览器打开该网站，那么就会创建新的Session。</strong></p><p>但是，如果按照上述代码，在浏览器新建一个会话，先访问Servlet2，那么会出现空指针异常。</p><p>那么问题来了：服务器是如何实现一个session为一个用户浏览器服务的呢？换个说法：为什么服务器能够为不同用户浏览器提供不同session？</p><p><strong>Http协议是无状态的，Session不能依据HTTP连接来判断是否为同一个用户，于是：服务器向用户发送了一个名为JESSIONID的Cookie，它的值是Session的id值，Session依据这个Cooie来识别是否为同一个用户。</strong></p><p><strong>简单来说，Session之所以可以识别不同用户，依靠的就是Cookie。该Cookie是服务器自动颁发给浏览器的，不需要手动创建，该Cookie的maxAge默认值为-1，也就是说仅供当前浏览器使用，不会将该Cookie存在硬盘中。</strong></p><p>捋一下思路流程：当访问Servlet1时，服务器会创建一个Session对象，执行程序代码，并且自动颁发给Cookie给用户浏览器。</p><p>当使用同一个浏览器访问Servlet2时，浏览器会把Cookie发给服务器，服务器通过Cookie存储的Session的ID就知道该浏览器使用的是哪个Session。</p><p>但是当使用新会话浏览器直接访问Servlet2时，该新浏览器没有Cookie，所有服务器无法辨认使用哪个浏览器，所以就获取不到值，所以前面例子出现空指针异常。</p><h3 id="URL地址重写"><a href="#URL地址重写" class="headerlink" title="URL地址重写"></a>URL地址重写</h3><p>前面提到，Session是通过Cookie来识别浏览器，但是如果用户浏览器禁用了Cookie（<strong>注意，禁用Cookie意味着浏览器不能向服务器发送Cookie，但是浏览器还是可以接受Cookie，也就是响应头可以有Cookie，但是请求头不能有</strong>），那么应该怎么办，JavaWeb提供了另一种方式：URL地址重写</p><p>HttpServletResponse类提供了两个URL地址重写的方法：</p><ul><li>encodingURL(String url)</li><li>encodingRedirectURL(String url)</li></ul><p>这两个方法会自动判断该浏览器是否支持Cookie，如果支持Cookie，重写后的URL地址就不会带有jsessionid了（当然，即使浏览器支持Cookie，第一次输出URL地址时还是会出现jsessionid，因为没有任何Cookie可带）。</p><p>使用Session，改写一下Cookie文档商品例子里的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//之前的代码，超链接直接为对应的链接</span><br><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Book&gt; bookEntry : entries) &#123;<br>            <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> bookEntry.getValue();<br>            out.print(<span class="hljs-string">&quot;&lt;li&gt;&lt;a href=&#x27;/myweb/one?id=&quot;</span>+ book.getId() + <span class="hljs-string">&quot;&#x27; target=&#x27;_blank&#x27;&gt;&quot;</span> + book.getName() + <span class="hljs-string">&quot;&lt;/a&gt;&lt;/li&gt;&quot;</span>);<br>        &#125;<br><br><span class="hljs-comment">//修改后的代码,将链接使用encodingURL进行编码，然后再进行链接</span><br><br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Book&gt; bookEntry : entries) &#123;<br>            <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> bookEntry.getValue();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> response.encodeURL(<span class="hljs-string">&quot;/myweb/one?id=&quot;</span> + book.getId());<br>            out.print(<span class="hljs-string">&quot;&lt;li&gt;&lt;a href=&#x27;&quot;</span>+ url + <span class="hljs-string">&quot;&#x27; target=&#x27;_self&#x27;&gt;&quot;</span> + book.getName() + <span class="hljs-string">&quot;&lt;/a&gt;&lt;/li&gt;&quot;</span>);<br>        &#125;<br><br></code></pre></td></tr></table></figure><p>URL地址重写的原理为：将Session的id重写到URL地址中，服务器通过解析后重写URL，获取Session的id，这样一来，即使浏览器禁用了Cookie，但是Session的id还是可以通过服务器端传递。</p><h2 id="Session的生命周期和有效期"><a href="#Session的生命周期和有效期" class="headerlink" title="Session的生命周期和有效期"></a>Session的生命周期和有效期</h2><p>Session在用户第一次访问服务端Servlet，jsp等动态资源时就会自动创建，Session对象保存在内存中。</p><p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，无论是否对Session进行读写，服务器都会认为Session活跃了一次。</p><p>由于随着越来越多用户访问服务器，因此Session也越来越多，为了防止内存溢出，服务器会把长时间没有活跃的Session从内存中删除，这个时间就是Session的超时时间。</p><p>Session默认超时时间为30分钟，有三种方式可以对Session的超时时间进行修改：</p><ol><li><p>在tomcat/conf/web.xml文件中设置，对所有的WEB应用都有效</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>20<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><span class="hljs-comment">&lt;!--修改超时时间为20分钟--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在单个web.xml文件中设置，只对单个web应用有效，如果冲突，以自己的web与你管用为准，代码和第一种一样。</p></li><li><p>通过setMaxInactiveInterval()方式设置</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置最长超时时间为60秒，这个方法参数为秒</span><br>session.setMaxInactiveInterval(<span class="hljs-number">60</span>);<br></code></pre></td></tr></table></figure></li></ol><h2 id="Session的简单应用"><a href="#Session的简单应用" class="headerlink" title="Session的简单应用"></a>Session的简单应用</h2><h3 id="使用Session完成用户简单登录"><a href="#使用Session完成用户简单登录" class="headerlink" title="使用Session完成用户简单登录"></a>使用Session完成用户简单登录</h3><p>在不关闭浏览器的情况下可以自动登录，而不用再次输入密码</p><p>思路：首先写一个静态HTML文件Login.html，用作登录界面，输入帐户密码。有两个Servlet实现类LoginServlet和IndexServlet，LoginServlet用来验证输入帐户密码是否匹配，输出对应提示信息，IndexServlet用来检查Session是否已经有了User，如果有了证明之前登录成功，直接提示登录成功信息，如果没有，重定向到登录界面。并将IndexServlet设置为默认打开文件。</p><p>代码（User类和UserDB类省略）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//LoginServlet的doPost方法</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//获得传来的参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br><br>        <span class="hljs-comment">//验证是否为正确的用户名和密码</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserDB.find(username, password);<br><br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">//如果不是，输出登录失败提示信息</span><br>            response.getWriter().print(<span class="hljs-string">&quot;&lt;h3&gt;用户名或密码错误，无法登陆!&lt;/h3&gt;&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//添加该user对象到Session中</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br><span class="hljs-comment">//打印登录成功提示信息</span><br>        response.getWriter().print(<span class="hljs-string">&quot;成功登录!&quot;</span>);<br>        <br>    &#125;<br><br><span class="hljs-comment">//IndexServlet的doGet方法</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br><br>        <span class="hljs-comment">//首先获得User对象，如果为空，证明没有登录成功过，转到登录界面，否则打印登录成功提示信息</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>) &#123;<br>            response.sendRedirect(<span class="hljs-string">&quot;Login.html&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            response.getWriter().print(<span class="hljs-string">&quot;用户登录成功！&quot;</span>);<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="Session和-Cookie的区别"><a href="#Session和-Cookie的区别" class="headerlink" title="Session和 Cookie的区别"></a>Session和 Cookie的区别</h2><ol><li><p>从存储方式上比较</p><ul><li>Cookie只能存储字符串，如果要存储非ASCII字符串还要进行编码</li><li>Session可以存储任意类型的数据，相当于一个容器</li></ul></li><li><p>从隐私安全比较</p><ul><li>Cookie存储在浏览器，对客户端可见，信息容易泄漏出去，如果使用，最好进行加密</li><li>Session存储在服务器上，对客户端透明，不存在隐私泄漏问题</li></ul></li><li><p>从有效期上比较</p><ul><li>Cookie可以保存在硬盘上，只需要设置maxAge为比较大的正整数</li><li>Session保存在服务器中，设置maxInactiveInterval属性值来确定Session有效期，并且Session依赖于JSESSIONID的Cookie，该Cookie默认maxAge属性为-1，如果关闭了浏览器，该Session虽然没有从服务器中消亡，但也无法再使用，失效了</li></ul></li><li><p>从对服务器的负担比较</p><ul><li>Session是保存在服务器的，每个用户都会产生一个Session，如果并发访问量很大，是不能使用Session的，Session会占用大量内存</li><li>Cookie是保存在客户端的，不占用服务器资源，像一些大型网站，一般都会使用Cookie来进行会话跟踪</li></ul></li><li><p>从浏览器支持上比较</p><ul><li>如果浏览器禁用Cookie，Cookie就无法使用了</li><li>禁用Cookie，Session还可以通过URL地址重写来进行会话跟踪</li></ul></li><li><p>从跨域名上比较</p><ul><li>Cookie可以设置domain属性来实现跨域名</li><li>Session只在当前域名内有效，不可跨域名</li></ul></li></ol><p>如果仅仅使用Cookie或者Session达不到理想效果，那么可以两者结合来使用。</p><p>例如，做一个购物系统，使用Session来记录购买过的商品，当关闭浏览器时，购买记录就全部消失，这时候可以使用Cookie来保存购买记录。</p><p>总之，两者要灵活使用，以达到我们希望的效果。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-Cookie</title>
    <link href="/2022/05/11/JavaWeb/Servlet/9-Cookie/"/>
    <url>/2022/05/11/JavaWeb/Servlet/9-Cookie/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p>会话技术：访问一个网站，只要不关闭该浏览器，不管用户点击多少超链接，访问多少资源，直到用户关闭浏览器，整个过程称为一次会话。</p><p>会话跟踪技术可以解决很多问题</p><ul><li>在登录时，很多会问是否要自动登录，等下次登陆就不需要输入账户密码</li><li>根据我之前浏览的商品，猜我喜欢什么商品</li></ul><p>会话跟踪技术有Cookie和Session。先说Cookie。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>Cookie来自于Servlet规范中一个工具类</li><li>如果两个Servlet来自同一个网站，并且为同一个浏览器/用户服务，那么可以使用Cookie对象进行数据共享</li><li>cookie存放当前用户的私人数据，在共享数据过程中提高服务质量</li></ul><p>网页之间的交互通过HTTP协议来传输数据，但是HTTP协议是无状态的协议，意思是一旦数据提交完，浏览器和服务器连接关闭，再次交互的时候重新建立新的连接，所以服务器无法确认用户信息，所有W3C组织提出：给每个用户发一个通行证，无论谁访问的时候都需要携带通行证，服务器通过这个通行证来确认用户的信息，这个通行证就是Cookie。</p><p>Cookie的工作流程：<strong>浏览器访问数据库，如果服务器需要记录该用户的状态，就使用响应对象response向浏览器发送Cookie，可以一次添加多个Cookie，浏览器把Cookie保存起来，当浏览器再次访问服务器时，浏览器会把请求的网址连通Cookie一起交给服务器。</strong></p><p>响应对象将Cookie放在响应头中，浏览器请求时将Cookie放在请求头中。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p>Cookie类用于创建一个Cookie对象，一个Cookie只能放一个键值对，且类型只能为String，<strong>并且键值对中的value不能为中文。</strong></p><ul><li>在response接口中定义了一个<code>addCookie(Cookie cookie)</code>方法，它用于在其响应头中增加一个响应的Set-Cookie头字段</li><li>request接口定义了<code>getCookie()</code>方法，用于获取客户端提交的Cookie</li></ul><p>常用的Cookie方法：</p><ul><li>public Cookie(String name, String value)：Cookie的构造方法，name定义变量名，value定义变量值</li><li>setValue()和getValue方法</li><li>setMaxAge和getMaxAge方法</li><li>setPath和getPath方法</li><li>setDomain和getDomain方法</li><li>getName方法</li></ul><h2 id="使用Cookie"><a href="#使用Cookie" class="headerlink" title="使用Cookie"></a>使用Cookie</h2><p>首先创建Cookie对象，然后使用响应对象添加Cookie，代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">response.setContentType(<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span>);<br><span class="hljs-comment">//创建Cookie，指定名字和值</span><br><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;host&quot;</span>, “localhost<span class="hljs-string">&quot;)；</span><br><span class="hljs-string">response.addCookie(cookie);</span><br><span class="hljs-string">cookie.setMaxAge(1000);</span><br></code></pre></td></tr></table></figure><h2 id="Cookie的特性"><a href="#Cookie的特性" class="headerlink" title="Cookie的特性"></a>Cookie的特性</h2><h3 id="Cookie的不可跨域名性"><a href="#Cookie的不可跨域名性" class="headerlink" title="Cookie的不可跨域名性"></a>Cookie的不可跨域名性</h3><p>Cookie具有不可跨域名性，也就是说，浏览器判断一个网站能操作另一个网址的Cookie的一句是域名，例如在访问百度时，浏览器只会把百度给的Cookie发过去，但是不会带上Google的Cookie。</p><h3 id="Cookie保存中文"><a href="#Cookie保存中文" class="headerlink" title="Cookie保存中文"></a>Cookie保存中文</h3><p>中文字符属于Unicode字符集，Cookie使用Unicode字符时需要对Unicode字符进行编码，同样，在取出Cookie时同样需要使用UTF-8进行解码。可以使用<code>URLDecoder.encode(String value, &quot;UTF-8&quot;)</code>和<code>URLDecoder.decode(String value, &quot;UTF-8&quot;)</code>进行编码和解码。</p><h3 id="Cookie的有效期"><a href="#Cookie的有效期" class="headerlink" title="Cookie的有效期"></a>Cookie的有效期</h3><p>Cookie的有效期是通过setMaxAge()来设置的。</p><ul><li><p>如果MaxAge为正数，浏览器会把Cookie写到硬盘中，只要还在MaxAge秒之前，登陆浏览器时该Cookie就有效（不论关了浏览器还是电脑）</p></li><li><p>如果MaxAge为负数，Cookie就是临时性的，仅仅在本浏览器内有效，关闭了浏览器Cookie就会失效，Cookie也不会写入到硬盘</p></li><li><p>如果MaxAge为0，则表示删除该Cookie，Cookie机制没有提供删除Cookie对应方法，所以把MaxAge设置为0等同于删除Cookie</p></li></ul><p><strong>MaxAge默认值为-1。</strong></p><h3 id="Cookie的修改和删除"><a href="#Cookie的修改和删除" class="headerlink" title="Cookie的修改和删除"></a>Cookie的修改和删除</h3><p>Cookie机制没有提供修改Cookie的方法，那么要如何修改Cookie的值呢？</p><p>先来说说Cookie的存储方式，Cookie存储类似Map集合，name=value，是一个键值对，</p><p>Cookie的名称相同，通过response添加到浏览器，会覆盖掉原来的Cookie。</p><p>所以修改Cookie时，只需要创建一个和要修改的Cookie名称相同的Cookie，value为想修改的值即可。</p><p>删除Cookie，就可以把名称相同的Cookie的MaxAge设为0，添加到浏览器，就可以实现修改。</p><p><strong>注意：新建的Cookie除了value、maxAge之外的其他所有属性都要和原来的Cookie相同，否则浏览器会视为不同的Cookie，不会覆盖，导致修改删除失败。</strong></p><h3 id="Cookie的域名"><a href="#Cookie的域名" class="headerlink" title="Cookie的域名"></a>Cookie的域名</h3><p>Cookie的domain属性决定了运行访问的域名，domain的值格式规定为”.域名”</p><ul><li>Cookie的隐私安全机制决定Cookie是不可跨域名的，也就是说www.baidu.com和www.google.com之间的Cookie互不影响，没有关系。并且即使同一级域名，不同二级域名也不能交接，也就是说：www.google.com和www.image.google.com的Cookie也不能互相访问</li></ul><p>如果希望一级域名相同的网页Cookie时间可以相互访问，就需要使用domain方法</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;zhaodaxin&quot;</span>);<br>cookie.setMaxAge(<span class="hljs-number">1000</span>);<br>cookie.setDomain(<span class="hljs-string">&quot;.google.com&quot;</span>);<br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><p>即  使用<code>cookie.setDomain()</code>来进行设置。</p><h3 id="Cookie的路径"><a href="#Cookie的路径" class="headerlink" title="Cookie的路径"></a>Cookie的路径</h3><p>Cookie的path属性决定允许访问Cookie的路径，如果值为”/“即代表所有网页的资源都可以访问Cookie，现在如果只想Servlet1可以获取到Cookie，其他资源都不可以获取，那么代码应该为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>);<br>Cookie.setPath(<span class="hljs-string">&quot;/Servlet1&quot;</span>);<br>cookie.setMaxAge(<span class="hljs-number">1000</span>);<br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure><p>使用<code>cookie.setPath()</code>来进行设置。</p><h2 id="Cookie的安全属性"><a href="#Cookie的安全属性" class="headerlink" title="Cookie的安全属性"></a>Cookie的安全属性</h2><p>HTTP协议不仅仅是无状态的，也是不安全的。如果不希望Cookie在非安全协议中传输，可以设置Cookie的secure属性为true，那么浏览器只会在HTTPS和SSL等安全协议中进行传输。</p><p>设置secure属性为true不会将Cookie的内容加密，如果想保证安全，最好是用md5算法加密。</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h3 id="显示上次用户访问时间"><a href="#显示上次用户访问时间" class="headerlink" title="显示上次用户访问时间"></a>显示上次用户访问时间</h3><ul><li><p>核心逻辑就是在每次登陆的时候，取到Cookie保存的上次访问时间，然后先输出上次访问时间，再更新这个值</p></li><li><p>访问Servlet只有两种情况:</p><pre><code class="hljs">                                  1. 第一次访问 2. 已经访问过了</code></pre></li></ul><p>​    </p><pre><code class="hljs">所以需要判断一下是第一次访问，还是已经访问过了代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OneServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <br>            <span class="hljs-comment">//创建日期格式字符串</span><br>            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">sdf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd-HH:mm:ss&quot;</span>);<br>            response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>            response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br>    <br>            <span class="hljs-comment">//获得Cookie数组</span><br>            Cookie[] cookies = request.getCookies();<br>    <br>            <span class="hljs-comment">//初始日期值为null</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">cookieValue</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cookies != <span class="hljs-literal">null</span> &amp;&amp; i &lt; cookies.length; i++) &#123;<br>                <span class="hljs-keyword">if</span>(cookies[i].getName().equals(<span class="hljs-string">&quot;time&quot;</span>)) &#123;<br>                    cookieValue = cookies[i].getValue();<br>                    out.print(<span class="hljs-string">&quot;上次访问的时间为：&quot;</span> + cookieValue);<br>                    cookies[i].setValue(sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>                    response.addCookie(cookies[i]);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>    <br>            <span class="hljs-comment">//如果没有日期值，那么cookieValue为null</span><br>            <span class="hljs-keyword">if</span>(cookieValue == <span class="hljs-literal">null</span>) &#123;<br>                out.print(<span class="hljs-string">&quot;这是第一次访问&quot;</span>);<br>                <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;time&quot;</span>, sdf.format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>                cookie.setMaxAge(<span class="hljs-number">20000</span>);<br>                response.addCookie(cookie);<br>            &#125;<br><br><br>​    <br>​        &#125;<br>​    &#125;<br>​    ```<br><br><br>​    <br><br><br><br>#### 显示用户上次访问的商品<br><br>以书籍为例子，先定义一个Book类和一个Books类：<br><br>```java<br><span class="hljs-comment">//Book类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String author;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String id, String name, String author)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.author = author;<br>    &#125;<br>    <br>    /set和get方法...<br>&#125;    <br><br><br><span class="hljs-comment">//Books类</span><br><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Books</span> &#123;<br><br>    <span class="hljs-comment">//使用LinkedHashMap存放书籍和对应的序号id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> LinkedHashMap&lt;String, Book&gt; books = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        books.put(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;javaweb&quot;</span>, <span class="hljs-string">&quot;zhong&quot;</span>));<br>        books.put(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;fu&quot;</span>));<br>        books.put(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;oracle&quot;</span>, <span class="hljs-string">&quot;cheng&quot;</span>));<br>        books.put(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;ou&quot;</span>));<br>        books.put(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;ajax&quot;</span>, <span class="hljs-string">&quot;zi&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">//获取所有书籍信息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LinkedHashMap&lt;String, Book&gt; <span class="hljs-title function_">getBooks</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> books;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><p>BooksSevlet负责输出所有书籍，并附上超链接，链接到OneServlet，点击显示书籍详细信息，并添加或者修改Cookie，Cookie名称为“bookHistory”,最多存放三本书籍id，id之间使用”_”连接，OneServlet首先显示对应书籍信息，然后添加或者修改对应Cookie，BooksServlet除了负责输出所有书籍，还需要获取浏览器发来的bookHistory对应Cookie，然后将id对应书籍显示出来。</p><p>代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//BooksServlet</span><br><br><span class="hljs-keyword">package</span> controller;<br><br><span class="hljs-keyword">import</span> entity.Book;<br><span class="hljs-keyword">import</span> entity.Books;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BooksServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        response.setContentType(<span class="hljs-string">&quot;text/html;charset=utf-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br><br>        LinkedHashMap&lt;String, Book&gt; books = Books.getBooks();<br>        Set&lt;Map.Entry&lt;String, Book&gt;&gt; entries = books.entrySet();<br>        out.print(<span class="hljs-string">&quot;&lt;h1&gt;网页上所有的书籍：&lt;/h1&gt;&lt;br&gt;&lt;ol&gt;&quot;</span>);<br>        <span class="hljs-keyword">for</span>(Map.Entry&lt;String, Book&gt; bookEntry : entries) &#123;<br>            <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> bookEntry.getValue();<br>            out.print(<span class="hljs-string">&quot;&lt;li&gt;&lt;a href=&#x27;/myweb/one?id=&quot;</span>+ book.getId() + <span class="hljs-string">&quot;&#x27; target=&#x27;_blank&#x27;&gt;&quot;</span> + book.getName() + <span class="hljs-string">&quot;&lt;/a&gt;&lt;/li&gt;&quot;</span>);<br>        &#125;<br>        out.print(<span class="hljs-string">&quot;&lt;/ul&gt;&lt;hr&gt;&quot;</span>);<br><br>        Cookie[] cookies = request.getCookies();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bookHistory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cookies != <span class="hljs-literal">null</span> &amp;&amp; i &lt; cookies.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cookies[i].getName().equals(<span class="hljs-string">&quot;bookHistory&quot;</span>)) &#123;<br>                bookHistory = cookies[i].getValue();<br>            &#125;<br>        &#125;<br><br>        out.print(<span class="hljs-string">&quot;&lt;h4&gt;您曾经浏览过的书籍：&lt;/h4&gt;&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(bookHistory != <span class="hljs-literal">null</span>) &#123;<br>            out.print(<span class="hljs-string">&quot;&lt;ul&gt;&quot;</span>);<br><br>            String[] strings = bookHistory.split(<span class="hljs-string">&quot;_&quot;</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; strings.length; i++) &#123;<br>                out.print(<span class="hljs-string">&quot;&lt;li&gt;&quot;</span> + books.get(strings[i]).getName() +<span class="hljs-string">&quot;&lt;/li&gt;&quot;</span>);<br>            &#125;<br>            out.print(<span class="hljs-string">&quot;&lt;/ul&gt;&quot;</span>);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><br><br><br><br><br><span class="hljs-comment">//OneServlet</span><br><br><span class="hljs-keyword">package</span> controller;<br><br><span class="hljs-keyword">import</span> entity.Book;<br><span class="hljs-keyword">import</span> entity.Books;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.Cookie;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.logging.SimpleFormatter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OneServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br><br><br>    <span class="hljs-comment">//该方法用于获取添加或修改Cookie对应的bookHistory值</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">makeHistory</span><span class="hljs-params">(HttpServletRequest request, String id)</span> &#123;<br><br>        Cookie[] cookies = request.getCookies();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bookHistory</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; cookies != <span class="hljs-literal">null</span> &amp;&amp; i &lt; cookies.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(cookies[i].getName().equals(<span class="hljs-string">&quot;bookHistory&quot;</span>)) &#123;<br>                bookHistory = cookies[i].getValue();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//如果不存在该Cookie，那么就直接添加id</span><br>        <span class="hljs-keyword">if</span>(bookHistory == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> id;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String[] strings = bookHistory.split(<span class="hljs-string">&quot;_&quot;</span>);<br><br>            <span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Arrays.asList(strings);<br>            LinkedList&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>            linkedList.addAll(list);<br><br>            <span class="hljs-comment">//如果已经存在该id，那么删除，并重新放到第一个位置</span><br>            <span class="hljs-keyword">if</span>(linkedList.contains(id)) &#123;<br>                linkedList.remove(id);<br>                linkedList.addFirst(id);<br>            &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果不存在，那么如果已经存在三个id，删除最后一个，并将该id添加到第一个</span><br>                <span class="hljs-keyword">if</span>(linkedList.size() &gt;= <span class="hljs-number">3</span>) &#123;<br>                    linkedList.removeLast();<br>                    linkedList.addFirst(id);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    linkedList.addFirst(id);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">//连接字符串</span><br>            bookHistory = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; linkedList.size() - <span class="hljs-number">1</span>; i++) &#123;<br>                bookHistory = bookHistory + linkedList.get(i) + <span class="hljs-string">&quot;_&quot;</span>;<br>            &#125;<br>            bookHistory = bookHistory + linkedList.getLast();<br>            <span class="hljs-keyword">return</span> bookHistory;<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>        response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br>        response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> request.getParameter(<span class="hljs-string">&quot;id&quot;</span>);<br>        <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Book) Books.getBooks().get(id);<br>        out.print(<span class="hljs-string">&quot;&lt;h3&gt;书的编号为：&quot;</span> + book.getId() + <span class="hljs-string">&quot;&lt;/h3&gt;&quot;</span>);<br>        out.print(<span class="hljs-string">&quot;&lt;h3&gt;书的名称为：&quot;</span> + book.getName() + <span class="hljs-string">&quot;&lt;/h3&gt;&quot;</span>);<br>        out.print(<span class="hljs-string">&quot;&lt;h3&gt;书的作者为：&quot;</span> + book.getAuthor() + <span class="hljs-string">&quot;&lt;/h3&gt;&quot;</span>);<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">bookHistory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.makeHistory(request, id);<br><br>        <span class="hljs-comment">//如果Cookie名称相同，会覆盖先前的Cookie，所以可以直接添加新的</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cookie</span>(<span class="hljs-string">&quot;bookHistory&quot;</span>, bookHistory);<br>        cookie.setMaxAge(<span class="hljs-number">20000</span>);<br>        response.addCookie(cookie);<br><br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-ServletContext接口</title>
    <link href="/2022/05/11/JavaWeb/Servlet/8-ServletContext%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/05/11/JavaWeb/Servlet/8-ServletContext%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当Tomcat启动时，就会创建一个ServletContext对象，它代表着当前web站点，该网站所有Servlet共享一个ServletContext对象，所有Servlet对象之间可以通过ServletContext实现通讯。</p><p>ServletContext对象被称为域对象，或者全局作用域对象，可以把它理解为一个容器，我们把需要共享的数据放到这个容器中，需要对应数据的Servlet对象就从这个容器中拿。</p><p>实现Servlet通讯要用ServletContext的<code>setAttribute(String name, Object obj)</code>方法，第一个参数为变量名，第二个参数为变量值；然后使用<code>servletContext.getAttribute(String name)</code>获取指定变量值，需要强制类型转换，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一个Servlet代码</span><br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;HAHAHAH&quot;</span>;<br>servletContext.setAttribute(<span class="hljs-string">&quot;Name&quot;</span>, value);<br><br><span class="hljs-comment">//第二个Servlet代码</span><br><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> servletContext = (String)servletContext.getAttribute(<span class="hljs-string">&quot;name&quot;</span>);<br></code></pre></td></tr></table></figure><h4 id="获取web站点配置的信息"><a href="#获取web站点配置的信息" class="headerlink" title="获取web站点配置的信息"></a>获取web站点配置的信息</h4><p>如果想要让所有Servlet都能够获取连接数据库的信息，不可能在web.xml给每个Servlet都配置，太麻烦，web.xml文件支持对整个站点进行配置参数信息，所有的Servlet都可以拿到该配置信息。</p><p>例如：<br>web.xml的内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>name<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>HAHAHA<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Servlet的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ServletContext</span> <span class="hljs-variable">servletContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getServletContext();<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> servletContext.getInitParameter(<span class="hljs-string">&quot;name&quot;</span>);<br>System.out.println(value);<br></code></pre></td></tr></table></figure><p>获取web.xml配置参数时，要使用getInitParameter(String name)方法。</p><h4 id="ServletContext的生命周期"><a href="#ServletContext的生命周期" class="headerlink" title="ServletContext的生命周期"></a>ServletContext的生命周期</h4><ul><li>当Tomcat启动过程中，自动为当前网站在内存中创建一个ServletContext对象</li><li>在Http服务器运行期间，一个网站只有一个ServletContext对象，并且一直处于存活状态</li><li>当Http服务器准备关闭时，负责将当前网站中ServletContext对象进行销毁</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-HttpServletRequest进行数据共享</title>
    <link href="/2022/05/11/JavaWeb/Servlet/7-%E4%BD%BF%E7%94%A8HttpServletRequest%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/"/>
    <url>/2022/05/11/JavaWeb/Servlet/7-%E4%BD%BF%E7%94%A8HttpServletRequest%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>request对象也是一个域对象，即在一个范围内，可以进行共享。</p><p>在一次请求中，利用请求转发进行多个Servlet调用时，使用的是同一个request对象，这时候，就可以利用该对象进行数据共享。</p><h2 id="HttpServletRequest相关API"><a href="#HttpServletRequest相关API" class="headerlink" title="HttpServletRequest相关API"></a>HttpServletRequest相关API</h2><p>有两个最主要方法进行数据共享</p><ul><li>void setAttribute(String s, Object o)：指定名字和任意数据类型的数据存入到request中</li><li>Object getAttribute(String s)：获取名为s的数据</li></ul><p>在request内部维护着一个Map集合，可以存放数据。</p><p>这个简单，没有例子！Yeah～</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-多个Servlet调用规则和数据共享</title>
    <link href="/2022/05/11/JavaWeb/Servlet/6-%E5%A4%9A%E4%B8%AAServlet%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/"/>
    <url>/2022/05/11/JavaWeb/Servlet/6-%E5%A4%9A%E4%B8%AAServlet%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99%E5%92%8C%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>某些来自浏览器的请求，往往需要服务端多个Servlet协同处理，但是浏览器一次只能访问一个Servlet，导致用户需要手动操作浏览器发起多次请求才能得到服务，这样增加了服务的难度，为了提供用户使用感受，所以要求无论本次请求涉及了多少Servlet，用户只需要手动通知浏览器发起一次请求即可。</p><h2 id="多个Servlet之间的调用规则"><a href="#多个Servlet之间的调用规则" class="headerlink" title="多个Servlet之间的调用规则"></a>多个Servlet之间的调用规则</h2><p>有两种解决方案：</p><ul><li>重定向解决方案</li><li>请求转发解决方案</li></ul><h3 id="重定向解决方案"><a href="#重定向解决方案" class="headerlink" title="重定向解决方案"></a>重定向解决方案</h3><p>工作原理：用户手动发送一次请求，第一个Servlet工作完成后，通过重定向方法将第二个Servlet地址写入到响应头location中，然后tomcat将302状态码写入到状态行，然后第二个Servlet继续工作，以此类推。</p><p>实现命令：response.sendRedirect(“地址”)</p><p>由于是通过地址栏通知浏览器发起下一次请求，因此请求方式一定是GET</p><p>缺点：进行多次往返，大量时间被消耗在往返上，增加用户等待时间：重定向解决方案需要在浏览器和服务器之间</p><h3 id="请求转发解决方案"><a href="#请求转发解决方案" class="headerlink" title="请求转发解决方案"></a>请求转发解决方案</h3><p>工作原理：用户第一次通过手动要求浏览器访问OneServlet，然后OneServlet工作完毕后，通过当前的请求对象代替浏览器向Tomcat发送请求，调用TwoServlet，然后Tomcat调用TwoServlet</p><p>实现命令：请求对象代替浏览器向Tomcat发送请求，</p><ol><li><p>通过当前对象生成资源文件申请报告对象，RequestDispatcher report = request.getRequestDispatcher(“/资源文件名”)；一定要以”/“开头</p></li><li><p>将报告对象发送给Tomcat</p><p>report.forward(“当前请求对象”，”当前响应对象”);</p><p>请求的方式由第一次浏览器发送请求的方式相同，即和浏览器的发送请求方式保持一致，因为所有Servlet共享一个请求协议包</p></li></ol><pre><code class="hljs">  优点：无论需要调用多少Servlet，用户只需要手动发送一次请求  ​                Servlet之间互相调用发生在服务端计算机，节省了服务端和浏览器之间的请求时间  **注意：**Http服务器只能调用当前网站的资源文件  特点：  - 浏览器只发送一次请求  ## 总结  简单来说，重定向方案就是浏览器发送一次请求，然后第一个Servlet执行完毕，通知浏览器去访问第二个Servlet，然后浏览器接着再次发送请求，以此类推；  而请求转发方案就是浏览器发送一次请求，然后第一个Servlet执行完毕，不需要通知浏览器去访问下一个Servlet，而是直接去调用下一个Servlet。  ## 多个Servlet之间的数据共享实现方案  所谓数据共享，就是第一个Servlet执行完后，将产生的数据交给下一个Servlet来处理  Servlet规范一共提供了四种数据共享方案  1. ServletContext接口  2. Cookie类  3. HttpSession接口  4. HttpServletRequest接口</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-请求、响应对象的生命周期和状态码</title>
    <link href="/2022/05/11/JavaWeb/Servlet/4-%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/11/JavaWeb/Servlet/4-%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%93%8D%E5%BA%94%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="请求、响应对象的生命周期"><a href="#请求、响应对象的生命周期" class="headerlink" title="请求、响应对象的生命周期"></a>请求、响应对象的生命周期</h1><p>当服务器收到Http请求协议包后，会创建请求对象和响应对象，当调用doGet或者doPost方法时，将生成的两个对象传入。</p><p>当doGet或者doPost方法执行完毕后，Http服务器准备将Http响应协议包推送给浏览器之前，负责将本次请求关联的请求对象和响应对象销毁。</p><p>所有请求对象和响应对象的生命周期贯穿一次请求的整个处理过程中，请求开始，两个对象会创建，请求结束，对象被销毁。</p><h1 id="Http状态码"><a href="#Http状态码" class="headerlink" title="Http状态码"></a>Http状态码</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Http状态码是由三位数字组成的符号，Http服务器会在推送响应包之前，根据本次请求处理的情况，将Http状态码写入到响应包中的状态行上。</p><p>如果 Http服务器针对本次请求，返回了对应的资源文件，通过Http服务器通知浏览器应该如何处理这个结果；</p><p>如果 Http服务器针对本次请求，无法返回对应的资源文件，通过Http服务器向浏览器解释不能提供服务的原因。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>Http状态码的范围为100-599，分为5个大类。</p><ul><li><p>1XX：</p><p>  ​        最有特征是100：通知浏览器本次返回的资源文件不是一个独立的资源文件，需要浏览器接受响应包后，继续向Http服务器索要依赖的其他资源文件</p></li><li><p>2XX：</p><p>  ​        最有特征200：通知浏览器本次返回的资源文件是一个完整独立资源文件，浏览器接收后，不需要请求其他关联文件</p></li><li><p>3XX：</p><p>  ​        最有特征302：通知浏览器本次返回的不是一个资源文件内容，而是一个资源文件地址，需要浏览器根据地址自动发  起请求来索要这个资源文件，例如<code>response.sendRedirect(&quot;地址&quot;)</code>写入到响应头location中</p></li><li><p>4XX:</p><p>  ​        404：由于在服务端没有定位到被访问的资源文件，因此不能提供</p><p>  ​        405：在服务器定位到了被访问的资源文件(Servlet)，但是这个Servlet对于浏览器采用的请求方式不能处理</p></li><li><p>5XX：</p><p>  ​        500：通知浏览器，在服务端已经定位到了被访问的资源文件(Servlet),这个Servlet也可以接收浏览器采用的请求方式，但是Servlet在处理请求期间，由于Java异常导致处理失败</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-HttpServletResponse接口</title>
    <link href="/2022/05/11/JavaWeb/Servlet/3-HttpServletResponse%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/05/11/JavaWeb/Servlet/3-HttpServletResponse%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>HttpServletResponse接口实现类由Http服务器提供</li><li>HttpServletResponse接口将doGet/doPost方法执行结果写入到 响应体交给浏览器</li><li>由HttpServletResponse接口修饰的对象称为响应对象</li></ul><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul><li>将执行结果以二进制写入到响应体</li><li>设置响应头中 [content-type]属性值，从而控制浏览器使用对应的编译器将响应体二进制数据编译为对应文件</li><li>设置响应头中[location]属性，将一个请求对象赋值给location，从而控制浏览器向指定服务器发送请求</li></ul><p>使用响应对象来获得输出流，例如<code>PrintWriter out = resp.getWriter();</code>，然后可以使用out对象的write和print方法来进行输出，但一般都使用print方法，不使用write方法。</p><p>默认情况下，响应体的content-type属性为 “text”,即文本，浏览器会将输出的内容解析成文本，如果想要输出其他内容例如HTML，那么<strong>一定要在得到输出流之前，通过响应对象对响应体中的content-type属性改为想要输出的文本格式</strong>。</p><p>可以使用<code>resp.setContentype(&quot;text/html&quot;)</code>和<code>resp.setCharacterEncoding(&quot;UTF-8&quot;);</code>两个方法对响应体的文件解析格式和编码方式进行设置。</p><h3 id="使用响应对象的sendRedirect-方法进行地址重定向"><a href="#使用响应对象的sendRedirect-方法进行地址重定向" class="headerlink" title="使用响应对象的sendRedirect()方法进行地址重定向"></a>使用响应对象的sendRedirect()方法进行地址重定向</h3><p>响应对象response有一个sendRedirect方法，可以使用该方法指定浏览器对该地址进行访问，当浏览器收到响应体后，发现有location属性，会自动访问location对应的地址。同样可以使用该方法控制访问的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br><br>    <span class="hljs-comment">//重定向的地址,也可以加参数例如：http://www.baidu.com?userName=mike</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://www.baidu.com&quot;</span>;<br>        resp.sendRedirect(result);<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p>运行上述代码结果为：</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/image-20200803140222729.png" alt="image-20200803140222729"></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-HttpServletRequest接口</title>
    <link href="/2022/05/11/JavaWeb/Servlet/2-HttpServletRequest%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/05/11/JavaWeb/Servlet/2-HttpServletRequest%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ul><li>HttpServletRequest接口是由Http服务器负责提供</li><li>HttpServletRequest接口负责在doGet/doPost方法运行时读取Http协议包中的信息</li><li>用HttpServletRequest接口修饰的对象叫做请求对象</li></ul><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>可以读取Http请求协议包中 请求行的信息</li><li>可以读取Http请求包中 请求头或者 请求体</li><li>可以代替浏览器向服务器申请资源文件调用</li></ul><p>可以使用该请求对象的一系列getXXX()方法来获取请求协议包的信息，例如使用getRequestURL()、getMethod()可以获得请求的URL地址和请求方式。</p><p>使用<code>request.getParameterNames()</code>来获取所有参数的名称，使用<code>request.getParameter(parameterName)</code>来获取对应变量的值。</p><p>Get和Post方式对应的doGet和doPost方法使用方法基本一样，<strong>但有一些差别：浏览器以Get方式发送请求，参数保存在请求头中，以Post方法发送请求，参数保存在请求体中</strong>。</p><p>请求头中二进制内容由Tomcat解码，Tomcat9.0默认使用UTF-8进行解码，请求体中二进制内容由当前request对象负责解码，<strong>request默认使用 ISO-8859-1解码，无法解码中文。</strong></p><p>所以<strong>在Post请求方式下，在读取请求体中内容之前</strong>，要让请求对象使用utf-8字符集进行解码，使用<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code>，即可改变字符集为UTF-8。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-使用Servlet接口开发类开发</title>
    <link href="/2022/05/11/JavaWeb/Servlet/1-%E4%BD%BF%E7%94%A8Servlet%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E7%B1%BB%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/"/>
    <url>/2022/05/11/JavaWeb/Servlet/1-%E4%BD%BF%E7%94%A8Servlet%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E7%B1%BB%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一共有三步：</p><ol><li><p>创建一个类继承HttpServlet实现类，使之成为Servlet接口实现类</p></li><li><p>重写HttpServlet父类两个方法，doGet或者doPost</p><p> ​    浏览器使用get方式——&gt;Servlet.doGet()</p><p> ​    浏览器使用post方式—-&gt;Servlet.doPost()</p></li><li><p>将Servlet接口实现类信息<strong>注册</strong>到Tomcat服务器</p><p> ​    在web文件夹中找到web.xml文件，在该文件里注册实现类信息</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-comment">&lt;!--声明一个变量名称存储servlet实现类类路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-comment">&lt;!--声明servlet接口路径--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 然后tomcat服务器会使用name和class路径来存储Servlet实现类路径</p></li></ol><pre><code class="hljs">用户在访问实现类时需要写完整的类路径，这样太麻烦，为了降低用户访问Servlet接口实现类难度，需要设置简短的请求别名<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-comment">&lt;!--这是在上面servlet标签中，和servlet-name一样--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><span class="hljs-comment">&lt;!--设置简短的请求别名，在书写时必须以&quot;/&quot;开头--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure></code></pre><h2 id="Servlet对象生命周期"><a href="#Servlet对象生命周期" class="headerlink" title="Servlet对象生命周期"></a>Servlet对象生命周期</h2><ol><li><p>网站中所有Servlet实现类实例对象，只能由Http服务器负责创建，开发人员不能手动创建</p></li><li><p>在默认情况下，Http服务器接收到对于当前Servlet接口实现类第一次请求时自动创建这个实现类的实例对象，如果没有请求，那么则不会创建该实例对象</p></li></ol><pre><code class="hljs">在手动配置下，可以要求Http服务器在启动时自动创建某个实现类实例对象<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><span class="hljs-comment">&lt;!--声明一个变量名称存储servlet实现类类路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><span class="hljs-comment">&lt;!--声明servlet接口路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><span class="hljs-comment">&lt;!--填写一个大于0的整数，默认值为0--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure>​    使用load-on-startup标签来设置当服务器启动时创建实例对象</code></pre><ol><li><p>在Http服务器运行过程中，一个Servlet接口实现类只能创建出一个实例对象，如果有多个请求访问该实例对象，也只会创建一个，多个请求访问这一个，即单例多线程</p></li><li><p>在Http服务器关闭时，所有的Servlet对象都会被销毁</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>JavaWeb</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaWeb</tag>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Aplayer的使用</title>
    <link href="/2022/05/11/Aplayer%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/05/11/Aplayer%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我希望在使用Hexo的个人博客中加入背景音乐，最后找到Aplayer工具。这里说下Aplayer的使用。</p><h3 id="引入文件并创建Aplayer对象"><a href="#引入文件并创建Aplayer对象" class="headerlink" title="引入文件并创建Aplayer对象"></a>引入文件并创建Aplayer对象</h3><p>首先引入Aplayer的Js和Css文件，代码如下。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;APlayer.min.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;aplayer&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;APlayer.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在想要插入的页面位置对应的代码中插入这段代码。</p><p>因为我不想让音乐播放器界面在博客界面显示，所以我把div对象的css属性<code>display</code>设为<code>none</code>。</p><p>然后在页面上方导航栏加入播放按钮，这样就可以在不显示音乐播放器的情况下播放和暂停音乐。</p><p>我使用的主题是fluid，该主题可以自定义页脚的html，所以我将上述代码加入到fluid配置文件中的对应位置。</p><p>然后在主题文件夹的source文件夹中，创建music.js文件，创建Aplayer对象，代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">APlayer</span>(&#123;<br>    <span class="hljs-attr">container</span>: <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;aplayer&#x27;</span>),<br>    <span class="hljs-attr">mini</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">autoplay</span>:<span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">loop</span>:<span class="hljs-string">&#x27;one&#x27;</span>,<br>   <span class="hljs-attr">volume</span>:<span class="hljs-number">0.2</span>,<br>    <span class="hljs-attr">audio</span>: [&#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">artist</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-attr">cover</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    &#125;]<br>&#125;);<br><br><span class="hljs-keyword">let</span> isPlaying = <span class="hljs-literal">false</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByClassName</span>(<span class="hljs-string">&quot;nav-link&quot;</span>)[<span class="hljs-number">5</span>].<span class="hljs-property">onclick</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">if</span>(!isPlaying) &#123;<br>ap.<span class="hljs-title function_">play</span>();<br>isPlaying = <span class="hljs-literal">true</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;i class=&quot;iconfont icon-music&quot;&gt;&lt;/i&gt; 暂停&#x27;</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ap.<span class="hljs-title function_">pause</span>();<br>isPlaying = <span class="hljs-literal">false</span>;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;&lt;i class=&quot;iconfont icon-music&quot;&gt;&lt;/i&gt; 播放&#x27;</span>;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>其中，上面的创建Aplayer对象是从Aplayer官网复制的，audio属性中的name、artist、url和cover分别代表歌曲名称、歌手、歌曲链接地址和歌曲封面。</p><p>下面的代码是我自己写的，其中的<code>document.getElementsByClassName(&quot;nav-link&quot;)[5]</code>就是播放按钮对象，这样写其实是比较偷懒的写法，不过我导航栏的结果一般也不会再变动，所以直接写<code>[5]</code>也没啥问题。</p><p><code>ap.play()</code>和<code>ap.pause()</code>分别代表歌曲的播放和暂停。</p><p>然后将music.js文件路径添加到fluid主题配置文件中的<code>custom_js</code>下，这样网站加载时就会引入该文件。</p><h3 id="歌曲链接地址"><a href="#歌曲链接地址" class="headerlink" title="歌曲链接地址"></a>歌曲链接地址</h3><p>在尝试找了众多音乐网站的外链地址后，我放弃了。大多数地址都无法使用，我也不知道怎么搞的。</p><p>而且很多音乐网站也没有我想要的音乐资源。</p><p>最后使用的方法是，我把想要播放的音乐文件下载到本地，但如果直接引入本地的音乐地址，网站加载会慢很多，因为大多数音乐文件还是比较大的。</p><p>所以我将文件上传到腾讯云的对象存储中，然后在url中填入对象存储生成的文件链接地址。</p><p>因为不显示音乐播放器，所以name、artist和cover不需要填。</p><p>在做完这些后，使用<code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</code>，重新生成文件并部署到服务器。</p><p>最后，就可以享受边浏览博客，边听音乐的乐趣啦。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程组和未处理的异常</title>
    <link href="/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E6%9C%AA%E5%A4%84%E7%90%86%E7%9A%84%E5%BC%82%E5%B8%B8/"/>
    <url>/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%92%8C%E6%9C%AA%E5%A4%84%E7%90%86%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理。对线程组的控制相当于同时控制这批线程，用户创建的所有线程都属于指定线程组，如果程序没有显式指定线程属于哪个线程组，则该线程属于默认线程组。默认情况下，子线程属于父线程所在的线程组。</p><p><strong>一旦某个线程加入了指定线程组后，该线程将一直属于该线程组，直到该线程死亡，线程运行过程中不允许更改线程组。</strong></p><p>Thread类提供了几个构造器来设置新创建的线程属于哪个线程组。</p><ul><li>Thread(ThreadGroup group, Runnable target)：以target的run方法作为线程执行体创建新线程，属于group线程组</li><li>Thread(ThreadGroup group, Runnable target, String name)：以target的run方法作为线程执行体创建新线程，该线程属于group线程组，且线程名为name</li><li><p>Thread(ThreadGroup group, String name)：创建新线程，线程名为name，线程组为group</p><p>此外，Thread类提供了getThreadGroup()方法来获得线程所在线程组。</p></li></ul><p>ThreadGroup类提供了两个构造器：</p><ul><li>ThreadGroup(String name)：以指定线程组名字来创建新的线程组名称</li><li>ThreadGroup(ThreadGroup parent, String name)：以指定的名字、指定的父线程组创建一个线程组</li></ul><p>线程组总会有一个字符串类型的名字，该名字可通过ThreadGroup类的getName方法获得，但不允许更改名字。</p><p>ThreadGroup类提供了几个常用方法来操作整个线程组里的所有线程</p><ul><li>int activeCount()：返回该线程组所有活动线程的数目</li><li>interrupt()：中断此线程组的所有线程</li><li>isDaemon()：判断该线程组是否为后台线程组</li><li>setDaemon()：把该线程组设置为后台线程组，后台线程组有一个特征：当后台线程组的最后一个线程执行结束或者被销毁后，后台线程组将自动销毁</li><li>setPriority(int pri)：设置线程组的最高优先级</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> work;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>        <span class="hljs-comment">//获得默认线程组也就是主线程所在线程组</span><br>        <span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">mainGroup</span> <span class="hljs-operator">=</span> Thread.currentThread().getThreadGroup();<br><br>        System.out.println(<span class="hljs-string">&quot;主线程组的名字为：&quot;</span> + mainGroup.getName());<br>        System.out.println(<span class="hljs-string">&quot;主线程组是否为后台线程组：&quot;</span> + mainGroup.isDaemon());<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;主线程组的线程&quot;</span>).start();<br>        <span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">tg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;新线程组&quot;</span>);<br>        tg.setDaemon(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;tg线程组是否为后台线程组：&quot;</span> + tg.isDaemon());<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(<span class="hljs-string">&quot;tg组的线程甲&quot;</span>);<br>        tt.start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>(tg, <span class="hljs-string">&quot;tg组的线程乙&quot;</span>).start();<br><br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(String name)</span> &#123;<br><br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThread</span><span class="hljs-params">(ThreadGroup group, String name)</span> &#123;<br><br>        <span class="hljs-built_in">super</span>(group, name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            System.out.println(getName() + <span class="hljs-string">&quot;线程的i变量&quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><p>ThreadGroup线程组还定义了一个方法：void uncaughtException(Thread t, Throwable e)：可以处理该线程组内的任意线程所抛出的未处理异常。</p><p>从Java 5开始，Java加强了线程的异常处理，如果线程执行过程中抛出了一个未处理异常，JVM在结束该线程之前，会自动查找是否有对应的Thread.UncaughtExceptionHandler对象，如果找到该处理器对象，则会调用该对象uncaughtException(Thread t, Throwable e)方法来处理该异常</p><p>Thread.uncaughtExceptionHandler是Thread类的一个静态内部接口，该接口内只有一个方法：void uncaughtException(Thread t, Throwable e)，方法中t代表出现异常的线程，而e代表该线程抛出的异常。</p><p>Thread类提供了两个方法来设置异常处理器</p><ul><li>static setDefaultUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为该线程类的所有实例线程设置默认的异常处理器</li><li>setUncaughtExceptionHandler(Thread.UncaughtExceptionHandler eh)：为指定线程实例设置异常处理器</li></ul><p>ThreadGroup类实现了Thread.UncaughtExceptionHandler接口，所以每个线程所属的线程组将会作为默认的异常处理器。</p><p><strong>当一个线程抛出未处理异常时，JVM会首先查找该异常对应的异常处理器(即使用setUncaughtExceptionHandler设置的异常处理器)，进行异常处理，如果没找到，JVM会调用该线程所属的线程组对象的uncaughtException()方法来处理该异常,线程组处理异常的流程为：</strong></p><ol><li>如果该线程组有父线程组，则调用父线程的uncaughtException()方法处理</li><li>如果该线程实例所属线程类由默认异常处理器(由setDefaultUncaughtExceptionHandler设置的异常处理器)，那么就调用该异常处理器来处理</li><li>如果该异常对象是ThreadDeath的对象，则不做任何处理，否则将异常跟踪栈打印到System.err错误输出流，并结束该线程。</li></ol><p>例子：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">package</span> work;<br><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br><br><span class="hljs-comment">//设置当前线程的异常处理器对象</span><br>            Thread.currentThread().setUncaughtExceptionHandler(<span class="hljs-keyword">new</span> MyExHandler());<br><br>            <span class="hljs-keyword">int</span> a = <span class="hljs-number">5</span> / <span class="hljs-number">0</span>;<br>            System.out.println(<span class="hljs-string">&quot;程序正常结束&quot;</span>);<br><br><br>    &#125;<br><br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyExHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Thread</span>.<span class="hljs-title">UncaughtExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> </span>&#123;<br>        System.out.println(t.getName() + <span class="hljs-string">&quot;线程出现了异常&quot;</span> + e);<br>    &#125;<br>&#125;<br><br><br><br><br><br><br><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="image/image-20200722115647052.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程同步</title>
    <link href="/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <url>/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当多个线程都需要修改同一个资源时，就可能出现错误，不同步的状态。需要使用同步机制使它们正确工作。使用关键词synchronized来进行同步。</p><p>同步代码块的语法格式为：</p><p>synchronized(obj)｛</p><p>​            同步代码块</p><p>｝</p><p>obj叫做同步监视器，线程要执行同步代码块之前必须要获得对同步监视器的锁定。即可以理解为对obj上锁。任何时刻，只能有一个线程拥有obj的锁。</p><p>应该使用两个或多个线程共享的资源来作为同步监视器。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">Accout</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Accout</span>(<span class="hljs-string">&quot;123456w&quot;</span>, <span class="hljs-number">200</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TakeMoney</span>(<span class="hljs-string">&quot;甲&quot;</span>, acc, <span class="hljs-number">200</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TakeMoney</span>(<span class="hljs-string">&quot;乙&quot;</span>, acc, <span class="hljs-number">200</span>);<br><br>        thread1.start();<br>        thread2.start();<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TakeMoney</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Accout accout;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TakeMoney</span><span class="hljs-params">(String name, Accout accout, <span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.accout = accout;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-comment">//在这里加上同步代码块，一个线程取钱操作完成后，另一个线程才可以执行</span><br>        <span class="hljs-keyword">synchronized</span> (accout) &#123;<br>            <span class="hljs-keyword">if</span> (accout.getBalance() &gt;= money) &#123;<br><br>                System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;取钱成功,取出&quot;</span> + money);<br>                accout.setBalance(accout.getBalance() - money);<br>                System.out.println(<span class="hljs-string">&quot;当前余额为：&quot;</span> + accout.getBalance());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;余额不足，取钱失败&quot;</span>);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Accout</span> &#123;<br>    <span class="hljs-comment">//省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>与同步代码块相对应的，Java提供了同步方法，同步方法就是使用synchronized关键词修饰某个方法，对于synchronized修饰的实例方法，线程在执行该方法时，<strong>取得的是调用该方法的对象的锁</strong>，即相当于synchronized(this)。</p><p>使用同步方法可以方便实现线程安全的类，线程安全类具体以下特征：</p><ul><li>该类对象可以被多个线程安全访问</li><li>每个线程调用该对象任意方法后都将得到正确的结果</li><li>每个线程调用该对象的任意方法后，该对象状态保持合理状态</li></ul><p>上个例子可以使用同步方法来做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">Accout</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Accout</span>(<span class="hljs-string">&quot;123456w&quot;</span>, <span class="hljs-number">200</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TakeMoney</span>(<span class="hljs-string">&quot;甲&quot;</span>, acc, <span class="hljs-number">200</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TakeMoney</span>(<span class="hljs-string">&quot;乙&quot;</span>, acc, <span class="hljs-number">200</span>);<br><br>        thread1.start();<br>        thread2.start();<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TakeMoney</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Accout accout;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TakeMoney</span><span class="hljs-params">(String name, Accout accout, <span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.accout = accout;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        accout.takeMoney(<span class="hljs-built_in">this</span>, accout, money);<br>        <br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Accout</span> &#123;<br>    <br>    <span class="hljs-comment">//省略...</span><br>    <span class="hljs-comment">//使用同步方法来解决</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeMoney</span><span class="hljs-params">(Thread thread, Accout accout, <span class="hljs-type">double</span> money)</span> &#123;<br><br>        <span class="hljs-keyword">if</span> (accout.getBalance() &gt;= money) &#123;<br>            System.out.println(thread.getName() + <span class="hljs-string">&quot;取钱成功,取出&quot;</span> + money);<br>            accout.setBalance(accout.getBalance() - money);<br>            System.out.println(<span class="hljs-string">&quot;当前余额为：&quot;</span> + accout.getBalance());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;余额不足，取钱失败&quot;</span>);<br>        &#125;<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="释放同步监视器的锁定"><a href="#释放同步监视器的锁定" class="headerlink" title="释放同步监视器的锁定"></a>释放同步监视器的锁定</h2><p>任何线程进入同步代码块，同步方法之前，要获得同步监视器的锁定，然后线程会在几种情况释放该锁</p><ul><li>执行到方法、同步代码块结束，线程释放监视器</li><li>在执行时遇到break、return终止该代码块</li><li>在执行时遇到了未处理的Error或者Exception，导致异常结束</li><li>当前线程执行时，程序执行了同步监视器对象的wait方法，当前线程暂停，并且释放监视器</li></ul><h2 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h2><p>Java提供了一种更强大的线程同步机制———通过显式定义同步锁对象来实现同步。这种机制下，同步锁使用Lock对象充当。</p><p>Lock是控制多个线程对共享资源进行访问的工具，线程开始访问共享资源时，应先获得Lock对象。</p><p>在实现线程安全控制中，比较常用的是ReentrantLock(可重入锁)，使用该对象可以显式的加锁、释放锁，通常使用该锁的代码格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">//定义需要保证线程安全的方法</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//需要保证线程安全的代码</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//即使遇到异常也能释放锁</span><br>    lock.unlock();        <br>        &#125;<br>    &#125;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>将之前例子中需要线程安全的方法改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeMoney</span><span class="hljs-params">(Thread thread, Accout accout, <span class="hljs-type">double</span> money)</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (accout.getBalance() &gt;= money) &#123;<br>            System.out.println(thread.getName() + <span class="hljs-string">&quot;取钱成功,取出&quot;</span> + money);<br>            accout.setBalance(accout.getBalance() - money);<br>            System.out.println(<span class="hljs-string">&quot;当前余额为：&quot;</span> + accout.getBalance());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;余额不足，取钱失败&quot;</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>同样可以实现线程安全</p><p>使用Lock对象和使用synchronized方法类似，只不过一个是显式使用Lock对象，另一个是隐式使用当前对象作为同步监视器。</p><p>ReentrantLock具有可重入性，意思是多个线程可以在已被加锁的ReentrantLock对象再次加锁，即可执行多次lock方法，ReentrantLock对象会维持一个计数器来追踪对lock对象的嵌套调用。线程在每次调用lock加锁后，必须调用unlock释放锁。</p><h2 id="避免死锁的策略"><a href="#避免死锁的策略" class="headerlink" title="避免死锁的策略"></a>避免死锁的策略</h2><p>当两个或多个线程在互相等待对方释放同步监视器时就会发生死锁。Java没有检测，也不会解决死锁。需要人为干预避免死锁出现。</p><p>可以使用几个方法来避免</p><ul><li>避免多次锁定，尽量避免同一个线程对多个同步监视器进行锁定</li><li>具有相同加锁顺序：如果多个线程需要对多个同步监视器进行锁定，则应该保证它们以相同顺序请求加锁</li><li>使用定时锁，程序调用Lock对象的tryLock方法可以指定time和unit参数，当超过指定时间就会自动释放对Lock的锁定</li><li>死锁检测：依靠算法来实现的死锁预防机制</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程通信</title>
    <link href="/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如果使用synchronized关键词，实现线程同步，可以使用Object类提供的三个方法，这三个方法必须使用同步监视器来调用，对于同步方法，可以直接使用，因为该类默认实例this就是同步监视器，对于同步代码块，必须使用同步监视器对象来调用这三个方法。</p><ul><li>wait()：导致当前线程等待，直到其他线程调用该同步监视器notify()方法或者notifyAll()方法来唤醒该线程。该方法有三种形式：无参，带毫秒参数，带毫秒和毫微妙参数。调用wait方法的当前线程会释放对同步监视器的锁定</li><li>notify()：唤醒在此同步监视器等待的单个线程，如果很多线程都在此同步监视器上等待，就唤醒其中一个。选择是任意的，只有当前线程放弃对该同步监视器锁定后，才可以执行被唤醒的线程</li><li>notifyAll()：唤醒在此同步监视器上等待的所有线程，只有当前线程放弃对该同步监视器锁定后，才可以执行被唤醒的线程</li></ul><p>类似操作系统中的PV操作，阻塞线程和唤醒线程。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> work;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>        <span class="hljs-type">Accout</span> <span class="hljs-variable">acc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Accout</span>(<span class="hljs-string">&quot;123456w&quot;</span>, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TakeMoney</span>(<span class="hljs-string">&quot;取钱人&quot;</span>, acc, <span class="hljs-number">100</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SaveMoney</span>(<span class="hljs-string">&quot;存钱人&quot;</span>, acc, <span class="hljs-number">100</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SaveMoney</span>(<span class="hljs-string">&quot;存钱人&quot;</span>, acc, <span class="hljs-number">100</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SaveMoney</span>(<span class="hljs-string">&quot;存钱人&quot;</span>, acc, <span class="hljs-number">100</span>);<br><br><br>        thread1.start();<br>        thread2.start();<br>        thread3.start();<br>        thread4.start();<br><br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TakeMoney</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Accout accout;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TakeMoney</span><span class="hljs-params">(String name, Accout accout, <span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.accout = accout;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">for</span>(; <span class="hljs-literal">true</span> ;)&#123;<br>            accout.take(<span class="hljs-built_in">this</span>, accout, money);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveMoney</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Accout accout;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> money;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SaveMoney</span><span class="hljs-params">(String name, Accout accout, <span class="hljs-type">double</span> money)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.accout = accout;<br>        <span class="hljs-built_in">this</span>.money = money;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Accout <span class="hljs-title function_">getAccout</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> accout;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getMoney</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> money;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">for</span>(;<span class="hljs-literal">true</span>;)&#123;<br>            accout.save(<span class="hljs-built_in">this</span>, accout, money);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Accout</span> &#123;<br>    <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">take</span><span class="hljs-params">(Thread thread, Accout accout, <span class="hljs-type">double</span> money)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>) &#123;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(accout.getBalance() &gt;= money) &#123;<br>                System.out.println(thread.getName() + <span class="hljs-string">&quot;取钱成功,取出&quot;</span> + money);<br>                balance = balance - money;<br>                System.out.println(<span class="hljs-string">&quot;当前余额为：&quot;</span> + accout.getBalance());<br><br>                flag = <span class="hljs-literal">false</span>;<br>                notifyAll();<br><br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">(Thread thread, Accout accout, <span class="hljs-type">double</span> money)</span> &#123;<br><br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><br>            System.out.println(thread.getName() + <span class="hljs-string">&quot;存钱成功，存进&quot;</span> + money);<br>            balance = balance + money;<br>            System.out.println(<span class="hljs-string">&quot;当前余额为：&quot;</span> + accout.getBalance());<br><br>            flag = <span class="hljs-literal">true</span>;<br>            notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><br><br></code></pre></td></tr></table></figure><h2 id="使用Condition控制线程通信"><a href="#使用Condition控制线程通信" class="headerlink" title="使用Condition控制线程通信"></a>使用Condition控制线程通信</h2><p>如果程序不使用synchronized关键词保证同步，而是直接使用Lock对象,那么就没有隐式同步监视器，就不能使用wait、notify、notifyAll方法进行线程通信。</p><p>当使用Lock对象来保证同步时，Java提供了一个Condition类来保持协调，使用Condition可以让那些已经得到Lock对象却无法继续执行的线程释放Lock对象，Condition对象也可以唤醒其他处于等待的线程。</p><p>Condition实例被绑定在一个Lock对象上，要获得Lock实例的Condition实例，可以调用Lock对象的newCondition方法，Condition类提供了三个方法：</p><ol><li>await()：类似隐式同步监视器的wait方法，可以导致当前线程等待，直到其他线程调用该Condition的signal方法或signalAll方法来唤醒该线程，该await方法有多个变体，如long awaitNanos(long nanosTimeout)、void awaitUninterruptibly()、awaitUntil(Date deadline)可以完成更丰富的操作</li><li>signal()：唤醒在此Lock对象上等待的单个线程，如果有多个线程在等待，那么选择任意一个线程来唤醒。只有当前线程放弃对Lock对象的锁定后(使用await方法),才可以执行被唤醒的线程</li><li>signalALL()：唤醒在此Lock对象上等待的所有线程，只有当前线程放弃对Lock对象的锁定后(使用await方法),才可以执行被唤醒的线程</li></ol><p><strong>注意！！！！！：无论是使用wait方法还是await方法使线程阻塞后，再次唤醒线程后，会从上次阻塞的位置继续开始执行，而不是重新进入同步代码块.</strong></p><h2 id="使用阻塞队列BlockingQueue控制线程通信"><a href="#使用阻塞队列BlockingQueue控制线程通信" class="headerlink" title="使用阻塞队列BlockingQueue控制线程通信"></a>使用阻塞队列BlockingQueue控制线程通信</h2><p>Java提供了一个BlockingQueue接口，它虽然是Queue的子接口，但它的主要作用并不是作为容器，而是作为线程同步的工具，BlockingQueue具有一个特征：当生产者线程试图向BlockingQueue中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从BlockingQueue中取出元素时，如果该队列已空，则该线程被阻塞。</p><p>程序的两个线程通过交替向BlockingQueue中放入、取出元素，可以很好的控制线程通信。</p><p>BlockingQueue提供了两个支持阻塞的方法：</p><ul><li>put(E e)：尝试把E元素放入BlockingQueue中，如果该队列元素已满，则阻塞该线程</li><li>take()：尝试从BlockingQueue的头部取出元素，如果该队列的元素已空，则阻塞该线程</li></ul><p>BlockingQueue继承自Queue，当然也可以使用Queue的方法，这些方法归纳起来可分为三组</p><ul><li>在队列尾部插入元素，包括add(E e)、offer(E e)、put(E e)方法，当该队列已满时，这三个方法分别为抛出异常、返回false、阻塞队列</li><li>在队列头部删除元素并返回删除的元素，包括remove()、poll()、take()方法，当队列为空，这三个方法分别会抛出异常，返回false、阻塞队列</li><li>在队列头部取出但不删除元素，包括element()、peek()方法，当队列已空时，这两个方法分别抛出异常、返回false</li></ul><p>BlockingQueue包括五个实现类</p><ul><li>ArrayBlockingQueue：基于数组实现的BlockingQueue队列</li><li>LinkedBlockingQueue：基于链表实现的BlockingQueue队列</li><li>PriorityBlockingQueue：它不是标准的阻塞队列，该队列调用remove、poll、take方法取出元素时，并不是取出队列中存在时间最长的，而是取出队列中最小的元素，PriorityBlockingQueue判断元素的大小可以根据元素本身大小来自然排序(实现Comparable接口)，也可以使用Conparator接口进行定制排序</li><li>SynchronizedQueue：同步队列，对该队列的存、取操作必须交替进行</li><li>DelayQueue：是一个特殊的阻塞队列，底层基于PriorityBlockingQueue实现，不过Delay要求集合元素都实现Delay接口(该接口只有一个long getDelay()方法)，DelayQueue根据集合元素的getDelay的返回值进行排序</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的生命周期</title>
    <link href="/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个进程的不同线程有各自的栈，但是所有线程共享方法区和堆。</p><p>即方法区和堆都只有一块。</p><p>线程有五种状态：新建、就绪、运行、阻塞、死亡</p><p>当新建一个线程对象时，该线程就处于新建状态</p><p>当调用该线程对象的start方法时，Java虚拟机会为该线程分配栈和程序计数器，但是该线程并不会立即执行，而是进入就绪状态，等待JVM线程调度器的调度。</p><p>当调度到该线程，就进入运行状态。</p><p>在运行过程中，如果需要等待输入，等待IO，或者其他资源，或者调用了sleep方法，就进入阻塞状态。</p><p>该线程执行完毕，结束，或者线程抛出异常或者错误，或者调用该线程的stop方法，就进入死亡状态。</p><p><strong>注意：</strong></p><p>永远不要调用线程对象的run方法，而是要调用start方法。如果调用run方法，则会在主线程运行，没有启动多线程。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>控制线程</title>
    <link href="/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B/"/>
    <url>/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id=""><a href="#" class="headerlink" title=" "></a> </h1><p>Java提供了一些控制线程的工具方法</p><h2 id="join线程"><a href="#join线程" class="headerlink" title="join线程"></a>join线程</h2><p>Thread提供了让一个线程等待另一个线程完成的方法——join方法，当在某个程序执行流中调用其他线程的join方法时，该线程将被阻塞，直到被调用join线程执行完为止。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JoinThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">vat</span> <span class="hljs-variable">jt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JoinThread</span>().start();<br>        jt.join();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0l</span> i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            System.out.println(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该程序中，主线程调用了jt线程的join方法，则主线程会陷入阻塞，直到jt线程执行完成，主线程才会继续运行。</p><p>join方法有三种重载形式：</p><ul><li><strong>join()</strong>：等待被join的线程执行完毕</li><li><strong>join(long millis)</strong>：等待被join的线程时间最长为millis毫秒，如果在millis毫秒时间后，还没有完成，则不再等待</li><li><strong>join(long millis, int nanos)</strong>：等待被join的线程执行时间最长为millis毫秒加nanos毫微秒</li></ul><p>通常很少使用第三种形式。</p><h2 id="后台线程"><a href="#后台线程" class="headerlink" title="后台线程"></a>后台线程</h2><p>在多线程中，main线程只是其中一个线程，必须等待所有线程结束后，整个进程才能结束。那么我们可以将一些线程设为后台线程。</p><p>后台线程是在后台运行的，其他所有线程结束后，这些后台线程会自动结束，从而整个进程结束。</p><p>这些后台线程是为其他线程提供服务的。又称为”守护线程“或者”精灵线程“。</p><p>后台线程的特征就是如果所有前台线程死亡，后台线程会自动死亡。</p><p>可以调用Thread对象的setDaemon方法来将指定线程设为后台线程,并且必须在start方法之前设置，否则会抛出异常。</p><p>前台线程创建的子线程默认为前台线程，后台线程创建的子线程默认为后台线程。</p><h2 id="线程睡眠：sleep"><a href="#线程睡眠：sleep" class="headerlink" title="　线程睡眠：sleep"></a>　线程睡眠：sleep</h2><p>如果需要将当前正在执行的线程暂停一段时间，进入阻塞状态，可以调用Thread的静态方法sleep方法来实现。sleep方法有两种重载形式。</p><ul><li><strong>static void sleep(long millis)</strong>：让当前正在执行的线程暂停millis毫秒，并进入阻塞状态，该方法受到系统计时器和线程调度器的精度和准确度的影响。</li><li><strong>static void sleep(long millis, int nanos)</strong>：当前执行的线程暂停millis毫秒加nanos毫微秒</li></ul><p>程序很少使用第二种形式。</p><p>当当前线程调用sleep方法进入阻塞状态后，在其睡眠时间段内，该线程不会获得，执行的机会，即使系统中没有其他正在运行的线程，处于睡眠的线程也不会执行。</p><h2 id="让线程转入就绪状态：yield"><a href="#让线程转入就绪状态：yield" class="headerlink" title="让线程转入就绪状态：yield"></a>让线程转入就绪状态：yield</h2><p>与sleep方法类似，Thread的一个静态方法yield可以使当前线程暂停，但这个方法并不会使线程陷入阻塞，它只是将线程转入就绪状态，等待重新调度。</p><p>关于sleep方法和yield方法的区别有：</p><ul><li>sleep方法暂停当前线程后，会给其他线程执行的机会，不会理会其他线程的优先级，<strong>但是yield方法只会给优先级相同或更高的线程执行机会</strong></li><li>sleep方法会将线程陷入阻塞状态，经过阻塞时间后才会转入就绪状态，但是yield方法只是强制当前线程进入就绪状态</li><li>sleep方法声明抛出了InterruptException异常，调用sleep方法要么捕捉该异常，要么抛出该异常，而yield方法不会声明抛出任何异常</li><li>sleep方法比yield方法有更好的可移植性，通常不建议使用yield方法控制并发线程的执行</li></ul><h2 id="改变线程优先级"><a href="#改变线程优先级" class="headerlink" title="改变线程优先级"></a>改变线程优先级</h2><p>每一个线程都有优先级，优先级高的线程会获得更多的执行机会。</p><p>每个线程默认的优先级都与创建它的线程拥有相同的优先级，在默认情况，main线程具有普通优先级。</p><p>Thread提供了一个方法setPriority(int newPriority)，getPriority()方法来设置和获得线程的优先级。其中，setPriority方法参数为一个整数，范围是1~10之间，也可以使用Thread类的三个静态常量。</p><ul><li>MAX_PRIORITY:10</li><li>MIN_PRIORITY: 1</li><li>NORM_PRIORITY: 5</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建多线程的三种方式</title>
    <link href="/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/05/11/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><p><strong>通过继承Thread类来创建并启动多线程的步骤为：</strong></p><ol><li>定义Thread类的子类，并继承重写该类的run()方法，该run()方法就代表该线程要完成的任务。</li><li>创建Thread子类的实例</li><li>调用该实例对象的start()方法启动该线程</li></ol><h2 id="实现Runnable接口创建线程类"><a href="#实现Runnable接口创建线程类" class="headerlink" title="实现Runnable接口创建线程类"></a>实现Runnable接口创建线程类</h2><p><strong>步骤如下：</strong></p><ol><li>定义Runnable接口的实现类，重写该接口的run()方法</li><li>创建Runnable接口的实例，并用该实例对象作为Thread的target来创建Thread对象，该Thread才是真正的线程对象</li><li>调用线程对象的start方法启动该线程</li></ol><p>例子(SecondThread实现了Runnable接口)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecondThread</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(st);<br></code></pre></td></tr></table></figure><h2 id="使用Callable和Future创建线程"><a href="#使用Callable和Future创建线程" class="headerlink" title="使用Callable和Future创建线程"></a>使用Callable和Future创建线程</h2><p>Callable接口提供了call()方法来作为线程执行体，但是call方法比run方法功能更强大</p><ul><li>call方法可以有返回值</li><li>call方法可以声明抛出异常</li></ul><p>Java提供了Future接口来代表Callable接口call方法的返回值，并且为Future提供了一个FutureTask实现类，该实现类实现了Future接口，并且实现了Runnable接口，可以作为Thread类的target。</p><p>在Future接口定义了几个公共方法控制与它关联的Callable任务</p><hr><p><strong>boolean cancel(boolean mayInterruptRunning)</strong></p><p>功能：试图取消该Future关联的Callable任务</p><p>参数：</p><ul><li>mayInterruptRunning</li></ul><p>返回值：一个布尔值</p><hr><p><strong>V get()</strong></p><p>功能：返回Callable任务中的返回值，调用该任务，将导致程序阻塞，必须等到子线程结束才会得到返回值</p><p>参数：无</p><p>返回值：指定返回值</p><hr><p><strong>V get(long timeout, TimeUnit unit)</strong></p><p>功能：返回Callable任务里call任务的返回值，该方法让程序最多阻塞timeout和unit指定的时间，如果经过指定时间仍然没有返回值，将抛出TimeoutException异常</p><hr><p><strong>boolean isCanceled()</strong></p><p>功能：如果该Callable任务在正常完成前被取消，则返回true</p><hr><p><strong>boolean isDone()</strong></p><p>功能：如果该任务已经完成，返回true</p><hr><p>Callable接口有泛型限制，Callable接口里的泛型形参类型和call方法返回值相同，而且Callable接口为函数式接口，可以直接使用Lambda表达式创建Callable对象。</p><p>步骤为：</p><ol><li>创建Callable接口的实现类，并实现call方法，创建实例对象</li><li>使用FutureTask来包装该实现类，该FutureTask对象封装了该Callable对象的call方法</li><li>使用FutureTask对象作为Thread对象的target创建线程对象，并启动线程</li><li>调用FutureTask对象的get方法来获得返回值</li></ol><h2 id="三种创建对象的方式对比"><a href="#三种创建对象的方式对比" class="headerlink" title="三种创建对象的方式对比"></a>三种创建对象的方式对比</h2><p>实现Runnable接口和实现Callable接口的方式基本差不多，只是Callable接口里可以有返回值，可以声明抛出异常。因此可以将两种实现接口的方法归为一种方式，和继承Thread类的主要区别有：</p><ol><li>线程类只是实现了接口，还可以继承其他类</li><li>在这种方式下，多个线程可以共享一个target对象，所以非常适合多个线程处理一份资源的情况，从而可以将CPU，代码和数据分开，形成清晰模型</li><li>劣势是，编程稍微复杂，如果需要访问当前线程，则必须使用Thread.currentThread方法</li></ol><p>采用继承Thread类的方法创建多线程优缺点为：</p><ol><li>劣势是，因为线程类已经继承了Thread，不能再继承其他类</li><li>优势是，编程简单，如果要访问当前线程，直接使用this</li></ol><p>综上，一般推荐采用Runnable接口、Callable接口来创建多线程。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务处理及批量更新</title>
    <link href="/2022/05/11/Java/JDBC/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8F%8A%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/"/>
    <url>/2022/05/11/Java/JDBC/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E5%8F%8A%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="事务的概念和MySQL事务支持"><a href="#事务的概念和MySQL事务支持" class="headerlink" title="事务的概念和MySQL事务支持"></a>事务的概念和MySQL事务支持</h3><p>事务：是由一步或几步数据库操作序列组成的逻辑执行单元，<strong>这系列操作要么不执行，要么全部执行。</strong></p><p>事务具有四个特性：</p><ul><li>原子性：事务是应用中最小的执行单元。</li><li>一致性：事务执行的结果必须使数据库从一个一致性状态转换到另一个一致性状态。<br>  当数据库只包含事务成功提交的结果时，数据库处于一致性状态。如果系统运行发生中断，某个事务尚未完成而被迫中断，而该事务对数据库做的修改已经被写入数据库，此时，数据库处于不正确的状态。<br>  例如：A给B转账1000元，系统先在A的账户减去1000，再在B的账户加上1000，如果都执行成功，则数据库处于一致性状态，如果给A减了1000，但在给B加上1000时，出错了，没有执行成功，此时就没有处于一致性状态。</li><li>隔离性：各个事务的执行互不干扰</li><li>持续性：指事务一旦提交，对数据所做的任何改变都要记录到永久存储器中，通常就是保存到物理数据库</li></ul><p>数据库事务由以下语句构成：</p><ul><li>一组数据操作语句(DML)；</li><li>一条数据定义语句(DDL)；</li><li>一条数据控制语句(DCL)；</li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>DDL和DCL语句最多只能有一条，因为DDL和DCL语句都会导致事务立即提交。</p><p>当事务全部执行成功后，应该提交事务。事务提交有两种方式：</p><ul><li>显式提交：使用commit</li><li>自动提交：执行DCL或DDL语句，或者程序正常退出</li></ul><p>当事务包含的操作执行失败后，应该回滚(rollback)事务，使之前所做的修改全部失效。事务回滚有两种方式：</p><ul><li>显式回滚：使用rollback</li><li>自动回滚：系统错误或者强行退出</li></ul><p>MySQL默认打开自动提交，在默认情况，用户输入一条DML语句,这条语句将会立即保存到数据库。<br>使用<code>set autocommit = 0</code> 开启显式提交。<strong>但只对本次连接有效，对其他连接到数据库的连接无效。</strong></p><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>使用commit提交只对DML语句有效，当执行DDL和DCL时，不管是否为显式提交，都会立即提交。</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set autocommit = 0;<br> begin;<br> insert into choose Values(&#x27;Get&#x27;, 20, 11.1, &#x27;Out&#x27;, &#x27;HaHa&#x27;);<br> select * from choose;<br></code></pre></td></tr></table></figure><p>结果</p><p><img src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200412102618429.png" alt="image-20200412102618429"></p><p>接着执行 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">rollback;<br>select * from choose;<br></code></pre></td></tr></table></figure><p>结果：</p><p><img src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200412102738691.png" alt="image-20200412102738691"></p><h2 id="JDBC的事务支持"><a href="#JDBC的事务支持" class="headerlink" title="JDBC的事务支持"></a>JDBC的事务支持</h2><p>JDBC连接事务支持由Conncetion提供，Connection默认打开自动提交。</p><p>调用setAutoCommit()方法关闭自动提交：</p><p><code>conn.setAutoCommit(false)</code></p><p>调用commit()方法提交事务：</p><p><code>conn.commit()</code></p><p>如果任何一条语句执行失败，用rollback回滚事务：</p><p><code>conn.rollback()</code></p><h5 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h5><p>当Connection遇到未处理的SQLException异常时，系统会非正常退出，事务会自动回滚，但是如果程序捕获了该异常，需要在异常处理块中显式回滚事务。</p><p>Connection也提供了设置中间点的方法：Savepoint setSavepoint()、Savepoint setSavepoint(String name)</p><p>通常没有必要给中间点设置名称，当回滚到指定中间点时，是根据中间点对象回滚的，使用rollback(Savepoint savepoint)回滚到指定中间点。</p><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>使用批量更新时，多条SQL语句被作为一批操作同时收集，并同时提交。</p><h5 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h5><p>批量更新要得到底层数据库支持，可以调用DatabaseMetaData的supportBatchUpdate()方法查看底层数据库是否支持批量更新</p><p>使用批量更新需要创建一个Statement对象，用该对象的addBatch()方法收集多条SQL语句，最后调用exexuteLargeBatch()或executeBatch()执行这些语句。</p><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Statement stmt = conn.createStatement();<br>//收集多条SQL语句<br>stmt.addBatch(sql1);<br>stmt.addBatch(sql2);<br>stmt.addBatch(sql3);<br>...<br>//同时执行多条语句<br>stmt.executeLargeBatch();<br></code></pre></td></tr></table></figure><p>执行后返回一个long[]数组，每个long值表示每条语句影响的行数，若addBatch()添加了查询语句，程序会直接出现错误。</p><p>实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs mysql"><br>import java.sql.*;<br>import java.io.*;<br>import java.util.*;<br><br><br>public class BatchTest<br>&#123;<br>private String driver;<br>private String url;<br>private String user;<br>private String pass;<br>public void initParam(String paramFile) throws Exception<br>&#123;<br>// 使用Properties类来加载属性文件<br>var props = new Properties();<br>props.load(new FileInputStream(paramFile));<br>driver = props.getProperty(&quot;driver&quot;);<br>url = props.getProperty(&quot;url&quot;);<br>user = props.getProperty(&quot;user&quot;);<br>pass = props.getProperty(&quot;pass&quot;);<br>&#125;<br>public void insertBatch(String[] sqls) throws Exception<br>&#123;<br>// 加载驱动<br>Class.forName(driver);<br>try (<br>Connection conn = DriverManager.getConnection(url, user, pass))<br>&#123;<br>// 关闭自动提交，开启事务<br>conn.setAutoCommit(false);<br>// 保存当前的自动的提交模式<br>boolean autoCommit = conn.getAutoCommit();<br>// 关闭自动提交<br>conn.setAutoCommit(false);<br>try (<br>// 使用Connection来创建一个Statement对象<br>Statement stmt = conn.createStatement())<br>&#123;<br>// 循环多次执行SQL语句<br>for (var sql : sqls)<br>&#123;<br>stmt.addBatch(sql);<br>&#125;<br>// 同时提交所有的SQL语句<br>stmt.executeLargeBatch();<br>// 提交修改<br>conn.commit();<br>// 恢复原有的自动提交模式<br>conn.setAutoCommit(autoCommit);<br>&#125;<br>// 提交事务<br>conn.commit();<br>&#125;<br>&#125;<br>public static void main(String[] args) throws Exception<br>&#123;<br>var tt = new TransactionTest();<br>tt.initParam(&quot;mysql.ini&quot;);<br>var sqls = new String[]&#123;<br>&quot;insert into student_table values(null, &#x27;aaa&#x27;, 1)&quot;,<br>&quot;insert into student_table values(null, &#x27;bbb&#x27;, 1)&quot;,<br>&quot;insert into student_table values(null, &#x27;ccc&#x27;, 1)&quot;,<br>&#125;;<br>tt.insertInTransaction(sqls);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>管理结果集</title>
    <link href="/2022/05/11/Java/JDBC/%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86/"/>
    <url>/2022/05/11/Java/JDBC/%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%9C%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="可滚动、可更新-可修改-的结果集"><a href="#可滚动、可更新-可修改-的结果集" class="headerlink" title="可滚动、可更新(可修改)的结果集"></a>可滚动、可更新(可修改)的结果集</h2><p>使用absolute()、previous()、afterLast()等方法自由移动记录指针的ResultSet被称为可滚动的结果集。<br>在Java 5.0以后，默认打开的ResultSet()就是可滚动的。</p><p>以默认方式打开的ResultSet是不可更新的，必须要传入额外参数。Connection在创建Statement或PreparedStatement时，<br>传入如下两个参数：</p><ol><li><p>resultSetType：可取三个值</p><ul><li>ResultSet.TYPE_FORWARD_ONLY：控制记录指针只能向前移动。</li><li>ResultSet.TYPE_SCROLL_INSENSITINE：记录指针可以自由移动(可滚动结果集)，但底层数据改变不会影响ResultSet 的内容。</li><li>ResultSet.TYPE_SCROLL_SENSTTIVE：记录指针可以自由移动(可滚动结果集)，底层数据改变会影响ResultSet 的内容。</li></ul></li></ol><ol><li><p>resultSetConcurrency：控制ResultSet的并发类型，可接收两个值。</p><ul><li><p>ResultSet.CONCUR_READ_ONLY：指示ResultSet是只读的并发模式（默认）</p></li><li><p>ResultSet.CONCUR_UPDATABLE：指示ResultSet是可更新的并发模式</p><p>  例子:</p></li></ul></li></ol><pre><code class="hljs">    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultSetTest</span><br>&#123;<br><span class="hljs-keyword">private</span> String driver;<br><span class="hljs-keyword">private</span> String url;<br><span class="hljs-keyword">private</span> String user;<br><span class="hljs-keyword">private</span> String pass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initParam</span><span class="hljs-params">(String paramFile)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 使用Properties类来加载属性文件</span><br><span class="hljs-type">var</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>props.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(paramFile));<br>driver = props.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>url = props.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>user = props.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>pass = props.getProperty(<span class="hljs-string">&quot;pass&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">query</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 加载驱动</span><br>Class.forName(driver);<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 获取数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, pass);<br><span class="hljs-comment">// 使用Connection来创建一个PreparedStatement对象</span><br><span class="hljs-comment">// 传入控制结果集可滚动，可更新的参数。</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(sql,<br>ResultSet.TYPE_SCROLL_INSENSITIVE,<br>ResultSet.CONCUR_UPDATABLE);<br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> pstmt.executeQuery())<br>&#123;<br>rs.last();<br><span class="hljs-type">int</span> <span class="hljs-variable">rowCount</span> <span class="hljs-operator">=</span> rs.getRow();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> rowCount; i &gt; <span class="hljs-number">0</span>; i--)<br>&#123;<br>rs.absolute(i);<br>System.out.println(rs.getString(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;\t&quot;</span><br>+ rs.getString(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot;\t&quot;</span> + rs.getString(<span class="hljs-number">3</span>));<br><span class="hljs-comment">// 修改记录指针所有记录、第2列的值</span><br>rs.updateString(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;学生名&quot;</span> + i);<br><span class="hljs-comment">// 提交修改</span><br>rs.updateRow();<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">rt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResultSetTest</span>();<br>rt.initParam(<span class="hljs-string">&quot;mysql.ini&quot;</span>);<br>rt.query(<span class="hljs-string">&quot;select * from student_table&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>    ## 使用ResultSetMetaData分析结果集    如果程序需要了解ResultSet里包含哪些数据列，以及每个数据列的数据类型，可以通过ResultSetMetaData来获取关于ResultSet的描述信息。    ResultSet里包含一个getMetaData()方法，该方法返回该ResultSetMetaData对象，然后通过ResultSetMetaData提供的方法返回ResultSet的描述信息。常有方法有如下三个：    | 函数原型                         | 功能                      | 参数             |    | -------------------------------- | ------------------------- | ---------------- |    | int getColumnCount()             | 返回该ResultSet的列的数量 | 无               |    | String getColumnName(int column) | 返回指定索引的列名        | column：指定索引 |    | int getColumnType(int column)    | 返回指定索引列类型        | column：指定索引 |    ## 使用RowSet 1.1 包装结果集    RowSet接口继承了ResultSet接口，RowSet接口包括JdbcRowSet、CachedRowSet、FilteredRowSet、JoinRowSet和WebRowSet常用子接口，其中JdbcRowSet需要保持与数据库的连接之外，其余四个子接口都是离线的RowSet,不需要保持与数据库的连接。    RowSet默认是可滚动、可更新、可序列化的结果集，对于离线的RowSet而言，程序在创建RowSet时已经把数据从底层数据库读取到了内存中，因此可以充分利用计算机的内存，从而降低数据库服务器的负载。    #### RowSetFactory与RowSet    RowSetProvider类负责创建RowSetFactory,而RowSetFactory提供以下方法创建RowSet实例。    - CachedRowSet createCachedRowSet()：创建一个默认的CachedRowSet。    - FilterRowSet createFilterRowSet()：创建一个默认的FilterRowSet</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行SQL语句</title>
    <link href="/2022/05/11/Java/JDBC/%E6%89%A7%E8%A1%8CSQL%E8%AF%AD%E5%8F%A5/"/>
    <url>/2022/05/11/Java/JDBC/%E6%89%A7%E8%A1%8CSQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Statement对象执行SQL语句"><a href="#Statement对象执行SQL语句" class="headerlink" title="Statement对象执行SQL语句"></a>Statement对象执行SQL语句</h2><ol><li><p>使用executeLargeUpdate()方法执行DDL和DML语句</p><p> executeUpdate和executeLargeUpdate区别是如果受影响的行数超过了int最大值，则要使用后者。</p><p> 例子：</p></li></ol><pre><code class="hljs"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecuteDDL</span><br>&#123;<br><span class="hljs-keyword">private</span> String driver;<br><span class="hljs-keyword">private</span> String url;<br><span class="hljs-keyword">private</span> String user;<br><span class="hljs-keyword">private</span> String pass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initParam</span><span class="hljs-params">(String paramFile)</span><br><span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 使用Properties类来加载属性文件</span><br><span class="hljs-type">var</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>props.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(paramFile));<br>driver = props.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>url = props.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>user = props.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>pass = props.getProperty(<span class="hljs-string">&quot;pass&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTable</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 加载驱动</span><br>Class.forName(driver);<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 获取数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, pass);<br><span class="hljs-comment">// 使用Connection来创建一个Statment对象</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement())<br>&#123;<br><span class="hljs-comment">// 执行DDL,创建数据表</span><br>stmt.executeUpdate(sql);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">ed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecuteDDL</span>();<br>ed.initParam(<span class="hljs-string">&quot;mysql.ini&quot;</span>);<br>ed.createTable(<span class="hljs-string">&quot;create table jdbc_test &quot;</span><br>+ <span class="hljs-string">&quot;( jdbc_id int auto_increment primary key, &quot;</span><br>+ <span class="hljs-string">&quot;jdbc_name varchar(255), &quot;</span><br>+ <span class="hljs-string">&quot;jdbc_desc text);&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;-----建表成功-----&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><ol><li><p>使用execute方法执行SQL语句</p><p> execute方法可以执行任何SQL语句，但是很麻烦，通常没必要用此方法。但如果不清楚SQL语句类型，则可以使用此方法。</p><p> 该方法返回值是boolean值，SQL语句返回结果集，则为true，否则为false。</p><p> 在该方法执行以后，若是true，则返回值为结果集</p><p> 可用<code>getResultSet()</code> 获取Statement执行查询语句的结果集</p><p> 若返回值是false，则表明SQL语句是DDL或者DML，用</p><p> <code>getUpdateCount()</code> 获取执行DML语句影响的行数</p></li></ol><pre><code class="hljs">例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExecuteSQL</span><br>&#123;<br><span class="hljs-keyword">private</span> String driver;<br><span class="hljs-keyword">private</span> String url;<br><span class="hljs-keyword">private</span> String user;<br><span class="hljs-keyword">private</span> String pass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initParam</span><span class="hljs-params">(String paramFile)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 使用Properties类来加载属性文件</span><br><span class="hljs-type">var</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>props.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(paramFile));<br>driver = props.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>url = props.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>user = props.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>pass = props.getProperty(<span class="hljs-string">&quot;pass&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeSql</span><span class="hljs-params">(String sql)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 加载驱动</span><br>Class.forName(driver);<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 获取数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,<br>user, pass);<br><span class="hljs-comment">// 使用Connection来创建一个Statement对象</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement())<br>&#123;<br><span class="hljs-comment">// 执行SQL,返回boolean值表示是否包含ResultSet</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">hasResultSet</span> <span class="hljs-operator">=</span> stmt.execute(sql);<br><span class="hljs-comment">// 如果执行后有ResultSet结果集</span><br><span class="hljs-keyword">if</span> (hasResultSet)<br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 获取结果集</span><br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.getResultSet())<br>&#123;<br><span class="hljs-comment">// ResultSetMetaData是用于分析结果集的元数据接口</span><br><span class="hljs-type">ResultSetMetaData</span> <span class="hljs-variable">rsmd</span> <span class="hljs-operator">=</span> rs.getMetaData();<br><span class="hljs-type">int</span> <span class="hljs-variable">columnCount</span> <span class="hljs-operator">=</span> rsmd.getColumnCount();<br><span class="hljs-comment">// 迭代输出ResultSet对象</span><br><span class="hljs-keyword">while</span> (rs.next())<br>&#123;<br><span class="hljs-comment">// 依次输出每列的值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; columnCount; i++)<br>&#123;<br>System.out.print(rs.getString(i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;\t&quot;</span>);<br>&#125;<br>System.out.print(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;该SQL语句影响的记录有&quot;</span><br>+ stmt.getUpdateCount() + <span class="hljs-string">&quot;条&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">es</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecuteSQL</span>();<br>es.initParam(<span class="hljs-string">&quot;mysql.ini&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;------执行删除表的DDL语句-----&quot;</span>);<br>es.executeSql(<span class="hljs-string">&quot;drop table if exists my_test&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;------执行建表的DDL语句-----&quot;</span>);<br>es.executeSql(<span class="hljs-string">&quot;create table my_test&quot;</span><br>+ <span class="hljs-string">&quot;(test_id int auto_increment primary key, &quot;</span><br>+ <span class="hljs-string">&quot;test_name varchar(255))&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;------执行插入数据的DML语句-----&quot;</span>);<br>es.executeSql(<span class="hljs-string">&quot;insert into my_test(test_name) &quot;</span><br>+ <span class="hljs-string">&quot;select student_name from student_table&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;------执行查询数据的查询语句-----&quot;</span>);<br>es.executeSql(<span class="hljs-string">&quot;select * from my_test&quot;</span>);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></code></pre><p>​    </p><p>​    </p><pre><code class="hljs">## PreparedStatement对象执行SQL语句如果要反复执行结构相同的SQL语句，可以用带占位符 ？参数的SQL语句来代替语句的不同地方`insert into student_table values(null, ?, ?)`可以用PreparedStatement来创建这样语句的对象，在执行语句之前，必须要为占位符传入对应参数值，用`setXxx(int index, Xxx value)方法来传入参数值。**如果清楚占位符参数对应数据类型，可以使用对应setXxx()传入参数值，若不知道对应数据类型，则用setObject()传入，PreparedStatement负责类型转换**。例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreparedStatementTest</span><br>&#123;<br><span class="hljs-keyword">private</span> String driver;<br><span class="hljs-keyword">private</span> String url;<br><span class="hljs-keyword">private</span> String user;<br><span class="hljs-keyword">private</span> String pass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initParam</span><span class="hljs-params">(String paramFile)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 使用Properties类来加载属性文件</span><br><span class="hljs-type">var</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>props.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(paramFile));<br>driver = props.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>url = props.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>user = props.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>pass = props.getProperty(<span class="hljs-string">&quot;pass&quot;</span>);<br><span class="hljs-comment">// 加载驱动</span><br>Class.forName(driver);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertUseStatement</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 获取数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,<br>user, pass);<br><span class="hljs-comment">// 使用Connection来创建一个Statment对象</span><br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.createStatement())<br>&#123;<br><span class="hljs-comment">// 需要使用100条SQL语句来插入100条记录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>&#123;<br>stmt.executeUpdate(<span class="hljs-string">&quot;insert into student_table values(&quot;</span><br>+ <span class="hljs-string">&quot; null, &#x27;姓名&quot;</span> + i + <span class="hljs-string">&quot;&#x27;, 1)&quot;</span>);<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;使用Statement费时:&quot;</span><br>+ (System.currentTimeMillis() - start));<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertUsePrepare</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 获取数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url,<br>user, pass);<br><span class="hljs-comment">// 使用Connection来创建一个PreparedStatement对象</span><br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">pstmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(<br><span class="hljs-string">&quot;insert into student_table values(null, ?, 1)&quot;</span>))<br><br>&#123;<br><span class="hljs-comment">// 100次为PreparedStatement的参数设值，就可以插入100条记录</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>&#123;<br>pstmt.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;姓名&quot;</span> + i);<br>pstmt.executeUpdate();<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;使用PreparedStatement费时:&quot;</span><br>+ (System.currentTimeMillis() - start));<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">pt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PreparedStatementTest</span>();<br>pt.initParam(<span class="hljs-string">&quot;mysql.ini&quot;</span>);<br>pt.insertUseStatement();<br>pt.insertUsePrepare();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></code></pre><p>使用PreparedStatement比使用Statement多了三个好处</p><ol><li><p>PreparedStatement预编译SQL语句，性能更好</p></li><li><p>PreparedStatement不需要拼接SQL语句，编程更简单</p></li><li><p>PreparedStatement可以防止SQL注入，安全性更好。</p></li></ol><p>​        </p><p>​        </p><h2 id="使用CallableStatement调用存储过程"><a href="#使用CallableStatement调用存储过程" class="headerlink" title="使用CallableStatement调用存储过程"></a>使用CallableStatement调用存储过程</h2><p>通过Connection的prepareCall()来创建CallableStatement对象，创建时要传入调用存储对象的SQL语句，语句格式为<br>{call 过程名(?, ?, ?…)},问号作为存储过程参数的占位符，如下代码创建了调用存储过程的CallableStatement对象</p><p><code>cstmt = conn.prepareCall(&quot;&#123;call add_pro(?, ?, ?)&#125;&quot;)</code></p><p>传入参数可以通过 <code>setXxx()</code> 来传入参数<br>传出参数需要调用 <code>registerOutParameter()</code> 来注册该参数，实例代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注册CallableStatement的第三个参数是int类型</span><br>cstmt.registerOutParameter(<span class="hljs-number">3</span>, Types.INTEGER)<br></code></pre></td></tr></table></figure><p>调用存储过程实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.sql.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableStatementTest</span><br>&#123;<br><span class="hljs-keyword">private</span> String driver;<br><span class="hljs-keyword">private</span> String url;<br><span class="hljs-keyword">private</span> String user;<br><span class="hljs-keyword">private</span> String pass;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initParam</span><span class="hljs-params">(String paramFile)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 使用Properties类来加载属性文件</span><br><span class="hljs-type">var</span> <span class="hljs-variable">props</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>props.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(paramFile));<br>driver = props.getProperty(<span class="hljs-string">&quot;driver&quot;</span>);<br>url = props.getProperty(<span class="hljs-string">&quot;url&quot;</span>);<br>user = props.getProperty(<span class="hljs-string">&quot;user&quot;</span>);<br>pass = props.getProperty(<span class="hljs-string">&quot;pass&quot;</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callProcedure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 加载驱动</span><br>Class.forName(driver);<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 获取数据库连接</span><br><span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, pass);<br><span class="hljs-comment">// 使用Connection来创建一个CallableStatment对象</span><br><span class="hljs-type">CallableStatement</span> <span class="hljs-variable">cstmt</span> <span class="hljs-operator">=</span> conn.prepareCall(<br><span class="hljs-string">&quot;&#123;call add_pro(?, ?, ?)&#125;&quot;</span>))<br>&#123;<br>cstmt.setInt(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>);<br>cstmt.setInt(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">// 注册CallableStatement的第三个参数是int类型</span><br>cstmt.registerOutParameter(<span class="hljs-number">3</span>, Types.INTEGER);<br><span class="hljs-comment">// 执行存储过程</span><br>cstmt.execute();<br><span class="hljs-comment">// 获取，并输出存储过程传出参数的值。</span><br>System.out.println(<span class="hljs-string">&quot;执行结果是: &quot;</span> + cstmt.getInt(<span class="hljs-number">3</span>));<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">ct</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallableStatementTest</span>();<br>ct.initParam(<span class="hljs-string">&quot;mysql.ini&quot;</span>);<br>ct.callProcedure();<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDBC常用接口和类及其编程步骤</title>
    <link href="/2022/05/11/Java/JDBC/JDBC%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/05/11/Java/JDBC/JDBC%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常用接口和类及其简介"><a href="#常用接口和类及其简介" class="headerlink" title="常用接口和类及其简介"></a>常用接口和类及其简介</h2><ol><li><p>DriverManager：用于管理JDBC驱动的服务类，该类主要功能是获取Connection对象，从而连接数据库。</p><p> 常用方法：</p><p> | 函数原型                                                     | 功能                 | 参数说明                                             |<br> | —————————————————————————————— | —————————— | —————————————————————————— |<br> | public  static Connection getConnection(String url,String user, String pass) | 与指定数据库进行连接 | url:数据库端口<br />user：用户名<br />pass：用户密码 |</p></li></ol><ol><li><p>Connection：代表数据库连接对象，每个Connection对象代表一个物理连接会话，要想访问数据库，必须先获得数据库连接。</p><p> 常用方法：</p><p> | 函数原型                                       | 功能                                  | 参数说明     |<br> | ——————————————————————— | ——————————————————- | —————— |<br> | Statement createStatement()                    | 返回一个新创建的Statement对象         | 无           |<br> | PreparedStatement prepareStatement(String sql) | 返回一个新创建的PreparedStatement对象 | sql：SQL语句 |<br> | CallableStatement prepareCall(String sql)      | 返回一个新创建的CallableStatement对象 | sql：SQL语句 |</p><p> 控制事务的方法：</p><p> | 函数原型                               | 功能                       | 参数说明                                                     |<br> | ——————————————————— | ————————————— | —————————————————————————————— |<br> | Savepoint setSavepoint()               | 创建一个保存点             | 无                                                           |<br> | Savepoint setSavepoint(String name)    | 以指定的名字创建一个保存点 | name：指定保存点的名字                                       |<br> | void rollback(Savepoint savepoint)     | 将事务会滚到指定保存点     | savepoint:指定保存点                                         |<br> | void rollback()                        | 回滚事务                   | 无                                                           |<br> | void setAutoCommit(boolean autoCommit) | 设置自动提交，即设置事务   | autoCommit:当为false时，关闭自动提交，打开事务<br />当为true，打开自动提交，关闭事务。<br /> |<br> | void commit()                          | 提交事务                   | 无                                                           |</p></li></ol><ol><li><p>Statement：用于执行SQL语句的工具接口，该对象既可用于执行DDL、DCL语句，也可用于执行DML语句，还可用于SQL查询，当执行SQL查询时，返回查询得到的结果集。</p><p> 常用方法：</p><p> | 函数原型                           | 功能                                                         | 参数说明         |<br> | ————————————————— | —————————————————————————————— | ———————— |<br> | ResultSet executeQuery(String sql) | 执行查询语句，并返回查询结果                                 | sql：查询语句    |<br> | int executeUpdate(String sql)      | 执行DML，返回受影响行数,也可用于执行DDL语句,返回0            | sql:DML或DDL语句 |<br> | boolean execute(String sql)        | 执行任何SQL语句，如果执行后第一个结果为ResultSet，返回true<br />如果为受影响行数或没有结果，返回0 | sql：SQL语句     |</p></li><li><p>PreparedStatement:预编译的对象。PreparedStatement是Statement的子接口，它允许数据库预编译SQL语句(这些SQL语句通常带有参数)，以后每次只改变SQL命令的参数，不用重新编译，性能更好。</p><p> 常用方法：</p><p> <code>void setXxx(int parameterIndex, Xxx value)</code></p><p>  该方法根据传入参数值的类型不同，需要使用不同的方法，传入的值根据索引传给SQ语句指定位置的参数。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p> PreparedStatement同样有上述Statement的方法，只不过没有参数sql，因为PreparedStatement已经预编译了SQL命令。</p></li></ol><ol><li><p>ResultSet：结果集对象，该对象包含访问查询结果的方法。</p><p> 常用方法：</p><p> | 函数原型                  | 功能                                                         | 参数说明              |<br> | ————————————- | —————————————————————————————— | ——————————- |<br> | void close()              | 释放结果集对象                                               | 无                    |<br> | boolean absolute(int row) | 将结果集的记录指针移动到第row行<br />如果row为负数，则移到倒数第row行 | row：指定对应行的位置 |<br> | void beforeFirst()        | 将记录指针移动到首行之前，如果所指记录<br />是有效记录，返回true，否则返回false | 无                    |<br> | boolean first()           | 将记录指针移动到第一行，返回值同上                           | 无                    |<br> | boolean previous()        | 将记录指针移动到上一行，返回值同上                           | 无                    |<br> | boolean next()            | 移动至下一行，返回值同上                                     | 无                    |<br> | boolean last()            | 移动至最后一行，返回值同上                                   | 无                    |<br> | void afterLast()          | 记录指针移动至最后一行之后                                   | 无                    |<br> |                           |                                                              |                       |</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p> 结果集行从1开始。</p></li></ol><h2 id="JDBC编程步骤"><a href="#JDBC编程步骤" class="headerlink" title="JDBC编程步骤"></a>JDBC编程步骤</h2><ol><li><p>加载数据库驱动：通常使用Class类的forName()静态方法加载驱动。</p><p> <code>Class.forName(driverClass)</code></p><p> driverClass就是数据库驱动类对应字符串，不同数据库系统是不同的。</p><p> 加载MySQL驱动：<code>Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;)</code></p></li></ol><ol><li><p>通过DriverManager获取数据库连接</p><p> <code>DriverManager.getConnection(String url, String user, String pass)</code></p><p> 参数分别为：数据库URL, 登陆数据库用户名和密码</p><p> URL遵循如下写法：</p><p> jdbc:subprotocol:other stuff</p><p> MySQL数据库URL写法为：jdbc:mysql://hostname:port/databasename</p><p> 其中，hostname是数据库主机名称，在本机上就是localhost</p><p> port就是端口，是3306，databasename就是要使用的数据库。</p></li></ol><ol><li><p>通过Connection对象创建Statement对象，创建方法有三个：</p><p> | 函数原型                     | 功能                                       | 参数说明     |<br> | —————————————— | ————————————————————— | —————— |<br> | createStatement()            | 创建基本的Statement对象                    | 无           |<br> | prepareStatement(String sql) | 根据传入的SQL语句创建预编译的Statement对象 | sql：SQL语句 |<br> | prepareCall(String sql)      | 根据传入的SQL语句创建CallableStatement对象 | sql：SQL语句 |</p></li></ol><ol><li>使用Statement对象执行SQL语句，所有Statement对象都有三个方法执行SQL语句</li></ol><pre><code class="hljs">| 函数原型                 | 功能                             | 参数说明 || ------------------------ | -------------------------------- | -------- || execute()                | 可以执行任何SQL语句，但比较麻烦  | 无       || executeUpdate()          | 主要执行DML和DDL语句             | 无       || ResultSet executeQuery() | 只能执行查询语句，返回查询结果集 | 无       |</code></pre><ol><li><p>操作结果集。如果是查询语句，可以操作ResultSet对象取出查询结果，并进行操作。</p><p> 除了上述ResultSet常用操作方法外，还有一个：</p><p> <code>getXxx()</code> 该方法获取记录指针指向的行，特定列的值，可以传入列索引为参数，也可以传入列名为参数。</p><p> <strong>列索引从1开始</strong>。</p></li></ol><ol><li><p>回收数据库资源：包括关闭ResultSet资源、Statement和Connection资源。</p><ol><li><p>推荐将这些对象的定义放在try块，程序会自动回收。</p></li><li><p>也可以使用对象的close()方法。</p></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>JDBC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过反射查看类信息</title>
    <link href="/2022/05/11/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8D%E5%B0%84/3-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9F%A5%E7%9C%8B%E7%B1%BB%E4%BF%A1%E6%81%AF/"/>
    <url>/2022/05/11/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8D%E5%B0%84/3-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9F%A5%E7%9C%8B%E7%B1%BB%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java程序许多对象运行时会出现两种类型：编译时类型、运行时类型。</p><p>例如<code>Person p = new Student();</code>，在编译时p变量是Person类型，运行时是Student类型。</p><p>但程序又需要调用该对象运行时类型的方法。</p><p>为了解决这个问题，程序需要在运行时发现对象和类的真实信息，有两种方法</p><ul><li>第一种是假设在编译和运行时都完全知道类型的具体信息，可以使用instanceof运算符进行判断，再利用强制类型转换，转换为运行时类型的变量。</li><li>第二种是程序只能依靠运行时来发现该对象和类的真实信息，只能用反射。</li></ul><h2 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h2><p>每个类被加载，系统都会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类，在Java程序中获得Class对象通常有三种方式。</p><ol><li>使用Class类的forName(String className)静态方法，参数是某个类的全限定类名</li><li>调用某个类的class属性来获取该类对应Class对象</li><li>调用某个对象的getClass方法，该方法是Object类的一个方法，所有Java对象都可以调用。</li></ol><p>对于第一种和第二种方法，都是直接根据类来获取Class对象。相比之下，第二种有两种优势。</p><ol><li>代码更安全，程序在编译阶段就可以检查需要访问的Class对象是否存在</li><li>性能更好，无需调用方法</li></ol><p>大部分时候，都应该使用第二种方法来获取类的Class对象。如果程序只能获得一个字符串”java..lang.String”，只能使用第一种方式。</p><p>一旦获得某个类对象的Class对象之后，就可以调用方法来获取该对象和该类的真实信息了。</p><h2 id="从Class中获取信息"><a href="#从Class中获取信息" class="headerlink" title="从Class中获取信息"></a>从Class中获取信息</h2><p>Class对象有贼拉多的方法来获取信息。每个方法都可能包括重载的版本。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>反射</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-类加载器</title>
    <link href="/2022/05/11/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8D%E5%B0%84/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <url>/2022/05/11/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8D%E5%B0%84/2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>类加载器负责加载所有的类，一旦一个类被载入JVM中，同一个类就不会被再次载入了，那么，怎么才算“同一个类”。</p><p>正如一个对象有一个唯一标识，一个载入JVM的类也有一个唯一的标识。在Java中，用全限定类名作为标识；但在JVM中，一个类用全限定类名和类加载器作为唯一标识。例如，Person类的example包中，被类加载器ClassLoader的实例a所加载，它在JVM中表示为(Person, example, a)。这意味着两个类加载器加载的同名类也是不同的。</p><p>​        当JVM启动时，会形成三个类加载器组成的初始类加载器层次结构：</p><ul><li>BootStrap ClassLoader：根类加载器</li><li>Extension ClassLoader：拓展类加载器</li><li>System ClassLoader：系统类加载器</li></ul><p>BootStrap ClassLoader被称为引导类加载器，负责加载Java的核心类。</p><p>JVM的类加载机制有三种：</p><ul><li>全盘负责：当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非是显式使用另外一个类加载器</li><li>父类委托：是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己类路径加载该类。</li><li>缓存机制：缓存机制保证所有加载过的Class都会被缓存，当程序需要使用某个Class时，类加载器先从缓存区搜寻该Class，当缓存区没有，系统才会读取该类对应二进制文件，并转换为Class对象，存入缓存区。这是为什么修改Class后，必须重新启动JVM，修改才会生效的原因。</li></ul><p>类加载器之间的父子关系不是类继承上的父子关系。这里的父子关系是指类加载器实例之间的关系。</p><p>根类加载器-&gt;拓展类加载器-&gt;系统类加载器-&gt;用户类加载器</p><p>JVM的根类加载器不是由Java实现的，而且程序一般不会访问根类加载器。</p><p>类加载器加载Class大概需要8个步骤：</p><ol><li>检测此Class是否载入过，如果有，到第8步；没有执行第2步</li><li>如果父类加载器不存在(没有父类加载器，那么要么parent是根类加载器，要么自己本身就是根类加载器)，执行第四步；如果父类加载器存在，到第3步</li><li>请求使用父类加载器载入目标类，成功载入，则到第8步；否则执行第5步</li><li>请求使用根类加载器载入目标类，成功载入，到第8步；否则执行第7步</li><li>当前类加载器尝试寻找Class文件(从与此ClassLoader相关的类路径寻找)，如果找到执行第6步；找不到执行第7步</li><li>从文件中载入Class，成功载入后跳到第8步</li><li>抛出ClassNotFoundException异常</li><li>返回对应java.lang.Class对象</li></ol><p>其中，第5、6步允许重写ClassLoader的findClass()方法来实现自己的载入策略，甚至重写loadClass实现自己的载入过程。</p><h2 id="创建并使用自定义的类加载器"><a href="#创建并使用自定义的类加载器" class="headerlink" title="创建并使用自定义的类加载器"></a>创建并使用自定义的类加载器</h2><p>JVM中除了根类加载器之外的所有类加载器都是ClassLoader子类的实例。开发者可以拓展ClassLoader的子类，重写相应方法来实现自定义的类加载器。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1- 类的加载、连接和初始化</title>
    <link href="/2022/05/11/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8D%E5%B0%84/1-%20%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2022/05/11/Java/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%92%8C%E5%8F%8D%E5%B0%84/1-%20%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一部分会介绍java.lang.reflect包下的接口和类，包括Class、Method、Field、Constructor和Array，这些类分别代表类、方法、变量、构造器和数组。Java程序可以使用这些类动态的获取某个对象、某个类的运行时信息，可以动态，的创建Java对象，动态调用Java方法，访问并修改对象的成员变量值。还有该包下的两个接口，Type是Class类实现的接口，ParameterizedType则代表带泛型参数的类型。</p><p>也介绍使用Proxy和InvocationHandler来创建JDK动态代理。和JDK动态代理和AOP的内在关系。</p><h2 id="JVM和类"><a href="#JVM和类" class="headerlink" title="JVM和类"></a>JVM和类</h2><p>当运行某个java程序时，会启动一个java虚拟机进程，不管该Java程序有多么复杂，有多少线程，他们都处于Java虚拟机进程中，同一个JVM的所有线程、所有变量都使用JVM进程的内存区。</p><p>当系统出现以下几种情况，JVM进程被终止：</p><ul><li>程序运行到正常结束</li><li>程序运行到System.exit()或Runtime.getRuntime().exit()代码</li><li>程序执行过程中遇到未捕获的异常或错误而结束</li><li>程序所在平台强制结束了JVM进程</li></ul><h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>当程序使用某个类时，如果该类还未被加载到内存中，系统会通过加载、连接、初始化三个步骤来对该类进行初始化，没有意外的话，JVM会连续完成这三个步骤，所以也统称为类加载或类初始化。</p><p>类加载是指将该类的class文件读入内存，<strong>并为之创建一个java.lang.Class对象</strong>，也就是说当程序中使用任何类时，系统都会为之建立一个java.lang.Class文件。</p><p>类的加载由类加载器完成，类加载器通常由JVM提供。JVM提供的类加载器通常称为系统类加载器，除此，开发者可以继承ClassLoader基类来创建自己的类加载器。</p><p>通过使用不用的类加载器，可以从不同来源加载类的二进制数据，通常由以下几种来源：</p><ul><li>从本地文件中加载class文件，这是最常用的</li><li>从JAR包加载class文件，这种也很常见，导入的jar包就是使用这种方式，例如JDBC编程用到的驱动类jar包</li><li>通过网络加载class文件</li><li>把一个Java源文件动态编译、并执行加载</li></ul><p>类加载器无需等到 首次使用该类 才加载，Java虚拟机允许系统预先加载某些类。</p><h2 id="类的连接"><a href="#类的连接" class="headerlink" title="类的连接"></a>类的连接</h2><p>当类被加载后，系统为之生成一个对应的Class对象，然后进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中，连接又可分为三个阶段：</p><ul><li>验证：用于检验被加载的类是否有正确的内部结构，并和其他类协调一致</li><li>准备：负责为类的类变量分配内存，并设置默认初始值</li><li>解析：将类的二进制数据中的符号引用转换为直接饮用</li></ul><h2 id="类的初始化"><a href="#类的初始化" class="headerlink" title="类的初始化"></a>类的初始化</h2><p>虚拟机对类负责初始化，主要就是对类变量进行初始化，Java类变量指定初始值有两种方式：</p><ol><li>声明类变量时指定初始值</li><li>使用静态初始化块指定初始值</li></ol><p>JVM初始化一个类包括几个步骤：</p><ul><li>假如这个类还没有被加载和连接，程序先加载并连接该类</li><li>假如该类的直接父类还没有被初始化，则先初始化该直接父类</li><li>假如类中有初始化语句，系统则依次执行这些初始化语句</li></ul><p>注意：当执行第二个步骤时，系统对直接父类的初始化也遵循这三个步骤，如果该直接父类的父类也没有被初始化，那么系统会先初始化父类的直接父类，以此类推。所以JVM最先初始化的总是Object类。</p><h3 id="类初始化的时机"><a href="#类初始化的时机" class="headerlink" title="类初始化的时机"></a>类初始化的时机</h3><p>当Java程序首次通过下面6种方式来使用某个类或接口时，系统会初始化该类或接口。</p><ul><li>创建类的实例。包括，使用new操作符来创建实例，通过反射来创建实例，通过反序列化创建实例</li><li>调用某个类的类方法</li><li>访问某个类的类变量，或为该类变量赋值</li><li>使用反射强制创建某个类或接口对应的Class对象，例如<code>Class.forName(&quot;Person&quot;)</code>，如果系统未初始化Person类，那么这行代码会导致Person类被初始化，并返回对应的Class对象。</li><li>初始化某个类的子类</li><li>直接使用java.exe命令来运行某个主类</li></ul><p><strong>注意：</strong>除此之外。对于final型的类变量，如果该类变量的值在编译时就可确定下来，那么这个类变量相当于宏变量，java编译器会在编译时直接把这个类变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类初始化。</p><p>​            如果final类变量在编译时不能确定下来，必须等到运行时才可确定，如果通过该类访问类变量，会导致该类被初始化。</p><p>当使用ClassLoader加载该类时，并不会导致该类的初始化，它加载该类。当使用Class.forName()静态方法才会初始化该类。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>类加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型通配符</title>
    <link href="/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
    <url>/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们知道，String类是Object类的子类，但是List<String>不是List<Object>的子类，所以如果在方法中定义形参List<Object>，我们是不能把List<String>赋给这个形参的。</p><p>但是如果Foo是Bar的一个子类，那么Foo[]可以直接赋给Bar[]，但是G<Foo>不是G<Bar>的子类型。Foo[]自动向上转型为Bar[]的方式称为型变，也就是说Java的数组支持型变，但是Java集合不支持。</p><h2 id="使用类型通配符"><a href="#使用类型通配符" class="headerlink" title="使用类型通配符"></a>使用类型通配符</h2><p>为了表达各种泛型List的父类，可以使用类型通配符，类型通配符是一个问号 ? ，将一个问号作为类型实参传给List集合，写作：List&lt;?&gt;，意思是元素类型未知的List，这个问号称为通配符，它的元素类型可以匹配任何类型。</p><p>但这种带通配符的List仅仅表示它是各种泛型List的父类，不能把元素加入其中。</p><h2 id="设定类型通配符的上限"><a href="#设定类型通配符的上限" class="headerlink" title="设定类型通配符的上限"></a>设定类型通配符的上限</h2><p>有一种特殊情形，程序不希望这个List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类。</p><p>例如定义三个形状类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas c)</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">draw</span><span class="hljs-params">(Canvas c)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;在画布&quot;</span> + c + <span class="hljs-string">&quot;上画一个圆&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;把一个矩形画在画布&quot;</span> + c + <span class="hljs-string">&quot;上&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Canvas</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawAll</span><span class="hljs-params">(List&lt;Shape&gt; shapes)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> s :shapes)&#123;<br>            s.draw(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面drawAll方法的形参是List<Shape>，所以不能把List<Circle>和List<Rectangle>传入，为了表示List<Circle>的父类，可以使用List&lt;? extends Shape&gt;，并且把Canvas改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Canvas</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawAll</span><span class="hljs-params">(List&lt;? extends Shape&gt; shapes)</span> &#123;<br>        <span class="hljs-keyword">for</span>(Shape s :shapes)&#123;<br>            s.draw(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就可以把List<Circle>对象当成List&lt;? extends Shape&gt;使用。Shape就称为这个通配符的上限。</p><p>此处问号代表一个未知的类型，但是这个类型一定是Shape的子类型，由于程序无法确定这个受限制的通配符的具体类型，所以不能把Shape对象或者子类的对象加入到这个泛型集合。</p><p>因为程序无法确定这个类型是什么，所以没法加入。</p><p>简而言之，这种指定通配符上限的集合，<strong>只能取元素(取出的元素总是上限的类型或者其子类)，不能向集合中添加元素。</strong></p><p>对于更广泛的泛型类，指定通配符上限就是为了支持类型型变，比如Foo是Bar的子类，这样A<Foo>就相当于A&lt;? extends Bar&gt;的子类，可以将A<Foo>直接赋值给A&lt;? extends Bar&gt;类型的变量，<strong>这种型变方式称为协变。</strong></p><p>对于协变的泛型而言，他只能调用泛型类型作为返回值类型的方法(编译器会将该方法返回值当成通配符上限的类型)，而不能调用泛型类型作为参数的方法，口诀是<strong>只出不进。</strong></p><h2 id="设定类型通配符下限"><a href="#设定类型通配符下限" class="headerlink" title="设定类型通配符下限"></a>设定类型通配符下限</h2><p>Java的通配符下限使用&lt;? super 类型&gt;的方式来制定，下限的作用于上限的作用刚好相反。</p><p>制定通配符的下限是为了支持类型型变，比如Foo是Bar的子类，当程序需要一个A&lt;? super Foo&gt;的变量时，可以把A<Bar>、A<Object>赋值给它，这种型变方式称为逆变。</p><p>对于逆变的泛型集合来说，编译器只知道集合元素是下限的父类型或者该下限，但是具体哪种不知道，所以这种逆变的泛型集合只能向其中添加元素(因为实际赋值的集合元素总是逆变声明的父类，可以向上造型)，但从集合取元素时，只能被当成Object类型处理。</p><p>对于逆变的泛型来说，口诀是<strong>只进不出</strong>。要出只能被当成Object类型处理，需要强制类型转换。</p><h2 id="设定泛型形参的上限"><a href="#设定泛型形参的上限" class="headerlink" title="设定泛型形参的上限"></a>设定泛型形参的上限</h2><p>Java泛型不仅允许在使用通配符时设定上限，而且可以在定义泛型形参的时候设定上限，用于表示传给该泛型形参的实际类型要么是该上限类型要么是该上限类型的子类。</p><p>对于更极端的情况，程序需要为泛型接口设定多个上限(至多有一个父类上限，多个接口上限)，那么所有接口上限必须位于类上限的后面。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span> &amp; java.io.Serializable&gt;&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型方法</title>
    <link href="/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/"/>
    <url>/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在一些情况下，定义类、接口时没有使用泛型形参，但定义方法时想自己定义泛型形参，这也可以，Java提供了对泛型方法的支持。</p><p>假设需要实现这样一个方法，将Object数组的所有元素都放入Collection集合里，可以考虑代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fromArrayToCollection</span><span class="hljs-params">(Object[] a, Collection&lt;Object&gt; c)</span><br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>上面方法没有问题，关键在于c形参，它的泛型形参是Object，因为Collection<String>不是Object<Object>的子类，所以这个方法功能十分有限，他只能将Object[]数组的元素复制到Collection集合里，但是Object的子类不行。</p><p>使用类型通配符也不行，因为Java不允许把对象放进一个未知类型的集合中。</p><p>我们可以使用泛型方法，所谓泛型方法，就是在声明方法时，定义一个或多个泛型形参，语法格式为</p><p>修饰符 <T, S> 返回值类型 方法名(形参列表){方法体};</p><p>泛型方法与普通方法实际上就是多了泛型形参声明，放在修饰符和返回值类型之间，这样就可以把上面方法改为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">fromArrayToCollection</span><span class="hljs-params">(T[] a, Collection&lt;T&gt; c)</span><br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericMethodTest</span><br>&#123;<br><span class="hljs-comment">// 声明一个泛型方法，该泛型方法中带一个T泛型形参，</span><br><span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">fromArrayToCollection</span><span class="hljs-params">(T[] a, Collection&lt;T&gt; c)</span><br>&#123;<br><span class="hljs-keyword">for</span> (T o : a)<br>&#123;<br>c.add(o);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">oa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>Collection&lt;Object&gt; co = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 下面代码中T代表Object类型</span><br>fromArrayToCollection(oa, co);<br><span class="hljs-type">var</span> <span class="hljs-variable">sa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">100</span>];<br>Collection&lt;String&gt; cs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 下面代码中T代表String类型</span><br>fromArrayToCollection(sa, cs);<br><span class="hljs-comment">// 下面代码中T代表Object类型</span><br>fromArrayToCollection(sa, co);<br><span class="hljs-type">var</span> <span class="hljs-variable">ia</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">100</span>];<br><span class="hljs-type">var</span> <span class="hljs-variable">fa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float</span>[<span class="hljs-number">100</span>];<br><span class="hljs-type">var</span> <span class="hljs-variable">na</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Number</span>[<span class="hljs-number">100</span>];<br>Collection&lt;Number&gt; cn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-comment">// 下面代码中T代表Number类型</span><br>fromArrayToCollection(ia, cn);<br><span class="hljs-comment">// 下面代码中T代表Number类型</span><br>fromArrayToCollection(fa, cn);<br><span class="hljs-comment">// 下面代码中T代表Number类型</span><br>fromArrayToCollection(na, cn);<br><span class="hljs-comment">// 下面代码中T代表Object类型</span><br>fromArrayToCollection(na, co);<br><span class="hljs-comment">// 下面代码中T代表String类型，但na是一个Number数组，</span><br><span class="hljs-comment">// 因为Number既不是String类型，</span><br><span class="hljs-comment">// 也不是它的子类，所以出现编译错误</span><br><span class="hljs-comment">//fromArrayToCollection(na, cs);</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类、接口声明中定义的泛型参数可以在整个类、接口中使用，方法中的泛型参数只能在该方法中使用。</p><p>与类、接口中使用泛型参数不同的是，方法中的泛型参数无序显式传入实际类型参数，如上例定义的方法，不需要在调用方法前传入String、Object等类型，系统依然可以知道为泛型实际传入的类型。</p><h2 id="泛型方法和类型通配符的区别"><a href="#泛型方法和类型通配符的区别" class="headerlink" title="　泛型方法和类型通配符的区别"></a>　泛型方法和类型通配符的区别</h2><p>大多数时候都可用泛型方法来代替类型通配符。</p><p><strong>泛型方法允许泛型形参被用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与参数之间的依赖关系，如果没有这样的依赖关系，就不应该使用泛型方法。</strong></p><p>当然也可以同时使用泛型方法和通配符，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;T&gt; dest, List&lt;? extends T&gt; src)</span><br>    &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面方法的dest和scr存在明显依赖关系，从scr复制出来的元素可以丢进dest中，这里使用通配符是因为：该方法不需要向src集合添加元素，也不需要修改src集合的元素，所以使用类型通配符，不需要使用泛型方法。</p><p>当然，也可以将上面方法改为完全使用泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Collections</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(List&lt;T&gt; dest, List&lt;S&gt; src)</span>&#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个可以代替前面的方法，但注意泛型形参S，他仅仅使用了一次，其他参数的类型、方法返回值的类型都不依赖于它，因此S没有存在的必要，可以用通配符来代替S。</p><p>类型通配符与泛型方法(在方法签名中显式声明泛型形参)还有一个显著区别：类型通配符既可以在方法签名中定义形参类型，也可以用于定义变量的类型；但是泛型方法中的泛型形参必须在对应方法中显式声明。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型构造器、泛型方法重载</title>
    <link href="/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/"/>
    <url>/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%9E%84%E9%80%A0%E5%99%A8%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="泛型构造器"><a href="#泛型构造器" class="headerlink" title="泛型构造器"></a>泛型构造器</h2><p>Java允许在构造器签名中声明泛型形参，这样就产生了所谓的泛型构造器。</p><p>一旦定义了泛型构造器，接下来在调用构造器时，就不仅可以让Java根据参数类型来推断泛型形参类型，也可以显式地为构造器中的泛型形参指定实际类型。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span> &lt;T&gt; Foo(T t)<br>&#123;<br>System.out.println(t);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericConstructor</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-comment">// 泛型构造器中的T类型为String。</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-string">&quot;疯狂Java讲义&quot;</span>);<br><span class="hljs-comment">// 泛型构造器中的T类型为Integer。</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Foo</span>(<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 显式指定泛型构造器中的T类型为String，</span><br><span class="hljs-comment">// 传给Foo构造器的实参也是String对象，完全正确。</span><br><span class="hljs-keyword">new</span> &lt;String&gt; Foo(<span class="hljs-string">&quot;疯狂Android讲义&quot;</span>);<br><span class="hljs-comment">// 显式指定泛型构造器中的T类型为String，</span><br><span class="hljs-comment">// 但传给Foo构造器的实参是Double对象，下面代码出错</span><br>        <span class="hljs-comment">//new &lt;String&gt; Foo(12.3);</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面说过的菱形语法，它允许调用构造器时在构造器后使用尖括号来代表泛型信息，但是如果程序显式指定了泛型构造器声明的泛型形参的实际类型，则不可以使用菱形语法。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span>&lt;E&gt;<br>&#123;<br><span class="hljs-keyword">public</span> &lt;T&gt; MyClass(T t)<br>&#123;<br>System.out.println(<span class="hljs-string">&quot;t参数的值为：&quot;</span> + t);<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDiamondTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-comment">// MyClass类声明中的E形参是String类型。</span><br><span class="hljs-comment">// 泛型构造器中声明的T形参是Integer类型</span><br>MyClass&lt;String&gt; mc1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>&lt;&gt;(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// 显式指定泛型构造器中声明的T形参是Integer类型，</span><br>MyClass&lt;String&gt; mc2 = <span class="hljs-keyword">new</span> &lt;Integer&gt; MyClass&lt;String&gt;(<span class="hljs-number">5</span>);<br><span class="hljs-comment">// MyClass类声明中的E形参是String类型。</span><br><span class="hljs-comment">// 如果显式指定泛型构造器中声明的T形参是Integer类型</span><br><span class="hljs-comment">// 此时就不能使用&quot;菱形&quot;语法，下面代码是错的。</span><br><span class="hljs-comment">//MyClass&lt;String&gt; mc3 = new &lt;Integer&gt; MyClass&lt;&gt;(5);</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="泛型方法与方法重载"><a href="#泛型方法与方法重载" class="headerlink" title="泛型方法与方法重载"></a>泛型方法与方法重载</h2><p>因为泛型既允许设定通配符上限，也允许设定通配符下限，所以允许在一个类包含以下两个方法定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUtils</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">copy</span><span class="hljs-params">(Collection&lt;T&gt; dest, Collection&lt;? extends T&gt; src)</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">copy</span><span class="hljs-params">(Collection&lt;? <span class="hljs-built_in">super</span> T&gt; dest, Collection&lt;T&gt; src)</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个方法参数列表存在一定区别，但区别不明显，两个方法的两个参数都是Collection对象，前一个集合元素类型是后一个集合元素类型的父类。在这里定义这两个方法不会有任何错误，但是如果调用这个方法就会出现错误。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Number&gt; ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>MyUtils.copy(ln, li);<br></code></pre></td></tr></table></figure><p>两个方法都匹配，编译器无法确定到底调用哪个copy方法，所以会出现编译错误。</p><p>Java 8 改进了泛型方法的类型推断能力，主要有两个方面</p><ul><li>可以通过调用方法的上下文来推断泛型的目标类型</li><li>可在方法调用链中，将推断得到的泛型传递到最后一个方法</li></ul><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyUtil</span>&lt;E&gt;<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;Z&gt; MyUtil&lt;Z&gt; <span class="hljs-title function_">nil</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;Z&gt; MyUtil&lt;Z&gt; <span class="hljs-title function_">cons</span><span class="hljs-params">(Z head, MyUtil&lt;Z&gt; tail)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>E <span class="hljs-title function_">head</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InferenceTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-comment">// 可以通过方法赋值的目标参数来推断类型参数为String</span><br>MyUtil&lt;String&gt; ls = MyUtil.nil();<br><span class="hljs-comment">// 无需使用下面语句在调用nil()方法时指定类型参数的类型</span><br>MyUtil&lt;String&gt; mu = MyUtil.&lt;String&gt;nil();<br><span class="hljs-comment">// 可调用cons方法所需的参数类型来推断类型参数为Integer</span><br>MyUtil.cons(<span class="hljs-number">42</span>, MyUtil.nil());<br><span class="hljs-comment">// 无需使用下面语句在调用nil()方法时指定类型参数的类型</span><br>MyUtil.cons(<span class="hljs-number">42</span>, MyUtil.&lt;Integer&gt;nil());<br><br><span class="hljs-comment">// 希望系统能推断出调用nil()方法类型参数为String类型，</span><br><span class="hljs-comment">// 但实际上Java 8依然推断不出来，所以下面代码报错</span><br><span class="hljs-comment">//String s = MyUtil.nil().head();</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> MyUtil.&lt;String&gt;nil().head();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面前两行代码作用完全一样，系统会推断出泛型参数为String，后两行代码作用也完全一样，系统会推断出Z的实参为Integer。</p><p>但是这种推断并不是万能的，例如下面代码就是错误的</p><p><code>String s = MyUtil.nil().head();</code>，希望系统可以推断出来，但是推断不出来，代码报错，需要改为<code>String s  = Mytil.&lt;String&gt;nil().head();</code>。</p><h3 id="擦除和转换"><a href="#擦除和转换" class="headerlink" title="擦除和转换"></a>擦除和转换</h3><p>在严格泛型代码中，带泛型声明的类应该总带着类型参数，但是为了和老的Java代码保持一致，也允许在使用带泛型声明的类时不指定实际类型，此时被称为原始类型，默认是声明该泛型形参时指定的第一个上限类型。</p><p>当把一个指定了泛型实参的对象赋给一个没有指定泛型实参的对象时，所有在尖括号之间的类型信息被扔掉，比如一个List<String>类型被转换为List，该List对集合元素的类型检查变成了泛型参数的上限即Object，这叫做擦除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt;<br>&#123;<br>T size;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Apple</span><span class="hljs-params">()</span><br>&#123;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Apple</span><span class="hljs-params">(T size)</span><br>&#123;<br><span class="hljs-built_in">this</span>.size = size;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSize</span><span class="hljs-params">(T size)</span><br>&#123;<br><span class="hljs-built_in">this</span>.size = size;<br>&#125;<br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.size;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErasureTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br>Apple&lt;Integer&gt; a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>&lt;&gt;(<span class="hljs-number">6</span>);    <span class="hljs-comment">// ①</span><br><span class="hljs-comment">// a的getSize方法返回Integer对象</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">as</span> <span class="hljs-operator">=</span> a.getSize();<br><span class="hljs-comment">// 把a对象赋给Apple变量，丢失尖括号里的类型信息</span><br><span class="hljs-type">Apple</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a;      <span class="hljs-comment">// ②</span><br><span class="hljs-comment">// b只知道size的类型是Number</span><br><span class="hljs-type">Number</span> <span class="hljs-variable">size1</span> <span class="hljs-operator">=</span> b.getSize();<br><span class="hljs-comment">// 下面代码引起编译错误</span><br><span class="hljs-comment">//Integer size2 = b.getSize();  // ③</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上面代码定义一个带泛型形参的类Apple，上限是Number，当把a对象赋给不带泛型信息的b变量，编译器就会丢失a对象的泛型信息，因为Apple泛型形参的上限是Number，所以编译器知道b的getSize方法返回Number类型，但具体是Number的哪个子类，编译器不清楚。</p><p>从逻辑上看，List<String>是List的子类，如果直接把List对象赋给List<String>对象，应该会编译错误，但实际上不会，编译器仅会提示”未经检查的转换”。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErasureTest2</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br>List&lt;Integer&gt; li = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>li.add(<span class="hljs-number">6</span>);<br>li.add(<span class="hljs-number">9</span>);<br><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> li;<br><span class="hljs-comment">// 下面代码引起“未经检查的转换”的警告，编译、运行时完全正常</span><br>List&lt;String&gt; ls = list;     <span class="hljs-comment">// ①</span><br><span class="hljs-comment">// 但只要访问ls里的元素，如下面代码将引起运行时异常。</span><br>System.out.println(ls.get(<span class="hljs-number">0</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java允许把list赋给ls，但是list变量此时引用的是List<Integer>集合，所以当试图把集合元素当成String类型取出来的时候，会引发ClassCastException异常。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型接口、泛型类</title>
    <link href="/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB/"/>
    <url>/2022/05/11/Java/%E6%B3%9B%E5%9E%8B/%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%80%81%E6%B3%9B%E5%9E%8B%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java增加泛型支持是为了让集合记住其元素的数据类型。在没有泛型之前，如果把一个对象放进集合，集合会忘记对象的数据类型，而统一当成Object类型处理，当程序从集合中取出来就需要进行强制类型转换。</p><p>增加了泛型后的集合，可以记住其元素的类型，并且可以在编译的时候检查集合中元素的类型。</p><h2 id="泛型入门"><a href="#泛型入门" class="headerlink" title="泛型入门"></a>泛型入门</h2><p>如果定义一个只想保存String类型的List集合，使用泛型后，如果向集合添加Integer对象，则编译时会出现错误。</p><p>Java引入了参数化类型的概念，允许程序在创建集合时指定集合元素的类型，Java的参数化类型被称为泛型。</p><p>例如:<code>List&lt;String&gt; str = new ArrayList&lt;String&gt;();</code>，就创建了一个只可以保存字符串类型的List集合。</p><p>我们还可以去掉后面ArrayList构造器中的指定类型，即<code>List&lt;String&gt; str = new ArrayList&lt;&gt;();</code>和上述例子是一样的，因为Java会推断后面尖括号里是什么类型。这种语法被称为菱形语法。</p><p>需要说明的是，如果使用var定义变量，那么就不能使用菱形语法。</p><h2 id="定义泛型接口、类"><a href="#定义泛型接口、类" class="headerlink" title="定义泛型接口、类"></a>定义泛型接口、类</h2><p>泛型，就是允许在定义类、接口和方法时使用类型形参，这个类型形参(或者叫做泛型)将在声明变量，创建对象、调用方法时动态指定(即传入实际类型参数，称为类型实参）。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">List</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//E可做为类型使用</span><br>    <span class="hljs-comment">//下面方法可以使用E作为参数类型</span><br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E x)</span>;<br>    Iterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    E <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">//定义该接口时使用了两个泛型形参</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-comment">//在该接口中K,V完全可以作为类型使用</span><br>    Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span>;<br>    V <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面定义了三个带泛型的接口，这就是泛型实质：允许在定义接口、类时声明泛型形参，泛型形参在整个接口、整个类体中可以被当成类型使用，几乎所有可使用普通类型的地方都可以使用泛型。</p><p><strong>注意：包含泛型声明的类型可以在定义变量、创建对象时传入类型实参，从而可以动态产生无数个逻辑子类，但这种子类在物理上并不存在。</strong></p><p>可以为任何类、接口定义泛型声明，并不是只有集合类才可以使用泛型，虽然集合类是泛型的重要使用场所。</p><p><strong>注意：当创建带泛型的自定义类时，为该类定义构造器时，构造器名还是原来类名，不要增加泛型声明，例如定义了一个Apple<T>类，构造器名仍为Apple，但是调用该构造器时要使用Apple<T>的形式。</strong></p><h2 id="从泛型类派生子类"><a href="#从泛型类派生子类" class="headerlink" title="　从泛型类派生子类"></a>　从泛型类派生子类</h2><p>当创建带泛型声明接口、父类之后，可以为接口创建实现类，或子类继承父类，此时，接口和父类不应该包含泛型形参，而应该是为形参赋一个类型实参，或者直接写接口、父类的名字，没有后面的尖括号。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&lt;T&gt; &#123;<br><br>        <span class="hljs-keyword">private</span> T info;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(T info)</span> &#123;<br><br>                <span class="hljs-built_in">this</span>.info = info;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInfo</span><span class="hljs-params">(T info)</span> &#123;<br>                <span class="hljs-built_in">this</span>.info = info;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.info;<br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&lt;String&gt; &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(String info)</span> &#123;<br>                <br>                <span class="hljs-built_in">super</span>(info);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInfo</span><span class="hljs-params">(String info)</span> &#123;<br>                <span class="hljs-built_in">super</span>.setInfo(info);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getInfo();<br>        &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span> &#123;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">C</span><span class="hljs-params">(Object info)</span> &#123;<br>                <span class="hljs-built_in">super</span>(info);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInfo</span><span class="hljs-params">(Object info)</span> &#123;<br>                <span class="hljs-built_in">super</span>.setInfo(info);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getInfo</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.getInfo();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建B、C两个类的写法都是正确的，创建B类时为泛型形参赋了String的类型实参，则子类重写父类方法所有T的地方都替换成String，创建C类时，没有传类型实参，这称为原始类型(raw type)，Java编译器可能会发出警告，并且会被T形参全部当成Object处理。</p><p>而<code>class D extends A&lt;T&gt; &#123;&#125;</code>这样的写法是错误的。</p><p><strong>注意：并不存在泛型类，例如系统并不会为ArrayList<String>生成新的class文件，也不会把它当成新类处理，对于Java来说，他们都被当成同一个类处理，在内存中，占用一块内存空间。因此在静态方法、静态初始化块中或者静态变量的声明和初始化中不允许使用泛型形参。</strong></p><p>同时instanceof运算符后不允许使用泛型类。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>泛型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RandomAccessFile</title>
    <link href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/RandomAccessFile/"/>
    <url>/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/RandomAccessFile/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>RandomAccessFile是Java输入/输出体系功能最丰富的文件内容访问类，它既可以读取文件内容，也可以写入文件内容，与普通输入/输出类不同的是，它支持“任意访问”，即程序可以从文件的任何位置开始写入或者读取。</p><p>RandomAccessFile允许自由定位记录指针，如果程序需要向已经存在的文件追加内容，则需要使用RandomAccessFile类。</p><p>当新创建一个RandomAccessFile对象时，文件记录指针位于开头（也就是0处），RandomAccessFile包含了两个方法来操作文件记录指针：</p><p><strong>long getFilePointer()</strong></p><p>功能：得到文件记录指针目前的位置</p><p>参数：无</p><p>返回值：返回记录指针位置</p><hr><p><strong>void seek(long pos)</strong></p><p>功能：将文件指针定位到pos位置</p><p>参数：</p><ul><li>pos:想要定位的文件位置</li></ul><p>返回值：无</p><hr><p>RandomAccessFile既可以读取文件内容也可以写入文件，所有它也包含了InputStream的三个read()方法，和OutputStream的三个write()方法，用法和原来一样。</p><p>除此之外，RandomAccessFile还包含一系列readXxx()方法和writeXxx()方法来完成输入输出。</p><p>RandomAccessFile本身有两个构造器</p><p><strong>RandomAccessFile( File file, String mode)</strong>和<strong>RandomAccessFile( String name, String mode)</strong></p><p>前一个使用String参数来指定文件名，后一个使用File来指定文件本身。</p><p>还有一个mode参数，指定文件以什么形式打开，有四个值：</p><ul><li>“r” :以只读方式打开文件，如果执行写入，会出现异常</li><li>“rw”：以读写方式打开文件，如果文件不存在，则会创建该文件</li><li>“rws”：以读写方式打开文件，相对于”rw”模式，还要求对文件内容或元数据的每个更新都同步写入到底层存储设备。</li><li>“rwd”：以读写方式打开文件，相对于”rw”模式，还要求对文件内容的每个更新都同步写入到底层存储设备。</li></ul><p>例子：使用RandomAccessFile来访问指定的中间部分数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">hello</span>  &#123;<br><br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String  args[])</span>  <span class="hljs-keyword">throws</span> IOException<br>        &#123;<br>                <span class="hljs-keyword">try</span>(<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;poem.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>))<br>                &#123;<br>                        System.out.println(raf.getFilePointer());<br><br>                        raf.seek(<span class="hljs-number">7</span>);<br><br>                        <span class="hljs-type">byte</span>[] bbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">hasread</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>                        <span class="hljs-keyword">while</span>((hasread = raf.read(bbuf)) &gt; <span class="hljs-number">0</span> )<br>                        &#123;<br>                                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bbuf, <span class="hljs-number">0</span>, hasread));<br>                        &#125;<br><br>                &#125;<br>                <span class="hljs-keyword">catch</span> (IOException e)<br>                &#123;<br>                        e.printStackTrace();<br>                &#125;<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例子：向指定文件后追加内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">hello</span>  &#123;<br><br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String  args[])</span>  <span class="hljs-keyword">throws</span> IOException<br>        &#123;<br>                <span class="hljs-keyword">try</span>(<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;poem.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>))<br>                &#123;<br>                        raf.seek(raf.length());<br><br>                        raf.write(<span class="hljs-string">&quot;我爱唐诗！\r\n&quot;</span>.getBytes());<br><br>                &#125;<br>                <span class="hljs-keyword">catch</span> (IOException e)<br>                &#123;<br>                        e.printStackTrace();<br>                &#125;<br><br>        &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong></p><p>RandomAccessFile依然不能向文件指定位置插入内容，如果直接将文件指针移动到中间某位置然后输出，新输出的内容会覆盖文件指针后面的内容，如果要插入，应该先把插入点后面的内容读入缓冲区，然后插入数据，最后把缓冲区内容追加到文件后面。</p><p>例子：实现了向指定文件、指定位置插入内容的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Hello;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">hello</span>  &#123;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String filename, <span class="hljs-type">long</span> pos, String insertContent)</span><span class="hljs-keyword">throws</span> IOException<br>        &#123;<br>                <span class="hljs-type">File</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> File.createTempFile(<span class="hljs-string">&quot;tmp&quot;</span>, <span class="hljs-literal">null</span>);<br><br>                tmp.deleteOnExit();<br><br>                <span class="hljs-keyword">try</span>(<span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;poem.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br>                    <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">tmpIn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(tmp);<br>                    <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">tmpOut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(tmp))<br>                &#123;<br><br>                        raf.seek(pos);<br><br>                        <span class="hljs-type">byte</span>[] bbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">64</span>];<br><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">hasread</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>                        <span class="hljs-keyword">while</span>((hasread = raf.read(bbuf)) &gt; <span class="hljs-number">0</span>)<br>                        &#123;<br>                                tmpOut.write(bbuf, <span class="hljs-number">0</span>, hasread);<br>                        &#125;<br><br>                        raf.seek(pos);<br><br>                        raf.write(insertContent.getBytes());<br><br>                        <span class="hljs-keyword">while</span>((hasread = tmpIn.read(bbuf)) &gt; <span class="hljs-number">0</span>)<br>                        &#123;<br>                                raf.write(bbuf, <span class="hljs-number">0</span>, hasread);<br>                        &#125;<br><br><br>                &#125;<br><br>        &#125;<br><br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String  args[])</span>  <span class="hljs-keyword">throws</span> IOException<br>        &#123;<br>                insert(<span class="hljs-string">&quot;poem.txt&quot;</span>, <span class="hljs-number">8</span>, <span class="hljs-string">&quot;插入的内容\r\n&quot;</span>);<br><br>        &#125;<br><br><br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>输入输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO.2</title>
    <link href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/NIO.2/"/>
    <url>/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/NIO.2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java 7对原有NIO进行重大改进，主要包含两方面内容</p><ul><li>提供了全面的文件IO和文件系统访问支持</li><li>基于异步Channel的第二个改进</li></ul><h2 id="Path、Paths和Files核心API"><a href="#Path、Paths和Files核心API" class="headerlink" title="Path、Paths和Files核心API"></a>Path、Paths和Files核心API</h2><p>NIO.2引入了一个Path接口，Path接口代表一个平台无关的平台路径，除此，NIO.2还提供了Files、Paths两个工具类，其中Files包含大量静态方法来操作文件，Paths提供了两个方法返回Path。</p><p>Path接口的常用方法</p><p><strong>Path getFileName()</strong></p><p>功能：返回此路径表示的文件或者目录名称作为Path对象返回，文件名是离根目录最远的元素</p><p>参数：无</p><p>返回值：Path对象</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:/a/b/c&quot;</span>);<br><br><span class="hljs-type">Path</span> <span class="hljs-variable">path1</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:/a/b/c/1.txt&quot;</span>);<br><br><span class="hljs-type">Path</span> <span class="hljs-variable">pathName1</span> <span class="hljs-operator">=</span> path.getFileName();<br><br><span class="hljs-type">Path</span> <span class="hljs-variable">pathName2</span> <span class="hljs-operator">=</span> path1.getFileName();<br><br>System.out.println(pathName1 + <span class="hljs-string">&quot;    &quot;</span> + pathName2);<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421110250155.png" alt="image-20200421110250155"></p><hr><p><strong>Path getName(int index)</strong></p><p>功能：以Path对象的形式返回此路径的名称元素</p><p>参数：</p><ul><li>index：以离根目录最近的元素名称为第一个，索引为0，以此类推</li></ul><p>返回值：以Path对象返回的对应元素名称</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:/a/b/c&quot;</span>);<br><br><span class="hljs-type">Path</span> <span class="hljs-variable">path1</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:/a/b/c/1.txt&quot;</span>);<br><br>System.out.println(path.getName(<span class="hljs-number">1</span>));<br><br>System.out.println(path1.getName(<span class="hljs-number">2</span>));<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421110557201.png" alt="image-20200421110557201"></p><hr><p><strong>int getNameCount()</strong></p><p>功能：返回路径中的名称元素数</p><p>参数：无</p><p>返回值：名称元素数，除去根目录</p><p>例子</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Path</span> <span class="hljs-keyword">path</span> = Paths.<span class="hljs-keyword">get</span>(&quot;D:/a/b/c&quot;);<br><br><span class="hljs-type">Path</span> path1 = Paths.<span class="hljs-keyword">get</span>(&quot;D:/a/b/c/1.txt&quot;);<br><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">path</span>.getNameCount());<br><br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(path1.getNameCount());<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="C:\Users\Bu'l'l'shi't\AppData\Roaming\Typora\typora-user-images\image-20200421110747591.png" alt="image-20200421110747591" style="zoom:150%;" /></p><hr><p><strong>Path getParent()</strong></p><p>功能：获得次路径的父路径</p><p>参数：无</p><p>返回值：以Path对象形式返回父路径，如果没有父路径，返回null</p><p><strong>注意：</strong>如果是以绝对路径创建Path对象，返回的也是绝对路径，相对路径一样。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:/a/b/c&quot;</span>);<br><br><span class="hljs-type">Path</span> <span class="hljs-variable">path1</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:/a/b/c/1.txt&quot;</span>);<br><br>System.out.println(path.getParent());<br><br>System.out.println(path1.getParent());<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421111101001.png" alt="image-20200421111101001"></p><hr><p><strong>Path getRoot()</strong></p><p>功能：获得此路径的根路径</p><p>参数：无</p><p>返回值：此路径的根路径作为Path对象返回，若没有则返回null</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:/a/b/c&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">path1</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:/a/b/c/1.txt&quot;</span>);<br><span class="hljs-type">Path</span> <span class="hljs-variable">path2</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;.&quot;</span>);<br>System.out.println(path.getRoot());<br>System.out.println(path1.getRoot());<br>System.out.println(path2.getRoot());<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421111320483.png" alt="image-20200421111320483"></p><hr><p><strong>boolean isAbsolute()</strong></p><p>功能：判断次路径是否为绝对路径</p><p>参数：无</p><p>返回值：若是绝对路径返回true，否则false</p><hr><p><strong>Path toAbsolutePath()</strong></p><p>功能：获得此路径的绝对路径的Path对象</p><p>参数：无</p><p>返回值：绝对路径的Path对象</p><p><strong>注意：</strong>如果此路径已经是绝对路径，则此方法就返回此路径</p><hr><p>Files工具类同样提供了一系列操作文件的方法，包括创建目录，文件，删除目录文件，复制文件，输入输出文件等等</p><p>鉴于方法太多，就不写这了，</p><p>链接———&gt;<a href="https://www.apiref.com/java11-zh/java.base/java/nio/file/Files.html#copy(java.nio.file.Path,java.nio.file.Path,java.nio.file.CopyOption...">Files工具类</a>)</p><h2 id="使用FileVisitor遍历文件和目录"><a href="#使用FileVisitor遍历文件和目录" class="headerlink" title="使用FileVisitor遍历文件和目录"></a>使用FileVisitor遍历文件和目录</h2><p>Files工具类提供了两个方法来遍历文件和子目录</p><p><strong>Path walkFileTree(Path start, FileVisitor&lt;? super Path&gt; visitor)</strong></p><p>功能：遍历start路径下的所有文件和子目录</p><p>参数：</p><ul><li>start：需要遍历的根目录</li><li>visitor：文件访问器</li></ul><p>返回值：返回起始文件，即start路径对应Path对象</p><hr><p><strong>Path walkFileTree(Path start, Set<FileVisitOption> options, int maxDepth, FileVisitor&lt;? super Path&gt; visitor)</strong></p><p>功能：遍历start路径下所有文件和子目录</p><p>参数：</p><ul><li>start：需要遍历的起始目录</li><li>options：遍历选项</li><li>maxDepth：遍历深度</li><li>visitor：文件访问器</li></ul><p>返回值：返回起始文件，即start路径对应Path对象</p><hr><p>其中两个方法中都有FileVisitor&lt;? super Path&gt;，文件访问器，在遍历文件和子目录时都会触发FileVisitor中相应的方法</p><p>FileVisitor定义了四个方法</p><ul><li>FileVisitResult postVisitDirectory(T dir, IOException exc)：访问子目录<strong>之后</strong>触发该方法</li><li>FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)：访问子目录<strong>之前</strong>触发该方法</li><li>FileVisitResult visitFile(T file, BasicFileAttributes attrs)：访问file文件时触发该方法</li><li>FileVisitResult preVisitDirectory(T file, IOException exc)：访问file文件失败后触发该方法</li></ul><p>上面四个方法都返回一个FileVisitResult对象，它是一个枚举类，代表了访问之后的后续行为</p><ul><li>CONTINUE：继续访问</li><li>SKIP_SIBLINGS：继续访问，但不访问该文件或目录的兄弟文件或者目录</li><li>SKIP_SUBTREE：继续访问，但不访问该文件或目录的子目录树</li><li>TERMINATE：终止访问</li></ul><p>其中第二个方法中，有一个Set<FileVisitOption>   options参数，用来定义文件树遍历选项，它是一个枚举类，只有一个常量：FOLLOW_LINKS，跟随符号链接。</p><p>符号链接：在windows上就是快捷方式，包含一条以绝对路径或相对路径的形式指向其他文件或者目录，对符号链接文件进行读写会表现为直接对目标文件进行操作，但是如果删除一个符号链接，它指向的目标文件不受影响。</p><p>还有一个参数maxDepth，就是遍历的深度</p><p>这两个方法以深度优先遍历文件，故设置了遍历深度，程序遍历到指定深度就会回退</p><p>实际编程中不需要为FileVisitor的四个方法都提供实现，可以通过继承SimpleFileVisitor(FileVisitor的实现类)来实现自己的文件访问器，这样就可以根据需要、选择性重写指定方法。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.nio.file.attribute.BasicFileAttributes;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>            <span class="hljs-comment">//遍历D盘a目录下的所有文件和子目录</span><br>            <span class="hljs-type">Path</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> Path.of(<span class="hljs-string">&quot;D:/a&quot;</span>);<br><br>            <span class="hljs-type">Path</span> <span class="hljs-variable">path1</span> <span class="hljs-operator">=</span> Files.walkFileTree(path,<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleFileVisitor</span>&lt;Path&gt;()<br>                    &#123;<br>                        <span class="hljs-comment">//访问子目录之前触发该方法</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">preVisitDirectory</span><span class="hljs-params">(Path dir, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                            System.out.println(<span class="hljs-string">&quot;正在访问&quot;</span> + dir + <span class="hljs-string">&quot;路径&quot;</span>);<br><br>                            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.preVisitDirectory(dir, attrs);<br>                        &#125;<br><br>                        <span class="hljs-comment">//访问文件之前触发该方法</span><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> FileVisitResult <span class="hljs-title function_">visitFile</span><span class="hljs-params">(Path file, BasicFileAttributes attrs)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br><br>                            System.out.println(<span class="hljs-string">&quot;正在访问&quot;</span>  + file + <span class="hljs-string">&quot;文件&quot;</span>);<br><br>                            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.visitFile(file, attrs);<br><br><br>                        &#125;<br>                    &#125;);<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200421121054150.png" alt="image-20200421121054150"></p><h2 id="使用WatchService监控文件变化"><a href="#使用WatchService监控文件变化" class="headerlink" title="使用WatchService监控文件变化"></a>使用WatchService监控文件变化</h2><p>以前Java版本中，如果程序需要监听文件变化，可以考虑启动一条后台线程，这条线程每隔一段时间去”遍历“一次指定目录的文件，如果发现遍历结果与上次结果不同，就会认为文件发生变化，但这种方式很烦碎，性能也不好。</p><p>NIO.2提供了一个方法来监听文件系统的变化</p><p>register(WatchService watcher, WatchEvent&lt;?&gt; … events):用watcher监听该path代表的目录下的文件变化，</p><p>events指定要监听哪些类型的事件。</p><p>在这个方法中，WatchService代表一个文件系统监听服务，它负责监听path代表的目录下的文件变化，一旦使用register方法完成注册后，就可以调用WatchService的三个方法来获取被监听的目录的文件变化事件</p><ul><li>WatchKey poll()：获取WatchKey，如果没有WatchKey发生就立即返回null</li><li>WatchKey poll(long timeout, TimeUnit unit)：尝试等待timeout时间就获取下一个WatchKey</li><li>WatchKey take()：获取下一个WatchKey，如果没有WatchKey发生就一直等待</li></ul><p>如果程序需要一直监控。则应该选择使用take()方法</p><p>例子：示范使用WatchService监控D盘a目录下文件的变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.nio.file.attribute.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WatchServiceTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br><span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 获取文件系统的WatchService对象</span><br><span class="hljs-type">WatchService</span> <span class="hljs-variable">watchService</span> <span class="hljs-operator">=</span> FileSystems.getDefault()<br>.newWatchService();<br><span class="hljs-comment">// 为C:盘根路径注册监听</span><br>Paths.get(<span class="hljs-string">&quot;C:/&quot;</span>).register(watchService,<br>StandardWatchEventKinds.ENTRY_CREATE,<br>StandardWatchEventKinds.ENTRY_MODIFY,<br>StandardWatchEventKinds.ENTRY_DELETE);<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 获取下一个文件改动事件</span><br><span class="hljs-type">WatchKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> watchService.take();    <span class="hljs-comment">// ①</span><br><span class="hljs-keyword">for</span> (WatchEvent&lt;?&gt; event : key.pollEvents())<br>&#123;<br>System.out.println(event.context() +<span class="hljs-string">&quot; 文件发生了 &quot;</span><br>+ event.kind()+ <span class="hljs-string">&quot;事件！&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 重设WatchKey</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">valid</span> <span class="hljs-operator">=</span> key.reset();<br><span class="hljs-comment">// 如果重设失败，退出监听</span><br><span class="hljs-keyword">if</span> (!valid)<br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="D:\各种文档\个人文档\学习总结\Java\输入输出\image\image-20200421133721588.png" alt="image-20200421133721588"></p><h2 id="访问文件属性"><a href="#访问文件属性" class="headerlink" title="访问文件属性"></a>访问文件属性</h2><p>Java 7的NIO.2提供了大量工具类来简单读取修改文件属性，这些工具类分为两大类</p><ul><li>XxxAttributeView：代表某种文件属性的视图</li><li>XxxAttributes:代表某种文件属性的”集合”</li></ul><p>程序一般通过XxxAttributeView对象来获取XxxAttributes</p><p>在这些工具类中，FileAttributeView其他XxxAttributeView的父接口，有以下几个XxxAttributeView</p><ul><li>AclFileAttributeView：通过AclFileAttributeView，开发者可以为特定文件设置ACL(Access Control List)及文件所有者属性，它的getAcl()方法返回List<AclEntry>对象，该返回值代表了该文件的权限集，通过setAcl(List)方法可以修改该文件的ACL.</li><li>BasicFileAttributeView：它可以获取或修改文件的基本属性，包括文件最后修改时间，最后访问时间，创建时间，大小等等，他的readArrtibutes()方法返回一个BasicFileAttributes对象，对文件夹基本属性的修改是通过BasicFileAttributes对象完成的</li><li>DosFileAttributeView：它主要获取或修改文件的DOS相关属性，比如文件是否可读，是否隐藏，是否为系统文件，是否为存档文件等，他的readAttributes()方法获取一个DosFileAttributes对象，对这些属性的修改其实是由DosFileAttributes对象来完成的</li><li>FileOwnerAttributeView：它主要用于获取或修改文件的所有者，他的getOwner()方法返回一个UsePrincipal对象来代表文件所有者，也可以调用setOwner(UsePrincipal owner)方法来改变文件所有者</li><li>PosixFileAttributeView：它主要用于获取或修改POSIX(Porable Operating System InterFace of INIX)属性，它的readArrtibutes()方法返回一个PosixFileAttributes对象，该对象可用于获取或修改文件的所有者，组所有者，访问权限信息，这个View只在UNIX,Linux系统上有用</li><li>UserDefinedFileAttributeView：它可以让开发者为文件设置一些自定义属性</li></ul><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> Hello;<br><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.file.*;<br><span class="hljs-keyword">import</span> java.nio.file.attribute.BasicFileAttributeView;<br><span class="hljs-keyword">import</span> java.nio.file.attribute.BasicFileAttributes;<br><span class="hljs-keyword">import</span> java.nio.file.attribute.FileOwnerAttributeView;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>            <span class="hljs-type">Path</span> <span class="hljs-variable">testpath</span> <span class="hljs-operator">=</span> Paths.get(<span class="hljs-string">&quot;D:\\a\\b\\c\\1.txt&quot;</span>);<br><br>            <span class="hljs-type">BasicFileAttributeView</span> <span class="hljs-variable">basicView</span> <span class="hljs-operator">=</span> Files.getFileAttributeView(testpath, BasicFileAttributeView.class);<br><br>            <span class="hljs-type">BasicFileAttributes</span> <span class="hljs-variable">basicAttributes</span> <span class="hljs-operator">=</span> basicView.readAttributes();<br><br>            System.out.println(<span class="hljs-string">&quot;创建时间为&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(basicAttributes.creationTime().toMillis()));<br><br>            System.out.println(<span class="hljs-string">&quot;最后访问时间为&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(basicAttributes.lastAccessTime().toMillis()));<br><br>            System.out.println(<span class="hljs-string">&quot;最后修改时间为&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(basicAttributes.lastModifiedTime().toMillis()));<br><br>            System.out.println(<span class="hljs-string">&quot;文件大小为&quot;</span> + basicAttributes.size() + <span class="hljs-string">&quot;个字节&quot;</span>);<br><br>            <span class="hljs-type">FileOwnerAttributeView</span> <span class="hljs-variable">ownerView</span> <span class="hljs-operator">=</span> Files.getFileAttributeView(testpath, FileOwnerAttributeView.class);<br><br>            System.out.println(<span class="hljs-string">&quot;该文件所属用户&quot;</span> + ownerView.getOwner());<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出</p><p><img src="D:\各种文档\个人文档\学习总结\Java\输入输出\image\image-20200421140431872.png" alt="image-20200421140431872"></p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>输入输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO</title>
    <link href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/NIO/"/>
    <url>/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/NIO/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>当时用BufferReader读取输入流数据时，如果没有读到有效数据，那么程序会在此处阻塞该线程的执行(使用InputStream的read方法读取输入流数据时，如果数据源没有数据，也会阻塞)，也就是说前面说的输入流输出流都是阻塞式的输入输出，不仅如此，传统的输入流输出流都是通过字节的移动来处理的，既然不直接处理字节流，底层也还是使用字节处理，也就是说，面向流的输入/输出系统一次只能处理一个字符，因此通常效率不高。</p><p>从jdk1.4，Java提供了一系列改进的输入输出新功能，这些功能被统称为新IO，新增了许多用于处理输入输出的类，这些类都放在java.nio包及其子包下。</p><h2 id="Java新IO概述"><a href="#Java新IO概述" class="headerlink" title="Java新IO概述"></a>Java新IO概述</h2><p>新IO和传统IO目的相同，用于输入/输出，但是新IO使用了不同的方式来处理输入输出。新IO采用内存映射文件的方式来处理输入输出，新IO将文件或者文件部分映射到内存中，这样就可以像访问内存一样来访问文件(这种方式模拟了操作系统的虚拟内存概念)，通过这种方式，进行输入输出要快得多。</p><p>Java中与新IO相关的包如下。</p><ul><li>java.nio：主要包含各种与Buffer相关的类</li><li>java.nio.channels：主要包含与Channels和Selector相关的类</li><li>java.nio.charset：主要包含与字符集相关的类</li><li>java.nio.channels.spi：主要包含与Channels相关的服务提供者编程接口</li><li>java.nio.charset.spi：包含与字符集相关的服务提供者编程接口</li></ul><p>Channel(通道)和Buffer(缓冲)是新IO的两个核心对象，Channel是对传统输入输出系统的模拟，在新IO系统中所有数据都需要通过通道传输；Channel与传统的InputStream和OutputStream最大的区别在于它提供了一个map()方法，通过这个方法可以将”一块数据“映射到内存中。</p><p>如果说传统输入输出是面向流的处理，那么新IO就是面向块的处理。</p><p>Buffer可以被理解成容器，它本质是数组，发送到Channel中的所有对象都必须放在Buffer中，而从Channel读取的数据也必须先放到Buffer。</p><p>除了Channel和Buffer之外，新IO还提供了用于将Unicode字符串应设成字节序列以及逆映射的操作的Charset类,也提供了用于支持非阻塞式输入输出的Selector类。</p><h2 id="使用Buffer"><a href="#使用Buffer" class="headerlink" title="　使用Buffer"></a>　使用Buffer</h2><p>从内部结构看，Buffer就像一个数组，可以保存多个类型相同的数据，Buffer是一个抽象类，最常用的子类是ByteBuffer，他可以在底层字节数组进行get/set操作，除了ByteBuffer外，对应其他基本数据类型(boolean除外)都有对应Buffer类:CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer和DoubleBuffer。</p><p>上面这些Buffer类，除了ByteBuffer类外，他们都采用相同或者相似的方法管理数据，这些Buffer类都没有提供构造器，通过如下一个方法来得到XxxBuffer对象</p><p>`<strong>static XxxBuffer allocate(int capacity)</strong>来创建一个容量为capacity的XxxBuffer对象。</p><p>实际使用较多的是ByteBuffer和CharBuffer类，其他Buffer子类较少用到，其中ByteBuffer类还有一个子类：MappedByteBuffer，它用于表示Channel将磁盘文件部分或者全部内容映射到内存中得到的结果，通常MappedByteBuffer对象由Channel得map方法返回。</p><p>在Buffer中有三个重要概念：</p><ul><li>容量(capacity)：缓冲区的容量，表示该Buffer的最大数据容量，不可以为负值，创建后不能更改</li><li>界限(limit)：第一不应该被读出或者写入的缓冲区位置索引，即位于limit后的数据既不可以被读，也不可被写</li><li>位置(position)：用于指明下一个可以被读出或者写入的缓冲区位置索引(类似于IO流的记录指针)，当时用Buffer从Channel读取数据时，position的值恰好等于已经读到了多少数据。初始化后，position的值为0。</li></ul><p>除此之外，Buffer还支持一个可选的标记mark，Buffer允许直接将position定位到该mark处。</p><p>这些值的关系为</p><p><strong>0≤mark≤position≤limit≤capacity</strong></p><p><img src="D:\各种文档\个人文档\学习总结\Java\输入输出\image\image-20200420150359162.png" alt="image-20200420150359162"></p><p>如图可看出这些值的关系。</p><p>Buffer的主要作用就是装入数据，然后输出数据，开始时，<strong>position为0，limit为capacity</strong>，程序通过put方法像Buffer中放入数据，</p><p>Buffer中一些常用的方法：</p><p><strong>XxxBuffer flip()</strong></p><p>功能：将limit设置为position所在位置，然后设position为0</p><p>参数：无</p><p>返回值：调用该方法的Buffer对象</p><p><strong>注：</strong></p><p>该方法使得Buffer的读写指针移到开始位置，即调用flip方法后，Buffer为输出数据做好准备</p><hr><p><strong>XxxBuffer clear()</strong></p><p>功能：将limit设为capacity，然后设position为0</p><p>参数：无</p><p>返回值：调用该方法的Buffer对象</p><p><strong>注：</strong></p><ul><li>该方法使得Buffer的读写指针移到开始位置，即调用clear方法后，Buffer为读取数据做好准备</li><li><strong>该方法不会清除Buffer中的内容，只会改变limit和position的值</strong></li></ul><hr><p><strong>int  capacity()</strong></p><p>功能：获得Buffer的capacity大小</p><p>参数：无</p><p>返回值：Buffer的capacity</p><hr><p><strong>boolean hasRemaining()</strong></p><p>功能：判断当前位置(position)和界限(limit)之间是否还有元素可供处理</p><p>参数：无</p><p>返回值：</p><p>有元素需要处理，返回true，无返回false</p><hr><p><strong>int limit()</strong></p><p>功能：返回Buffer界限的位置</p><p>参数：无</p><p>返回值：Buffer的limit</p><hr><p><strong>Buffer limit(int newPs)</strong></p><p>功能：重新设置limit的位置</p><p>参数：</p><ul><li>newPs:新limit的位置</li></ul><p>返回值：此Buffer对象</p><hr><p><strong>Buffer mark()</strong></p><p>功能：在当前Buffer的position设置一个mark</p><p>参数：无</p><p>返回值：当前Buffer对象</p><p><strong>注意</strong></p><ul><li>mark只能在0到position之间</li><li>设置了mark，只是在position位置做一个标记，需要调用reset方法将position转到mark位置</li></ul><hr><p><strong>int position()</strong></p><p>功能：获得Buffer的position值</p><p>参数：无</p><p>返回值：Buffer的position</p><hr><p><strong>Buffer position(int newPs)</strong></p><p>功能:设置Buffer的position</p><p>参数：</p><ul><li>newPs：需要设置的newPs位置</li></ul><p>返回值：返回修改了position的Buffer对象</p><hr><p><strong>int remaining()</strong></p><p>功能：返回当前位置和界限之间的元素个数。</p><p>参数：无</p><p>返回值：返回元素个数</p><hr><p><strong>Buffer reset()</strong></p><p>功能：将position转到mark所在位置</p><p>参数：无</p><p>返回值：此Buffer对象</p><hr><p><strong>Buffer rewind()</strong></p><p>功能：将位置设为0，取消设置的mark</p><p>参数：无</p><p>返回值：此Buffer对象</p><hr><p>除了这些方法外，Buffer的所有子类还提供了两个重要方法，put()和get()，用于向Buffer中放入数据和从Buffer中取出数据，当时用这两个方式时，Buffer即支持对单个数据的访问，也支持对批量数据的访问(以数组作为参数)。</p><p>使用put()和get()来访问Buffer中的数据时，分为相对和绝对两种</p><ul><li>相对：从position开始读取或写入数据，然后位置position按元素个数增加</li><li>直接根据索引向Buffer中读取或写入数据，position不受影响，值不改变</li></ul><p>tong</p><p>下面是Buffer的常规操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>                <span class="hljs-type">CharBuffer</span> <span class="hljs-variable">buff</span> <span class="hljs-operator">=</span> CharBuffer.allocate(<span class="hljs-number">8</span>);<br><br>                System.out.println(<span class="hljs-string">&quot;capacity : &quot;</span> + buff.capacity());<br><br>                System.out.println(<span class="hljs-string">&quot;limit : &quot;</span> + buff.limit());<br><br>                System.out.println(<span class="hljs-string">&quot;position : &quot;</span> + buff.position());<br><br>                buff.put(<span class="hljs-string">&#x27;a&#x27;</span>);<br><br>                buff.put(<span class="hljs-string">&#x27;b&#x27;</span>);<br><br>                buff.put(<span class="hljs-string">&#x27;c&#x27;</span>);<br><br>                System.out.println(<span class="hljs-string">&quot;加入三个元素后的position：&quot;</span> + buff.position());<br><br>                buff.flip();<br><br>                System.out.println(<span class="hljs-string">&quot;执行完flip方法后 limit = &quot;</span> + buff.limit() + <span class="hljs-string">&quot;  position = &quot;</span> + buff.position());<br><br>                System.out.println(<span class="hljs-string">&quot;取出第一个元素: &quot;</span> + buff.get());<br><br>                System.out.println(<span class="hljs-string">&quot;取出第一个元素后，position位置为&quot;</span> + buff.position());<br><br>                buff.clear();<br><br>                System.out.println(<span class="hljs-string">&quot;执行完clear方法后 limit = &quot;</span> + buff.limit() + <span class="hljs-string">&quot;   position = &quot;</span> + buff.position());<br><br>                System.out.println(<span class="hljs-string">&quot;执行clear后，缓冲区内容并没有被清除，取出第三个元素:&quot;</span> + buff.get(<span class="hljs-number">2</span>));<br><br>                System.out.println(<span class="hljs-string">&quot;执行绝对读取后，position = &quot;</span> + buff.position());<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><p><img src="D:\各种文档\个人文档\学习总结\Java\输入输出\image\image-20200420153133317.png" alt="image-20200420153133317"></p><p>通过allocate()方法创建的Buffer对象是普通的Buffer，ByteBuffer还提供了一个allocateDirect方法来创建直接Buffer，直接Buffer的创建成本比普通Buffer的创建成本高，但直接Buffer的读取效率更高。</p><p><strong>提示</strong></p><p>由于直接Buffer创建成本很高，所以直接Buffer只适用于生存期长的Buffer，而不适用与短生存期、一次用完就丢弃的Buffer。</p><p>而且只有ByteBuffer提供了allocateDirect()方法，所以只能在ByteBuffer级别上创建直接Buffer，如果希望使用其他类型，则应该将该Buffer转为其他类型的Buffer。</p><p>直接Buffer和普通Buffer用法基本相同。</p><h2 id="使用Channel"><a href="#使用Channel" class="headerlink" title="使用Channel"></a>使用Channel</h2><p>Channel类似于传统的流对象，但与传统流对象有两个主要区别：</p><ul><li>Channel可以直接将指定文件的部分或者全部映射成Buffer</li><li>程序不能直接访问Channel中的数据，读取、写入都不可以，必须写通过Buffer，如果要写入Channel，必须先写入Buffer，通过Buffer写入Channel，读取也是一样</li></ul><p>Java为Channel接口提供了DatagramChannel、FileChannel、Pipe.SinkChannel、Pipe.SourceChannel、SelectableChannel、ServerSocketChannel和SocketChannel等实现类，这里主要介绍FileChannel的用法。新IO的Channel是按功能来分类的，Pipe.SinkChannel、Pipe.SourceChannel是用于支持线程通信的管道Channel，ServerSocketChannel和SocketChannel是用于网络通信的管道Channel。</p><p>注意，所有的Channel都不应该通过构造器来创建，而是通过传统节点InputStream，OutputStream的getChannel()方法来返回对应Channel，不同节点流返回的Channel类型不同。FileInputStream和FileutputStream返回的Channel是FileChannel，PipedInputStream和PipedOutputStream返回的Channel是PipeChannel。</p><p>Channel最常用的三类方法是map(),read(),write()，其中map()方法用于将Channel对应的部分或者全部数据映射成ByteBuffer，而read()和write()都有一系列重载形式。</p><p>map()的方法签名为 <strong>MappedByteBuffer map(FileChannel.MapMode mode, long position, long size)</strong></p><p>第一个参数是执行映射时的模式，有三个取值</p><ul><li>FileChannel.MapMode.PRIVATE：私有模式(写时复制)</li><li>FileChannel.MapMode.READ_ONLY:只读模式</li><li>FileChannel.MapMode.READ_WRITE：读写模式</li></ul><p>第二个参数决定映射数据的起始位置，第三个是数据的长度</p><p>例子：直接将FileChannel的全部数据映射成ByteBuffer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.*;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><span class="hljs-keyword">import</span> java.nio.charset.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileChannelTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;FileChannelTest.java&quot;</span>);<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 创建FileInputStream，以该文件输入流创建FileChannel</span><br><span class="hljs-type">var</span> <span class="hljs-variable">inChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(f).getChannel();<br><span class="hljs-comment">// 以文件输出流创建FileBuffer，用以控制输出</span><br><span class="hljs-type">var</span> <span class="hljs-variable">outChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;a.txt&quot;</span>).getChannel())<br>&#123;<br><span class="hljs-comment">// 将FileChannel里的全部数据映射成ByteBuffer</span><br><span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> inChannel.map(FileChannel<br>.MapMode.READ_ONLY, <span class="hljs-number">0</span>, f.length());   <span class="hljs-comment">// ①</span><br><span class="hljs-comment">// 使用GBK的字符集来创建解码器</span><br><span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>);<br><span class="hljs-comment">// 直接将buffer里的数据全部输出</span><br>outChannel.write(buffer);     <span class="hljs-comment">// ②</span><br><span class="hljs-comment">// 再次调用buffer的clear()方法，复原limit、position的位置</span><br>buffer.clear();<br><span class="hljs-comment">// 创建解码器(CharsetDecoder)对象</span><br><span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">decoder</span> <span class="hljs-operator">=</span> charset.newDecoder();<br><span class="hljs-comment">// 使用解码器将ByteBuffer转换成CharBuffer</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">charBuffer</span> <span class="hljs-operator">=</span> decoder.decode(buffer);<br><span class="hljs-comment">// CharBuffer的toString方法可以获取对应的字符串</span><br>System.out.println(charBuffer);<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex)<br>&#123;<br>ex.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>虽然FileChannel可以读取也可以写入，但是FileInputStream创建的FileChannel只能读，FileOutputStream创建的FileChannel只能写。</p><p>RandAccessFile中也包含了一个getChannel()方法，RandAccessFile打开文件的模式决定返回的FileChannel是只读的还是读写的。</p><p>例子：对a.txt的文件内容进行复制，并追加在文件后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.*;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomFileChannelTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br><span class="hljs-keyword">throws</span> IOException<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 创建一个RandomAccessFile对象</span><br><span class="hljs-type">var</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(f, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-comment">// 获取RandomAccessFile对应的Channel</span><br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">randomChannel</span> <span class="hljs-operator">=</span> raf.getChannel())<br>&#123;<br><span class="hljs-comment">// 将Channel中所有数据映射成ByteBuffer</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> randomChannel.map(FileChannel<br>.MapMode.READ_ONLY, <span class="hljs-number">0</span>, f.length());<br><span class="hljs-comment">// 把Channel的记录指针移动到最后</span><br>randomChannel.position(f.length());<br><span class="hljs-comment">// 将buffer中所有数据输出</span><br>randomChannel.write(buffer);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序也可以使用Channel和Buffer传统的”用竹筒多次重复取水“的方式，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.*;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><span class="hljs-keyword">import</span> java.nio.charset.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadFile</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br><span class="hljs-keyword">throws</span> IOException<br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 创建文件输入流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;ReadFile.java&quot;</span>);<br><span class="hljs-comment">// 创建一个FileChannel</span><br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">fcin</span> <span class="hljs-operator">=</span> fis.getChannel())<br>&#123;<br><span class="hljs-comment">// 定义一个ByteBuffer对象，用于重复取水</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bbuff</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">256</span>);<br><span class="hljs-comment">// 将FileChannel中数据放入ByteBuffer中</span><br><span class="hljs-keyword">while</span> (fcin.read(bbuff) != -<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 锁定Buffer的空白区</span><br>bbuff.flip();<br><span class="hljs-comment">// 创建Charset对象</span><br><span class="hljs-type">Charset</span> <span class="hljs-variable">charset</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>);<br><span class="hljs-comment">// 创建解码器(CharsetDecoder)对象</span><br><span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">decoder</span> <span class="hljs-operator">=</span> charset.newDecoder();<br><span class="hljs-comment">// 将ByteBuffer的内容转码</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">cbuff</span> <span class="hljs-operator">=</span> decoder.decode(bbuff);<br>System.out.print(cbuff);<br><span class="hljs-comment">// 将Buffer初始化，为下一次读取数据做准备</span><br>bbuff.clear();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符集和Charset"><a href="#字符集和Charset" class="headerlink" title="字符集和Charset"></a>字符集和Charset</h2><p>计算机中的文件、数据、图片等等是一种表面现象，在计算机内部它们都是以二进制序列存储的，对于文本文件，我们之所以可以看到一个个的字符，是因为系统将二进制序列转换为了字符。这个过程有两个概念：编码(Encode)和解码(Decode)。通常，把明文的字符序列转换成计算机理解的二进制序列称为编码，把二进制序列转换成普通人看得懂的明文字符串为解码。</p><p>Java默认使用Unicode字符集，但很多操作系统并不是用Unicode字符集，那么当从系统中读取数据到Java程序中时，就可能出现乱码问题。</p><p>Java提供了Charset来处理字节序列和字符序列的转换关系，该类包含了创建解码器和编码器的方法，还提供了获取Charset所支持的字符集的方法，Charset类是不可变类。</p><p>常用的字符集：</p><ul><li>GBK：windows操作系统默认字符集，简体中文字符集</li><li>BIG5：繁体中文字符集</li><li>UTF-8：linux系统默认字符集，8位UCS转换格式</li></ul><p>可以通过Chatrset的forName()方法创建对应的Charset对象，参数就是字符集的别名</p><p>如<code>Charset cs = Charset.forName(&quot;GBK&quot;);</code></p><p>获得了Charset对象后，就可以通过该对象的newDecoder()和newEncoder()方法来获得CharsetDecoder和CharsetEncoder对象，分别是该Charset对象的解码器和编码器。这两个对象分别有decode()和encode()方法来对字节序列和字符序列解码和编码。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.*;<br><span class="hljs-keyword">import</span> java.nio.charset.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharsetTransform</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br><span class="hljs-keyword">throws</span> Exception<br>&#123;<br><span class="hljs-comment">// 创建简体中文对应的Charset</span><br><span class="hljs-type">Charset</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> Charset.forName(<span class="hljs-string">&quot;GBK&quot;</span>);<br><span class="hljs-comment">// 获取cn对象对应的编码器和解码器</span><br><span class="hljs-type">CharsetEncoder</span> <span class="hljs-variable">cnEncoder</span> <span class="hljs-operator">=</span> cn.newEncoder();<br><span class="hljs-type">CharsetDecoder</span> <span class="hljs-variable">cnDecoder</span> <span class="hljs-operator">=</span> cn.newDecoder();<br><span class="hljs-comment">// 创建一个CharBuffer对象</span><br><span class="hljs-type">CharBuffer</span> <span class="hljs-variable">cbuff</span> <span class="hljs-operator">=</span> CharBuffer.allocate(<span class="hljs-number">8</span>);<br>cbuff.put(<span class="hljs-string">&#x27;孙&#x27;</span>);<br>cbuff.put(<span class="hljs-string">&#x27;悟&#x27;</span>);<br>cbuff.put(<span class="hljs-string">&#x27;空&#x27;</span>);<br>cbuff.flip();<br><span class="hljs-comment">// 将CharBuffer中的字符序列转换成字节序列</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">bbuff</span> <span class="hljs-operator">=</span> cnEncoder.encode(cbuff);<br><span class="hljs-comment">// 循环访问ByteBuffer中的每个字节</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bbuff.capacity(); i++)<br>&#123;<br>System.out.print(bbuff.get(i) + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">// 将ByteBuffer的数据解码成字符序列</span><br>System.out.println(<span class="hljs-string">&quot;\n&quot;</span> + cnDecoder.decode(bbuff));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面程序分别实现了将ByteBuffer转换成CharBuffer，和CharBuffer转换成ByteBuffer的功能。</p><p>实际上，Charset类也提供了三个方法</p><p><strong>CharBuffer decode(ByteBuffer bb)</strong>:将ByteBuffer中的字节序列转换成字符序列的快捷方法</p><p><strong>ByteBuffer encode(CharBuffer bb)</strong>:将CharBuffer中的字符序列转换成字节序列的快捷方法</p><p><strong>ByteBuffer encode(String str)</strong>:将String字符序列转换成字节序列的快捷方法</p><p>也就是说，获取Charset对象以后，如果仅仅是需要简单的编码和解码操作，不需要创建对应的解码器和编码器，直接调用Charset对象的方法即可。</p><p>在String类里也提供了一个getBytes(String charset)方法，该方法返回byte[],即使用指定字符集将字符串转换成字节序列</p><h2 id="文件锁"><a href="#文件锁" class="headerlink" title="文件锁"></a>文件锁</h2><p>FileLock文件锁，在操作系统中很常见，如果多个程序同时访问、修改同一个文件，但是因为文件数据不同步而出现问题，给文件加一个锁，同一时间，只有一个程序可以访问该文件，或者所有程序都可以读取此文件，但不能同时写入，这就解决了同步问题。</p><p>文件锁是进程级别的，不是线程级别的，文件锁可以解决多个进程并发访问，但不能解决多线程并发访问的问题。</p><p>这就是说，当使用文件锁时，同一进程的多个线程可以同时访问修改该文件。</p><p>文件锁是当前程序所属的JVM实例持有的，一旦获取到文件锁，要释放文件锁有三种方法</p><ul><li>调用FileLock类的release方法</li><li>关闭对应的FileChannel对象</li><li>当前JVM退出</li></ul><p>文件锁分为两类</p><ul><li>排他锁：又叫做独占锁，对文件加上排他锁后，该进程可以对文件进行读写，该进程独占此文件，其他进程不能读写该文件，直到该进程释放文件锁。</li><li>共享锁：某个进程对文件加共享锁，其他进程也可以访问该文件，<strong>但是这些进程都只能读此文件，不能写</strong>，即读操作是共享的，但写操作是独占的，线程安全，其他进程不能获得该文件的排他锁，可以获得该文件的共享锁。</li></ul><p>在FileChannel提供的lock/tryLock方法可以获得文件锁FileLock对象,lock和tryLock的区别是：当lock方法试图锁定某个文件时，如果无法得到文件锁，程序将一直阻塞；而tryLock是尝试锁定文件，它将直接返回而不是阻塞，如果获得了文件锁，则该方法返回该文件锁，否则返回null</p><p>如果要锁定文件的部分内容，使用<strong>lock(long position, long size, boolean shared)</strong>和<strong>tryLock(long position, long size, boolean shared)</strong></p><p>所以一共有四种获得文件锁的方式</p><ul><li><strong>lock()</strong>：对整个文件加锁，默认为排他锁</li><li><strong>lock(long position, long size, boolean shared)</strong>：自定义加锁方式，前两个指定加锁文件的起始位置和大小，第三个参数，如果为true，则是共享锁，false则为排他锁</li><li><strong>tryLock()</strong>：对整个文件加锁，默认排他锁，非阻塞式</li><li><strong>tryLock(long position, long size, boolean shared)</strong>：自定义加锁方式，参数与第二个方法一样，非阻塞式</li></ul><p>FileLock其他常用的两个方法</p><ul><li><strong>boolean isShared()</strong>：判断此文件锁是否为共享锁</li><li><strong>boolean isValid()</strong>：判断此文件是否还有效</li></ul><p><strong>注意：</strong></p><p>文件锁虽然可以用于控制并发访问，但对于高并发访问的情形，还是推荐使用数据库保存程序信息</p><p>关于文件锁注意的几点</p><ul><li>在某些平台上，文件锁仅仅是建议性的，并不是强制性的， 这意味着即使一个程序不能获得文件锁，也可对该文件读写</li><li>在某些平台上，不能同步地锁定一个文件并把它映射到内存</li><li>文件锁是由Java虚拟机持有，如果两个Java程序使用同一个虚拟机运行，则他们不能对同一个文件进行加锁</li><li>在某些平台关闭FileChannel时，会释放虚拟机在该文件上的所有锁，因此避免对同一个被锁定的文件打开多个FileChannel</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>输入输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的IO流</title>
    <link href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84IO%E6%B5%81/"/>
    <url>/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84IO%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中把不同的输入输出源(键盘，文件，网络连接等)抽象表述为”流“，通过流的方式允许Java程序使用相同方式访问不同的输入/输出源。stream是从起源到接收的有序数据。</p><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><p>按照不同分类标准，可以将流分成不同类型。</p><ol><li><p>按照流的流向来分，分为输入流和输出流</p><ol><li>输入流：只能从中读取数据，不能写入数据</li><li><p>输出流：只能从中写入数据，不能读取数据</p><p><strong>注</strong>：</p><p>此处输入输出是相对内存来说的，数据从硬盘或其他设备到内存是输入，从内存到其他设备是输出。</p></li></ol></li></ol><pre><code class="hljs">Java的输入流主要由InputStream和Reader作为基类，输出流由OutputStream和Writer作为基类。它们都是抽象基类，无法直接创建实例。</code></pre><ol><li><p>按照流的操作数据单元不同，分为字符流和字节流</p><ol><li>字节流：操作的数据单元是8位的字节</li><li><p>字符流：操作的数据单元是16位的字符</p><p>除了操作数据单元不同，字符流和字节流的用法几乎一样<br>字节流主要由InputStream和OutputStream作为基类，而字符流则主要由Reader和Writer作为基类。</p></li></ol></li></ol><ol><li><p>按照流的角色来分，分为节点流和处理流</p><ol><li>节点流：从一个特定的IO设备(如磁盘、网络)读/写数据的流，称为节点流，也被称为低级流。</li><li><p>处理流：对一个已存在的流就行连接或封装，通过封装后的流来实现数据读/写功能。处理流被称为高级流。</p><p>注：</p><p>当时用处理流进行输入输出时，程序不会直接连接到实际的数据源，没有和实际的输入输出节点相连接，使用处理流的一个好处就是，只要使用相同的处理流，程序就可以采用完全相同的输入输出代码来访问不同数据源。</p></li></ol></li></ol><h2 id="流的概念模型"><a href="#流的概念模型" class="headerlink" title="流的概念模型"></a>流的概念模型</h2><p>Java把所有设备的有序数据抽象成流模型，简化了输入输出处理。</p><p>Java的IO流共涉及40多个类，非常规则，而且彼此之间存在紧密联系，Java的IO流的40多个类都是从如下的4个基类派生出来的：</p><ul><li>InputStream/Reader：所有输入流的基类，前者是字节输入流，后者字符输入流</li><li>OutputStream/Writer：所有输出流基类，前者字节输出流，后者字符输出流</li></ul><p>其中，处理流的功能主要体现在两个方面：</p><ul><li>性能的提高：主要以增加缓冲的方式提高输入/输出效率。</li><li>操作的便捷：处理流提高了一系列便捷的方式来一次输入/输出大批量的内容。</li></ul><p>处理流可以”嫁接“在任何已经存在的流的的基础上，这允许Java采用相同代码来访问不同输入/输出设备的数据流。</p><h2 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h2><h3 id="InputStream和Reader"><a href="#InputStream和Reader" class="headerlink" title="InputStream和Reader"></a>InputStream和Reader</h3><p>这是所有输入流的抽象基类，它们本身并不能创建实例来执行，但是它们是所有输入流的模板，包含的方法是所有输入流都可使用的方法。</p><p>InputStream里包含三个方法：</p><p><strong>int read()</strong></p><p>功能：从输入流读取单个字节。</p><p>参数：无</p><p>返回值：返回读取的字节数据(字节数据可直接转换为int类型)</p><hr><p><strong>int read(byte[] b)</strong></p><p>功能：从输入流读取b.length个字节的数据，并储存在数组b中。</p><p>参数：byte数组</p><p>返回值：返回实际读取的字节数</p><hr><p><strong>int read(byte[] b, int off, int len)</strong></p><p>功能：从输入流读取len个字节的数据，存储在数组b中，不是从数组起点开始，而是从off位置开始。</p><p>参数：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>byte[] b</td><td>将读取的数据存入数组b中</td></tr><tr><td>int off</td><td>从数组的off位置开始存</td></tr><tr><td>int len</td><td>从输入流读取len个字节的数据</td></tr></tbody></table></div><p>返回值：返回实际读取的字节数</p><hr><p>Reader里也包含三个方法</p><p><strong>int read()</strong></p><p>功能：从输入流读取单个字符。</p><p>参数：无</p><p>返回值：返回读取的字符数据(字节数据可直接转换为int类型)</p><hr><p><strong>int read(char[] cbuf)</strong></p><p>功能：从输入流读取cbuf.length个字符的数据，并储存在数组cbuf中。</p><p>参数：char数组</p><p>返回值：返回实际读取的字符数</p><hr><p><strong>int read(char[] cbuf int off, int len)</strong></p><p>功能：从输入流读取len个字符的数据，存储在数组cbuf中，不是从数组起点开始，而是从off位置开始。</p><p>参数：</p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>char cbuf</td><td>将读取的数据存入数组cbuf中</td></tr><tr><td>int off</td><td>从数组的off位置开始存</td></tr><tr><td>int len</td><td>从输入流读取len个字符的数据</td></tr></tbody></table></div><p>返回值：返回实际读取的字符数</p><p>可以发现，两个基类的功能基本一样，只是一个是字节，一个是字符</p><p>当read方法返回-1时，表明到了输入流的结束点</p><p>它们两个基类分别有用于读取文件的输入流：FileInputStream和FileReader,他们都是节点流——与指定文件关联。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileInputStreamTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException<br>&#123;<br><span class="hljs-comment">// 创建字节输入流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;FileInputStreamTest.java&quot;</span>);<br><span class="hljs-comment">// 创建一个长度为1024的“竹筒”</span><br><span class="hljs-type">var</span> <span class="hljs-variable">bbuf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-comment">// 用于保存实际读取的字节数</span><br><span class="hljs-type">var</span> <span class="hljs-variable">hasRead</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 使用循环来重复“取水”过程</span><br><span class="hljs-keyword">while</span> ((hasRead = fis.read(bbuf)) &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 取出“竹筒”中水滴（字节），将字节数组转换成字符串输入！</span><br>System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bbuf, <span class="hljs-number">0</span>, hasRead));<br>&#125;<br><span class="hljs-comment">// 关闭文件输入流，放在finally块里更安全</span><br>fis.close();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>上面创建了一个1024字节的数组，但源文件不到1024个字节，只需要执行一次read即可，但如果创建较小长度的字节数组，程序运行时再输出中文注释时可能会出现乱码——因为Windows保存文件默认用GBK编码方法，这种方式下，每个中文字符占两个字节，如果只读到了半个中文字符，会出现乱码。</p><p>程序可以使用close()方法来关闭输入流，与JDBC编程一样，程序里打开的文件IO资源不属于内存资源，垃圾回收机制无法回收，应该显式关闭文件IO资源,IO资源类都实现了AutoCloseable接口，可以通过自动关闭资源的try语句来关闭IO流。</p><p>InoutStream和Reader还支持如下几个方法移动记录指针：</p><p><strong>void mark(int readAheadLimit)</strong></p><p>功能：在记录指针当前位置记录一个标记</p><p>参数：</p><p>readAheadLimit: 在标记位置变为无效之前可以读取的最大字节数限制。</p><p>返回值:无</p><hr><p><strong>boolean markSupported()</strong></p><p>功能：判断此输入流是否支持mark操作，即是否支持记录标记。</p><p>参数：无</p><p>返回值：</p><p>支持返回true，否则false</p><hr><p><strong>void reset()</strong></p><p>功能：将该流的记录指针重新定位到上一次记录标记的mark位置</p><p>参数：无</p><p>返回值：无</p><hr><p><strong>long skip(long n)</strong></p><p>功能：从记录指针开始，跳过n个字节/字符</p><p>参数：需要跳过的字符/字节数</p><p>返回值：实际跳过的字符/字节数</p><hr><p><strong>重要</strong>：<strong>Windows默认使用GBK编码保存文件，在GBK编码中，一个中文字符占两个字节，中文标点两个字节，英文字母和标                点占一个字节。且在文本文件中，每行末尾有\r\n，各占一个字节。</strong><br>                <strong>Linux系统默认使用UTF-8编码，在UTF-8编码中，一个中文字符和标点占三个字节，英文字母和标点占一个字节。<br>                IDEA中默认使用UTF-8编码</strong></p><h3 id="OutputStream和Writer"><a href="#OutputStream和Writer" class="headerlink" title="OutputStream和Writer"></a>OutputStream和Writer</h3><p>这两个类也非常相似，两个流都提供了三个方法。</p><p><strong>void write(int c)</strong></p><p>功能：将字节/字符输出到输出流。</p><p>参数：c可以代表字节，也可以代表字符。</p><p>返回值：无</p><hr><p><strong>void write(byte[]/char[] buf)</strong></p><p>功能：将字节数组/字符数组中的数据输出到指定输出流。</p><p>参数：要输出的字节数组/字符数组的数据</p><p>返回值：无</p><hr><p><strong>void write(byte[]/char[] buf, int off, int len)</strong></p><p>功能：将字节数组/字符数组中从off位置开始，长度为len的数据输出到指定输出流。</p><p>参数：</p><ul><li>byte[]/char[]:要输出的字符数组/字节数组</li><li>off：开始输出的数组位置</li><li>len：要输出的字符/字节长度</li></ul><p>返回值：无</p><hr><p>因为字符流以字符为基本操作单位，所以Writer可以用字符串来代替字符数组，即以String对象为参数，Writer里还包含两个方法：</p><p><strong>void write(String str)</strong></p><p>功能：将字符串中的数据输出到指定输出流。</p><p>参数：要输出的字符串</p><p>返回值：无</p><hr><p><strong>void write(String src, int off, int len)</strong></p><p>功能：将字符串中从off位置开始，长度为len的数据输出到指定输出流。</p><p>参数：</p><ul><li>src：要输出的字符串</li><li>off：开始输出的数组位置</li><li>len：要输出的字符/字节长度</li></ul><p>返回值：无</p><hr><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileOutputStreamTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 创建字节输入流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;FileOutputStreamTest.java&quot;</span>);<br><span class="hljs-comment">// 创建字节输出流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;newFile.txt&quot;</span>))<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">bbuf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">32</span>];<br><span class="hljs-type">var</span> <span class="hljs-variable">hasRead</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 循环从输入流中取出数据</span><br><span class="hljs-keyword">while</span> ((hasRead = fis.read(bbuf)) &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 每读取一次，即写入文件输出流，读了多少，就写多少。</span><br>fos.write(bbuf, <span class="hljs-number">0</span>, hasRead);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ioe)<br>&#123;<br>ioe.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>输入输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java的对象序列化和反序列化</title>
    <link href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/Java%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="序列化的含义和意义"><a href="#序列化的含义和意义" class="headerlink" title="序列化的含义和意义"></a>序列化的含义和意义</h2><p>对象序列化的目标就是将对象保存到磁盘中，或者直接在网络传输对象，对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许永久保存在磁盘上。程序一旦获得了这种二进制流，都可以将这种二进制流恢复成原来的Java对象,即反序列化。</p><p>对象的序列化(Serialize)指将一个Java对象写入IO流，与此对应，对象的反序列化，指从IO流中恢复该Java对象。</p><p>Java 9增强了对象序列化机制，它允许对读入的序列化数据进行过滤，这种过滤在反序列化之前对数据进行校验，从而提高了安全性和健壮性。</p><p>如果需要让某个对象支持序列化机制，则必须让它的类是可序列化的，该类必须实现两个接口之一：</p><ul><li>Serializable</li><li>Externalizable</li></ul><p>Java很多类实现了Serializable，该接口为标记接口，无需实现任何方法，只是表明该类的实例是可以序列化的。</p><p>所有在网络上传输的对象的类都应该是实例化的。</p><h2 id="使用对象流实现序列化和反序列化"><a href="#使用对象流实现序列化和反序列化" class="headerlink" title="使用对象流实现序列化和反序列化"></a>使用对象流实现序列化和反序列化</h2><p>实现序列化应该实现Serializable接口或者Externalizable接口之一，这两接口区别和联系，后面会有介绍，暂时不用理会Externalizable接口。</p><p>使用Serializable接口实现序列化很简单，只要让对应的类实现该接口即可。然后程序可以通过两个步骤序列化对象</p><ol><li><p>创建一个ObjectOutputStream，这个输出流是一个处理流，必须建立在其他节点流的基础上</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;object.txt&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>调用ObjectOutputStream对象的writeObject()方法输出该可序列化对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">oos.writeObject(per);<br></code></pre></td></tr></table></figure><p> 下面程序定义了一个可序列化的类：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br><br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> age;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span>&#123;<br><br>                System.out.println(<span class="hljs-string">&quot;有参数的构造器&quot;</span>);<br><br>                <span class="hljs-built_in">this</span>.name = name;<br><br>                <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>                <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> age;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br>                <span class="hljs-built_in">this</span>.age = age;<br>        &#125;<br><br></code></pre></td></tr></table></figure><p> 然后使用ObjectOutputStream将Person对象写入磁盘文件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;transient.txt&quot;</span>)))<br>                &#123;<br>                        <span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">500</span>);<br><br>                        oos.writeObject(per);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (Exception e)<br>                &#123;<br>                        e.printStackTrace();<br>                &#125;<br><br><br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>从IO流中恢复该Java对象，即反序列化，也需两步：</p><ol><li><p>创建ObjectInputStream处理流：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.txt&quot;</span>));<br></code></pre></td></tr></table></figure></li><li><p>调用ObjectInputStream对象的readObject()方法读取流中的对象，该方法返回一个Object对象，如果程序知道该Java对象类型，应强制转换，代码：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) ois.readObject();<br></code></pre></td></tr></table></figure><p> 完整的从object文件读取Java对象：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadObject</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span><br>    &#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(object.txt)))<br>        &#123;<br>           <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) ois.readObject();<br>            <br>            System.out.println(<span class="hljs-string">&quot;名字为&quot;</span> + p.getName() + <span class="hljs-string">&quot;年龄为&quot;</span> + p.getAge());<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(Exception e)<br>        &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>注意</strong></p><ol><li>反序列化读取的仅仅是Java对象的数据，不是Java类，因此采用反序列化恢复Java对象时，必须提供Java对象所属类的class文件，否则将会引发ClassNotFoundException异常。</li><li>Person类只有一个有参数的构造器，没有无参数的构造器，而且该构造器有打印语句，但反序列化java对象时，没有看到程序调用该构造器，说明反序列化机制不需要通过构造器来初始化Java对象。</li><li><strong>当使用序列化机制向文件写入多个Java对象，使用反序列化机制时必须按写入的顺序来读取</strong>。</li><li>当一个可序列化类有多个父类时(包括直接父类和间接父类)，这些父类要么有无参数的构造器，要么也是可序列化的，否则反序列化时会抛出InvalidClassException异常，如果父类是不可序列化的，只是带有无参数的构造器，则该父类定义的成员变量值不会序列化到二进制流中。</li></ol></li></ol><pre><code class="hljs">## 对象引用的序列化之前介绍的序列化对象对应的类Person，两个成员变量分别是String和int类型，如果某个类的成员变量不是基本类型或者String类型，而是另一种引用类型，那么这个引用类型必须是可序列化的，否则拥有该变量的类也是不可序列化的。**换句话说，只有一个类的所有成员变量对应的类都是可序列化的，这个类才是可序列化的，基本类型和String已经实现了可序列化。**比如Teacher类里有一个成员变量是Person类，只有Person是可序列化的，Teacher才是可序列化的。那么现在假设有一种特殊的情形，程序有两个Teacher对象，它们的student实例变量都引用同一个Person对象，而且该Person对象还有一个引用变量引用它，代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Person</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">500</span>);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;唐僧&quot;</span>, per);<br><span class="hljs-type">Teacher</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;菩提祖师&quot;</span>, per);<br></code></pre></td></tr></table></figure>上面代码创建了两个Teacher对象和一个Person对象，这里产生了一个问题，如果先序列化t1对象，则系统会将t1对象引用的Person对象一起序列化，如果程序再序列化t2对象，系统会序列化t2对象，如果再序列化per对象，系统会再次序列化该Person对象，整个过程似乎会序列化三个Person对象。那么当输入流反序列化这些对象时，将会得到三个Person对象，从而引起t1和t2对象引用的不是同一个Person对象，这违背了Java序列化机制的初衷。所以Java序列化机制采用特殊序列化算法如下：- 所有保存到磁盘中的对象都有一个序列化编号- 当程序试图序列化一个对象，程序先检查该对象是否已经被序列化过，只有该对象从未(在本次虚拟机中)被序列化过，系统才会将该对象转换成字节序列输出- 如果某个对象已经被序列化，程序将只输出一个序列化编号，而不是重新序列化该对象根据上述序列化算法，可以知道当第二次第三次序列化Person对象时，程序将只会输出一个序列化编号。**注意**这种序列化算法也会引起潜在问题，当多次序列化一个对象时，只有第一次会序列化该对象，那么当第一次序列化该对象时，如果修改了该对象成员变量的值，再次序列化，也只会输出一个序列化编号，即第一次序列化的对象，因此改变的成员变量值不会被输出。**所以在序列化Java对象时，一定要注意，只有第一次序列化才会将对象转换成字节序列，在后面程序中，即使该对象实例变量发生改变，再次调用writeObject方法时，改变的实例变量也不会被输出。**## Java 9增加的过滤功能Java 9为ObjectInputStream增加了setObjectFilter(),getObjectFilter()两个方法，其中一个方法为对象输入流设置过滤器，当程序通过ObjectInputStream反序列化对象时，过滤器的checkInput()方法会被自动激发，用于检查序列化数据是否有效。使用checkInput()方法检查序列化数据有三种返回值：- Status.REJECTED:拒绝恢复- Status.ALLOWED:允许恢复- Status.UNDECIDED:未决定状态，程序将继续执行检查ObjectInputStream会根据ObjectInputFilter检查结果来决定是否执行反序列化，如果返回Status.REJECTED，反序列化将会被阻止，返回ALLOWED，反序列化会被执行。例子：该程序会在反序列化之前对数据执行检查：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FilterTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 创建一个ObjectInputStream输入流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;object.txt&quot;</span>)))<br>&#123;<br>ois.setObjectInputFilter((info) -&gt; &#123;<br>System.out.println(<span class="hljs-string">&quot;===执行数据过滤===&quot;</span>);<br><span class="hljs-type">ObjectInputFilter</span> <span class="hljs-variable">serialFilter</span> <span class="hljs-operator">=</span> ObjectInputFilter.Config.getSerialFilter();<br><span class="hljs-keyword">if</span> (serialFilter != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-comment">// 首先使用ObjectInputFilter执行默认的检查</span><br>ObjectInputFilter.<span class="hljs-type">Status</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> serialFilter.checkInput(info);<br><span class="hljs-comment">// 如果默认检查的结果不是Status.UNDECIDED</span><br><span class="hljs-keyword">if</span> (status != ObjectInputFilter.Status.UNDECIDED) &#123;<br><span class="hljs-comment">// 直接返回检查结果</span><br><span class="hljs-keyword">return</span> status;<br>&#125;<br>&#125;<br><span class="hljs-comment">// 如果要恢复的对象不是1个</span><br><span class="hljs-keyword">if</span> (info.references() != <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">// 不允许恢复对象</span><br><span class="hljs-keyword">return</span> ObjectInputFilter.Status.REJECTED;<br>&#125;<br><span class="hljs-keyword">if</span> (info.serialClass() != <span class="hljs-literal">null</span> &amp;&amp;<br><span class="hljs-comment">// 如果恢复的不是Person类</span><br>info.serialClass() != Person.class)<br>&#123;<br><span class="hljs-comment">// 不允许恢复对象</span><br><span class="hljs-keyword">return</span> ObjectInputFilter.Status.REJECTED;<br>&#125;<br><span class="hljs-keyword">return</span> ObjectInputFilter.Status.UNDECIDED;<br>&#125;);<br><span class="hljs-comment">// 从输入流中读取一个Java对象，并将其强制类型转换为Person类</span><br><span class="hljs-type">var</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) ois.readObject();<br>System.out.println(<span class="hljs-string">&quot;名字为：&quot;</span> + p.getName()<br>+ <span class="hljs-string">&quot;\n年龄为：&quot;</span> + p.getAge());<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex)<br>&#123;<br>ex.printStackTrace();<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>上述代码重写了checkInput方法，先使用默认的ObjectInputFilter执行检查，如果检查结果不是Status.UNDECIDED，程序直接返回检查结果，接下来通过FilterInfo检查序列化数据，如果序列化数据不唯一，拒绝执行，如果不是Person对象，拒绝执行，通过这种检查，程序可以保证反序列化出来的是唯一的Person对象。## 自定义序列化在一些特殊的情景，如果一个类的某些实例变量是敏感信息，这时不希望程序将该实例变量进行实例化，或者某个实例变量类型是不可序列化的，因此不希望对该实例变量进行递归序列化。**递归序列化**：当对某个对象进行序列化时，系统会自动把该对象的所有实例变量依次进行序列化，如果某个实例变量引用到另一个对象，则该引用的对象也会被序列化，这样一层一层的递归的进行对象序列化，就是递归序列化。通过在实例变量前面使用transient关键词修饰，可以指定Java序列化时无需理会该实例变量。例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable<br>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> age;<br><span class="hljs-comment">// 注意此处没有提供无参数的构造器!</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;有参数的构造器&quot;</span>);<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-comment">// 省略name与age的setter和getter方法</span><br><br><span class="hljs-comment">// name的setter和getter方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span><br>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;<br><br><span class="hljs-comment">// age的setter和getter方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>**注意**transient关键词只能用于修饰实例变量，不可修饰Java程序其他成分。下面先序列化一个Person对象，然后反序列化读取，再输出age变量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransientTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 创建一个ObjectOutputStream输出流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;transient.txt&quot;</span>));<br><span class="hljs-comment">// 创建一个ObjectInputStream输入流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;transient.txt&quot;</span>)))<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">500</span>);<br><span class="hljs-comment">// 系统会per对象转换字节序列并输出</span><br>oos.writeObject(per);<br><span class="hljs-type">var</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Person) ois.readObject();<br>System.out.println(p.getAge());<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex)<br>&#123;<br>ex.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>age使用transient关键词修饰，所以输出age的值为0.使用transient关键词修饰实例变量虽然简单，方便，但是所修饰的实例变量将被完成隔离在序列化机制之外，这样导致反序列化时无法取得该实例变量值，Java提供了一种自定义序列化机制，可以让程序控制如何序列化各实例变量。需要特殊处理的类应该提供如下特殊签名的方法，这些方法用于实现自定义序列化。**private void writeObject(java.io.ObjectOutputStream out) throws IOException**功能：负责写入特定类的实例状态，以便readObject()如何恢复它参数:out:特定对象输出流返回值：无**注：**默认情况，该方法会调用out.defaultWriteObject来保存Java对象实例变量。---**private void writeObject(java.io.ObjectOutputStream out) throws IOException**功能：负责从流中读取并恢复实例变量参数:in:特定对象输入流返回值：无**注：**默认情况，该方法会调用in.defaultReadObject来恢复Java对象的非瞬态实例变量，通常情况，readObject和writeObject方法相对应。---**private void readObjectNoData() throws ObjectStreamException**功能：如果序列化流不完整，此方法可以正确初始化反序列化的对象，例如，接收方使用的反序列化类版本不同于发送方，或者序列化流被篡改时，系统调用此方法初始化反序列化的对象。---下面Person类重写了writeObject方法和readObject方法，其中写入时先将name变量包装成SringBuffer，然后反转进行写入，读取时，先将读取的数据强制类型转换为StringBuffer，再将其反转后赋给name变量。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable<br>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-comment">// 注意此处没有提供无参数的构造器!</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;有参数的构造器&quot;</span>);<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-comment">// 省略name与age的setter和getter方法</span><br><br><span class="hljs-comment">// name的setter和getter方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span><br>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;<br><br><span class="hljs-comment">// age的setter和getter方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream out)</span><br><span class="hljs-keyword">throws</span> IOException<br>&#123;<br><span class="hljs-comment">// 将name实例变量的值反转后写入二进制流</span><br>out.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(name).reverse());<br>out.writeInt(age);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readObject</span><span class="hljs-params">(java.io.ObjectInputStream in)</span><br><span class="hljs-keyword">throws</span> IOException, ClassNotFoundException<br>&#123;<br><span class="hljs-comment">// 将读取的字符串反转后赋给name实例变量</span><br><span class="hljs-built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse()<br>.toString();<br><span class="hljs-built_in">this</span>.age = in.readInt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>对于这个Person类而言，序列化和反序列化Person实例与不重写两个方法效果一样，区别在于序列化后的处理流，即使有Cracker截获到Person对象流，它看到的也是加密后的name，提高了序列化的安全性。</code></pre><p><strong>注意：</strong></p><p>writeObject方法存储实例变量的顺序应该和readObject方法恢复实例变量的顺序一致。</p><p>还有一种更彻底的自定义机制，它甚至可以在序列化对象之前，将该对象替换成其他对象，如果需要，则应该为序列化类提供如下特殊方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ANY_ACCESS_MODIFIER Object <span class="hljs-title function_">writeReplace</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException<br></code></pre></td></tr></table></figure><p>此序列化方法由序列化机制调用，只要该方法存在。因为该方法可以拥有private、protected和包私有权限，所以子类可能获得该方法。</p><p>下面例子提供了writeReplace方法，可以在写入Person对象是将该对象替换成ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable<br>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-comment">// 注意此处没有提供无参数的构造器!</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;有参数的构造器&quot;</span>);<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-comment">// 省略name与age的setter和getter方法</span><br><br><span class="hljs-comment">// name的setter和getter方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span><br>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;<br><br><span class="hljs-comment">// age的setter和getter方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>&#125;<br><br><span class="hljs-comment">//重写writeReplace方法，程序在序列化该对象之前，先调用该方法</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">writeReplace</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException<br>&#123;<br>ArrayList&lt;Object&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(name);<br>list.add(age);<br><span class="hljs-keyword">return</span> list;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Java序列化机制保证在序列化某个对象之前，先调用该对象的writePeplace方法，如果该对象返回另一个Java对象，则需系统转为序列化另一个对象。如下程序表明序列化Person对象，实际序列化的是ArrayList对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReplaceTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 创建一个ObjectOutputStream输出流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;replace.txt&quot;</span>));<br><span class="hljs-comment">// 创建一个ObjectInputStream输入流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;replace.txt&quot;</span>)))<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">per</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">500</span>);<br><span class="hljs-comment">// 系统将per对象转换字节序列并输出</span><br>oos.writeObject(per);<br><span class="hljs-comment">// 反序列化读取得到的是ArrayList</span><br><span class="hljs-type">var</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> (ArrayList) ois.readObject();<br>System.out.println(list);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex)<br>&#123;<br>ex.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>综上所述，系统在序列化某个对象之前，首先调用该对象的writeReplcae方法，如果该方法返回另一个对象，系统将再次调用另一个对象的writeReplace方法，直到该方法不再返回另一个对象为止。然后程序最后调用该对象的writeObject方法保存对象状态。</p><p>与writeReplace方法相对应的是，序列化机制还有一个特殊的方法，它可以实现保护性复制整个对象，该方法是：</p><p><code>ANY_ACCESS_MODIFIER Object readResolve() throws ObjectStreamException</code></p><p>这个方法会在readObject方法调用后被调用，该方法的返回值会替代原来反序列化的对象，而原来使用readObject方法反序列化的对象会被丢弃。</p><p>readResolve方法在序列化单例类。枚举类时尤其有用。</p><p>例如下面一个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Orientation</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Orientation</span> <span class="hljs-variable">HORIZONTAL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orientation</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Orientation</span> <span class="hljs-variable">VERTICAL</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Orientation</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Orientation</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span><br>&#123;<br><span class="hljs-built_in">this</span>.value = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>该枚举类构造器私有，程序有两个Orientation对象，但如果让该类实现Serializable接口，会引发一个问题，如果将Orientation.HORIZONTAL值序列化后再读入，如果立即拿读入后的对象与Orientation.HORIZONTAL进行比较，返回false，也就是说读入的对象是一个新的Orientation对象，而不等于Orientation类中的任何枚举类，虽然Orientation的构造器是私有的，但反序列化依然可以创建新的Orientation对象。</p><p><strong>提示</strong>：</p><p>反序列化机制在恢复Java对象时无序调用构造器来初始化对象，从这个意义上看，序列化对象可以“克隆”对象。</p><p>在这种情况下，可以为Orientation类提供一个readResolve方法来解决，readResolve方法返回值会代替原反序列化对象，也就是让反序列化得到的Orientation对象直接被丢弃。</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 为枚举类增加readResolve()方法</span><br><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException<br>&#123;<br><span class="hljs-keyword">if</span> (value == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">return</span> HORIZONTAL;<br>&#125;<br><span class="hljs-keyword">if</span> (value == <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-keyword">return</span> VERTICAL;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过重写readResolve方法可以保证反序列化得到的依然是Orientation的两个枚举对象之一。</p><p><strong>注意</strong>：所有单例类、枚举类序列化时都应该提供readResolve方法，这样才能保证反序列化的对象依然正常。</p><p>与writeReplace方法类似，readResolve方法一可以用任意访问控制符，因此父类readResolve方法可能被子类继承，这样使用该方法就会存在明显的缺点：当父类已经实现readResolve方法，子类将变得无从下手，如果父类包含protected或public的readResolve方法，而且子类没有重写该方法，会使得子类反序列化时得到一个父类的对象。总是让子类重写readResolve方法无疑是个负担。因此对于要作为父类继承的类而言，实现readResolve方法可能会有潜在危险。<br><strong>通常建议时，对于final类重写readResolve方法不会有任何问题，因为该类不可以被继承，否则重写readResolve尽量使用private修饰。</strong></p><h2 id="另一种自定义序列化机制"><a href="#另一种自定义序列化机制" class="headerlink" title="另一种自定义序列化机制"></a>另一种自定义序列化机制</h2><p>Java提供了另一种序列化机制，即Externalizable接口，这种序列化方式完全由程序员决定存储和恢复对象数据，该接口定义了两个方法。</p><p><strong>void readExternal(ObjectInput in)</strong></p><p>功能：实现反序列化，从输入流中读取对象</p><p>参数：in:输入流</p><p>返回值：无</p><p><strong>注</strong></p><p>该方法调用DataInput的方法来恢复<strong>基本类型</strong>的实例变量值，调用ObjectOutput的writeObject()方法来保存<strong>引用类型</strong>的实例变量。</p><hr><p><strong>void writeExternal(ObjectOutput out)</strong></p><p>功能：实现序列化</p><p>参数：out：输出流</p><p>返回值：无</p><p><strong>注</strong></p><p>该方法调用DataOutput的方法来保存<strong>基本类型</strong>的实例变量值，使用ObjectOutput的writeObject方法保存<strong>引用类型</strong>的实例变量值。</p><hr><p>实际上，采用Externalizable接口序列化和前面的Serializable序列化很相似，只是Externalizable强制自定义序列化，必须要实现上述两个方法，下面的Person类实现了Externalizable接口，并且实现了该接口的两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Externalizable<br>&#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><span class="hljs-comment">// 注意必须提供无参数的构造器，否则反序列化时会失败。</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span>&#123;&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span><br>&#123;<br>System.out.println(<span class="hljs-string">&quot;有参数的构造器&quot;</span>);<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-comment">// 省略name与age的setter和getter方法</span><br><br><span class="hljs-comment">// name的setter和getter方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span><br>&#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>&#125;<br><br><span class="hljs-comment">// age的setter和getter方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeExternal</span><span class="hljs-params">(java.io.ObjectOutput out)</span><br><span class="hljs-keyword">throws</span> IOException<br>&#123;<br><span class="hljs-comment">// 将name实例变量的值反转后写入二进制流</span><br>out.writeObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>(name).reverse());<br>out.writeInt(age);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readExternal</span><span class="hljs-params">(java.io.ObjectInput in)</span><br><span class="hljs-keyword">throws</span> IOException, ClassNotFoundException<br>&#123;<br><span class="hljs-comment">// 将读取的字符串反转后赋给name实例变量</span><br><span class="hljs-built_in">this</span>.name = ((StringBuffer) in.readObject()).reverse().toString();<br><span class="hljs-built_in">this</span>.age = in.readInt();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果程序需要序列化实现Externalizable接口对象，一样调用writeObject方法，反序列化则调用readObject方法，和之前用法一样。</p><p><strong>注意</strong>：</p><p>当时用Externalizable机制反序列化对象时，程序会首先使用public的无参数构造器创建实例，然后才执行readExternal方法进行反序列化，因此<strong>实现Externalizable的序列化类必须提供public的无参数构造器</strong>。</p><h2 id="两种序列化机制对比"><a href="#两种序列化机制对比" class="headerlink" title="两种序列化机制对比"></a>两种序列化机制对比</h2><div class="table-container"><table><thead><tr><th>实现Serializable接口</th><th>实现Externalizable接口</th></tr></thead><tbody><tr><td>系统自动存储必要信息</td><td>程序员决定存储哪些信息</td></tr><tr><td>Java内建支持，易于实现，只需实现该接口即可，无需任何代码支持</td><td>仅提供两个空方法，实现该接口要为两个空方法提供实现</td></tr><tr><td>性能略差</td><td>性能略好</td></tr></tbody></table></div><p>虽然Externalizable接口性能较好，但是实现Externalizable接口导致编程复杂，所以但部分时候还是使用Serializable接口。</p><p>关于对象序列化，以下几点需要注意：</p><ul><li>对象的类名、实例变量(包括基本类型、数组、对其他对象的引用)，都会被序列化，但是方法，类变量，transient实例变量(也被称为瞬态实例变量)不会被序列化</li><li>实现Serializable接口的类如果需要让某个实例变量不被序列化，应该添加transient关键词，而不应该用static修饰，虽然也可达到这个效果，但这个关键词不是这么用的，而且也会出现其他问题。</li><li>保证序列化对象的实例变量类型也是可序列化的。</li><li>反序列化对象必须有序列化对象的class文件</li><li>当通过文件、网络读取序列化后的对象时，必须按实际写入的顺序读取。</li></ul><h2 id="版本"><a href="#版本" class="headerlink" title="　版本"></a>　版本</h2><p>反序列化对象时必须提供该对象对应类的class文件，现在问题是，随着项目升级，系统的class文件也会升级，Java如何保证class文件的兼容性。</p><p>Java序列化机制允许为序列化类提供一个private static final的serialVersionUID值，该类变量的值用于标识该Java类的序列化版本，也就是说，如果一个类升级以后，只要它的serialVersionUID值不变，序列化机制会把它们当成同一个序列化版本。</p><p>分配serialVersionUID值很简单，</p><p><code>private static final long serialVersionUID = 512L;</code></p><p>为了在反序列化时确保序列化版本的兼容性，最好在每个序列化类中加入这个类变量，具体数值可以自己定义，这样即使在某个对象被序列化后，它所对应的类被修改了，该对象也容易被正确反序列化。</p><p>每个类的serialVersionUID值都是唯一的，也就是说不同类的serialVersionUID值不应该相同。</p><p>如果不显式指定这个类变量的值，该类变量的值由JVM根据类的相关信息计算，而修改后的类的计算结果和之前的计算结果往往不同，造成对象反序列化因为类版本不兼容而失败。</p><p>不显式指定这个serialVersionUID值的另一个坏处是，不利于程序在不同JVM之间移植，因为不同编译器对该类变量的计算策略可能不同，从而造成类可能没有改变，但是serialVersionUID值不同。</p><p>那么对类的哪些修改可能会导致改变serialVersionUID值呢？</p><p>分三种情况讨论：</p><ul><li><p>如果修改类时仅仅修改了静态变量或者瞬态实例变量，则反序列化不受任何影响，serialVersionUID值不会改变</p></li><li><p>如果修改类时，仅仅修改了方法，则反序列化不受任何影响，serialVersionUID值不改变</p></li><li><p>如果修改类时修改了非瞬态的实例变量，则可能导致序列化版本不兼容。</p><ol><li>如果对象流中的对象与新类中包含同名的实例变量，而实例变量类型不同，则反序列化失败，serialVersionUID值会改变</li><li>如果对象流的对象比新类中包含更多的实例变量，即新类删除了部分实例变量，则多出的实例变量值被忽略，序列化版本可以兼容，serialVersionUID值不会改变</li><li>如果新类比对象流中的对象包含更多的实例变量，即新类增加了一些实例变量，那么序列化版本也可以兼容，serialVersionUID值不会更新，但是反序列化中的对象得到的新对象多出来的实例变量值都是null(引用类型变量)或者0(基本类型变量)。</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>输入输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重定向输入输出</title>
    <link href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
    <url>/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E9%87%8D%E5%AE%9A%E5%90%91%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java的标准输入输出分别通过System.in和System.out来代表，默认情况他们分别代表键盘和显示器，在System.in类里提供了三个重定向标准输入输出的方法：</p><p><strong>static void setErr(PrintStram err)</strong></p><p>功能：重定向标准错误输出</p><p>参数:</p><ul><li>err：重新定向的标准错误输出流</li></ul><p>返回值：无</p><hr><p><strong>static void setIn(InputStream in)</strong></p><p>功能：重定向标准输入</p><p>参数:</p><ul><li>in：重新定向的标准输入流</li></ul><p>返回值：无</p><hr><p><strong>static void setOut(PrintStram out)</strong></p><p>功能：重定向标准输出</p><p>参数:</p><ul><li>out：重新定向的标准输出流</li></ul><p>返回值：无</p><hr><p>下面两个例子，分别是标准输出重定向:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedirectOut</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 一次性创建PrintStream输出流</span><br><span class="hljs-type">var</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;out.txt&quot;</span>)))<br>&#123;<br><span class="hljs-comment">// 将标准输出重定向到ps输出流</span><br>System.setOut(ps);<br><span class="hljs-comment">// 向标准输出输出一个字符串</span><br>System.out.println(<span class="hljs-string">&quot;普通字符串&quot;</span>);<br><span class="hljs-comment">// 向标准输出输出一个对象</span><br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedirectOut</span>());<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex)<br>&#123;<br>ex.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>标准输入重定向：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedirectIn</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-type">var</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;RedirectIn.java&quot;</span>))<br>&#123;<br><span class="hljs-comment">// 将标准输入重定向到fis输入流</span><br>System.setIn(fis);<br><span class="hljs-comment">// 使用System.in创建Scanner对象，用于获取标准输入</span><br><span class="hljs-type">var</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">// 增加下面一行将只把回车作为分隔符</span><br>sc.useDelimiter(<span class="hljs-string">&quot;\n&quot;</span>);<br><span class="hljs-comment">// 判断是否还有下一个输入项</span><br><span class="hljs-keyword">while</span> (sc.hasNext())<br>&#123;<br><span class="hljs-comment">// 输出输入项</span><br>System.out.println(<span class="hljs-string">&quot;键盘输入的内容是：&quot;</span> + sc.next());<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex)<br>&#123;<br>ex.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>输入输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>File类</title>
    <link href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/File%E7%B1%BB/"/>
    <url>/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/File%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>File类代表与平台无关的文件和<strong>目录</strong>， File可以操作文件和目录，如新建、创建和重命名目录，但是File不能访问文件内容，要想访问文件内容，需要输入输出流。</p><h2 id="访问文件和目录"><a href="#访问文件和目录" class="headerlink" title="访问文件和目录"></a>访问文件和目录</h2><p>File类可以使用文件路径字符串创建File实例，字符串既可以是相对路径，也可以是绝对路径。在默认情况，系统依据用户工作路径解释相对路径，这个路径由系统属性“user.dir”指定，通常就是运行Java虚拟机所在的路径。</p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>绝对路径：盘符开头的路径，表示是一个绝对路径，如”C:/download/a.txt”</p><p>相对路径： 相对路径就是指由这个文件所在的路径引起的跟其它文件（或文件夹）的路径关系。</p><hr><p>“./“：代表当前目录。</p><p>“../“：代表父目录。</p><p>注：在Java源文件用相对路径，默认是工作空间所在目录。</p><ol><li>访问文件名相关方法：</li></ol><pre><code class="hljs">**String getName()**功能：返回此File对象表示的文件名或路径名(如果是路径，只返回最后一级目录名)参数：无返回值：字符串例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/a/b/c/test.txt&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/a/b/c&quot;</span>);<br>System.out.println(file.getName());<br>System.out.println(dir.getName());<br></code></pre></td></tr></table></figure>输出：&lt;img src=&quot;C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200412175643211.png&quot; alt=&quot;image-20200412175643211&quot; style=&quot;zoom:120%;&quot; /&gt;---**String getPath()**功能：返回File对象对应的路径名。参数：无返回值：路径名字符串**注意**：若File对象使用绝对路径构造的，则返回的是绝对路径，若用相对路径构造的，则返回的是相对路径例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/a/b/c/test.txt&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br>System.out.println(file.getPath());<br>System.out.println(file1.getPath());<br></code></pre></td></tr></table></figure>输出：![image-20200412184557985](C:\Users\Bu&#39;l&#39;l&#39;shi&#39;t\AppData\Roaming\Typora\typora-user-images\image-20200412184557985.png )---**File getAbsoluteFile()**功能：返回此对象的绝对路径。参数：无返回值：返回用此File对象绝对路径构造的File对象。---**String getAbsolutePath()**功能：返回此File对象的绝对路径**名**。参数：无返回值：返回此File对象的绝对路径名字符串。**注意**：打印同一个对象使用该方法和上述方法，输出都是一样的，但是该方法返回的只是绝对路径名字构成的字符串，---**String getParent()**功能：返回此对象对应目录的父目录名。参数：无返回值：父目录名构成的字符串**注意**1. 若File对象是文件，则返回该文件所在目录，若File是路径，则返回该目录上一级目录。2. 如果File对象是以相对路径构造的，则用该方法返回的是null，即没有父目录。3. 如果File对象是用绝对路径，则返回绝对路径。例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/a/b/c/test.txt&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;a.txt&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;D:/a/b/c&quot;</span>);<br><span class="hljs-type">File</span> <span class="hljs-variable">dir1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;.&quot;</span>);<br>System.out.println(file.getParent());<br>System.out.println(file1.getParent());<br>System.out.println(dir.getParent());<br>System.out.println(dir1.getParent());<br></code></pre></td></tr></table></figure>输出：&lt;img src=&quot;picture/image-20200413092038023.png&quot; alt=&quot;image-20200413092038023&quot;  /&gt;---**boolean renameTo(File newName)**功能：重命名File对象对应的文件或者目录参数：新名字字符串构成的File对象返回值：如果重命名成功，返回true，否则返回false**注意**只可以该最后一级文件或者目录。其实前面几级也可以改，但会出现错误的情况，所以用就只改最后一级目录。---</code></pre><ol><li>文件检测相关方法：</li></ol><pre><code class="hljs">----**boolean exists()**功能：判断File对象对应文件目录是否存在参数：无返回值：存在返回true，否则false---**boolean canWrite()**功能：判断File对象对应文件或目录是否可写参数：无返回值：可写返回true，否则false---**boolean canRead()**功能：判断对应文件或目录是否可读参数：无返回值：可读返回true，否则false---**boolean isFile()**功能：判断File对象对应的是否为文件参数：无返回值：是文件返回true，否则false---**boolean isDirectory()**功能：判断是否为目录参数：无返回值：是目录返回true，否则false---**boolean isAbsolute()**功能：判断File对象是否为绝对路径，该方法消除了不同平台差异。参数：无返回值：是绝对路径返回true，否则返回false**注意**在UNIX/Linux系统上，绝对路径开头是一条斜线/，在Windows系统上，绝对路径开头是盘符，C盘D盘等等。---</code></pre><ol><li>获取常规文件信息方法：</li></ol><pre><code class="hljs">**long lastModified()**功能：返回文件最后修改时间参数：无返回值：时间构成的long型整数---**long length()**功能：返回文件内容长度，以字节为单位。参数：无返回值：文件内容长度构成的long型整数---</code></pre><ol><li><p>文件操作相关方法：</p><p> | 函数原型                                                     | 功能                                                         | 参数                                                         |<br> | —————————————————————————————— | —————————————————————————————— | —————————————————————————————— |<br> | boolean createNewFile()                                      | 如果File对象对应的文件不存在，<br />则创建一个新文件，<br />创建成功返回ture，<br />否则返回false | 无                                                           |<br> | boolean delete()                                             | 删除File对象对应的文件或路径，<br /><strong>如果是路径，则对应路径必须是空目录</strong> | 无                                                           |<br> | static File createTempFile(String prefix, String suffix)     | 在默认临时文件目录创建临时文件                               | prefix:给定前缀，至少3字节长<br />suffix:后缀，若null，默认”.tmp” |<br> | static File createTempFile(String prefix, String suffix, File directory) | 在指定目录创建临时空文件                                     | prefix和suffix同上<br />directory:指定目录                   |</p></li></ol><ol><li>目录操作相关方法：</li></ol><pre><code class="hljs">**boolean mkdir()**</code></pre><p>功能：创建一个File对象对应的<strong>一个</strong>目录，File对象必须是路径。</p><p>参数：无</p><p>返回值：</p><p>若创建成功，返回ture，否则返回false.</p><p><strong>注意</strong>：</p><p>该方法只能创建一个，若需要创建多级目录，则会创建失败。</p><p>例如 <code>dir.mkdir()</code> 其中dir对应目录“D:/a/b/c”，只能创建c目录，若b目录不存在，会创建失败。</p><hr><p><strong>boolean medirs()</strong></p><p>功能：创建一个File对象对应的多级目录，File对象必须是路径。</p><p>参数：无</p><p>返回值：</p><p>创建成功返回ture，失败返回false</p><p><strong>注意</strong>：</p><p>该方法可以创建多级目录，例如例如 <code>dir.mkdir()</code> 其中dir对应目录“D:/a/b/c”，若a目录不存在，则会按照目录关系一级一级创建。</p><hr><p><strong>String[] list()</strong></p><p>功能：返回File对象的所有子文件名和目录名，File对象必须是路径。</p><p>参数：无</p><p>返回值：返回一个String数组。</p><p><strong>注意</strong>：</p><p>只会返回本目录所有文件的名字和目录的名字。</p><hr><p><strong>File[] listFiles</strong></p><p>功能：列出File对象所有子文件名和目录名，File对象必须是路径。</p><p>参数：无</p><p>返回值：返回一个包含所有File对象的File数组</p><p><strong>注意</strong>:</p><p>若File对象是用绝对路径构造的，则返回的子文件名和目录用getPath()方法返回的是绝对路径<br>若用的是相对路径，则返回的File对象用getPath()方法返回的是相对路径。</p><hr><p><strong>static File[] listRoots()</strong></p><p>功能：列出系统所有的根路径，就是C盘，D盘，静态方法，可用File类直接调用</p><p>参数：无</p><p>返回值：返回一个包含根路径的File对象数组。</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">File[] a = File.listRoots();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">var</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++)<br>&#123;<br>    System.out.println(a[i].getPath());<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="C:\Users\Bu'l'l'shi't\AppData\Roaming\Typora\typora-user-images\image-20200412175210822.png" alt="image-2" style="zoom:120%;" /></p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>输入输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>输入/输出体系</title>
    <link href="/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BD%93%E7%B3%BB/"/>
    <url>/2022/05/11/Java/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E4%BD%93%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="处理流的用法"><a href="#处理流的用法" class="headerlink" title="处理流的用法"></a>处理流的用法</h2><p>使用处理流的典型思路是，使用处理流来包装节点流，程序通过处理流来执行输入/输出功能，让节点流与底层IO设备、文件进行交互。</p><p>实际识别处理流非常简单，只要流的构造器参数不是一个物理节点，而是已经存在的流，它就一定是处理流。<br>        所有节点流都是直接以物理IO节点作为构造器参数的。</p><p>使用PrintStream处理流来包装OutputStream的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintStreamTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-type">var</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;test.txt&quot;</span>);<br><span class="hljs-type">var</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStream</span>(fos))<br>&#123;<br><span class="hljs-comment">// 使用PrintStream执行输出</span><br>ps.println(<span class="hljs-string">&quot;普通字符串&quot;</span>);<br><span class="hljs-comment">// 直接使用PrintStream输出对象</span><br>ps.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintStreamTest</span>());<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ioe)<br>&#123;<br>ioe.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>提示：由于PrintStream类的输出功能非常强大，通常如果需要输出文本内容，都应该包装成PrintStream后进行输出。</p><p><strong>注意</strong>：</p><p>使用处理流包装了底层节点流后，关闭输入/输出资源时，只要关闭最上层的处理流即可，系统会自动关闭被该处理流包装的节点流。</p><h2 id="输入-输出体系"><a href="#输入-输出体系" class="headerlink" title="输入/输出体系"></a>输入/输出体系</h2><p>Java输入/输出流体系常用流分类</p><div class="table-container"><table><thead><tr><th>分类</th><th>字节输入流</th><th>字节输出流</th><th>字符输入流</th><th>字符输出流</th></tr></thead><tbody><tr><td>抽象基类</td><td><em>InputStream</em></td><td><em>OutputStream</em></td><td><em>Reader</em></td><td><em>Writer</em></td></tr><tr><td>访问文件</td><td>FileInputStream</td><td>FileOutputStream</td><td>FileReader</td><td>FileWriter</td></tr><tr><td>访问数组</td><td>ByteArrayInputStream</td><td>ByteArrayOutputStream</td><td>CharArrayReader</td><td>CharArrayWriter</td></tr><tr><td>访问管道</td><td>PipedInputStream</td><td>PipedOutputStream</td><td>PipedReader</td><td>PipedWriter</td></tr><tr><td>访问字符串</td><td></td><td></td><td>StringReader</td><td>StringWriter</td></tr><tr><td>缓冲流</td><td>BufferedInputStream</td><td>BufferedOutputStream</td><td>BufferedReader</td><td>BufferedWriter</td></tr><tr><td>转换流</td><td></td><td></td><td>InputStreamReader</td><td>OutputStreamWriter</td></tr><tr><td>对象流</td><td>ObjectInputStream</td><td>ObjectOutputStream</td><td></td><td></td></tr><tr><td>抽象基类</td><td><em>FilterInputStream</em></td><td><em>FilterOutputStream</em></td><td><em>FilterReader</em></td><td><em>FilterWriter</em></td></tr><tr><td>打印流</td><td></td><td>PrintStream</td><td></td><td>PrintWriter</td></tr><tr><td>推回输入流</td><td>PushbackInputStream</td><td></td><td>PushbackReader</td><td></td></tr><tr><td>特殊流</td><td>DataInputStream</td><td>DataOutputStream</td><td></td></tr></tbody></table></div><p><strong>注意</strong>：</p><p>字节流的功能比字符流的功能强大，因为计算机的所有数据都是二进制的，但问题是，如果使用字节流来处理文本文件，需要使用合适的方式把字节转换成字符，增加了编程难度。所以一个规则是：如果进行输入输出的数是文本文件，则考虑使用字符流，如果是二进制内容，考虑字节流。</p><h2 id="计算机的文件分类"><a href="#计算机的文件分类" class="headerlink" title="计算机的文件分类"></a>计算机的文件分类</h2><p>计算机文件通常分为二进制文件和文本文件两类，所有能用记事本打开并且可以看到字符内容的文件都是文本文件，反之则是二进制文件。实际上，计算机里所有文件都是二进制文件，文本文件只是二进制的一种特例。当二进制的内容刚好能被正常解析成文本，该二进制文件就变成了文本文件。如果要看到正常的文本内容，则必须在打开文件时与保存文件时使用相同的字符集，Windows系统简体中文默认使用GBK字符集，Linux系统默认使用UTF-8字符集。</p><h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><p>输入/输出体系提供了两个转换流InputStreamReader 、OutputStreamWriter，用于将字节流转换为字符流，一个将字节输入流转换为字符输入流，一个将字节输出流转换为字符输出流。</p><p>Java没有提供将字符流转换为字节流的类。</p><p>Java使用System.in代表标准输入，但这个标准输入流是InputStream类的实例，使用不方便，而且键盘输入都是文本内容，所以可以使用InputStreamReader将其转换为字符输入流，普通的Reader读取输入内容依然不太方便，可以将Reader再次包装成BufferedReader，利用BufferedReader的readLine()方法可以一次性读取一行。</p><p>如下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">KeyinTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 将Sytem.in对象转换成Reader对象</span><br><span class="hljs-type">var</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in);<br><span class="hljs-comment">// 将普通Reader包装成BufferedReader</span><br><span class="hljs-type">var</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(reader))<br>&#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// 采用循环方式来一行一行的读取</span><br><span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>)<br>&#123;<br><span class="hljs-comment">// 如果读取的字符串为&quot;exit&quot;，程序退出</span><br><span class="hljs-keyword">if</span> (line.equals(<span class="hljs-string">&quot;exit&quot;</span>))<br>&#123;<br>System.exit(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">// 打印读取的内容</span><br>System.out.println(<span class="hljs-string">&quot;输入内容为:&quot;</span> + line);<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ioe)<br>&#123;<br>ioe.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="推回输入流"><a href="#推回输入流" class="headerlink" title="推回输入流"></a>推回输入流</h2><p>有两个特殊的类，就是PushbackInputStream和PushbackReader，他们都提供了三个方法：</p><p><strong>void unread(byte[]/char[] buf)</strong></p><p>功能：将一个字节/字符数组推回到缓冲区里，从而允许重复读取内容。</p><p>参数：</p><ul><li>byte[]/char[] buf:需要推回的字节/字符数组；</li></ul><p>返回值：无</p><hr><p><strong>void unread(byte[]/char[] buf, int off, int len)</strong></p><p>功能：将一个字节/字符数组从off开始，长度为len字节/字符的内容推回到缓冲区里，从而允许重复读取内容。</p><p>参数：</p><ul><li>byte[]/char[] buf:需要推回的字节/字符数组；</li><li>off：需要推回内容的开始位置；</li><li>len:推回内容的长度</li></ul><p>返回值：无</p><hr><p><strong>void unread(int b)</strong></p><p>功能：将一个字节/字符推回到缓冲区里，从而允许重复读取内容。</p><p>参数：</p><ul><li>b:需要推回的字节/字符；</li></ul><p>返回值：无</p><hr><p>这两个推回输入流都带有一个推回缓冲区，当程序调用这两个推回输入流的unread()方法时，系统会把指定内容推回该缓冲区，而推回输入流每次调用read()方法时，总是先从推回缓冲区读取，只有完全读取了推回缓冲区的内容以后，才会从原输入流读取。</p><p>创建推回输入流实例需要指定缓冲区大小，默认缓冲区长度为1，如果推回缓冲区内容超过缓冲区大小，会引发异常。</p><p>下面程序找出程序的”new PushbackReader”字符串，找到后，程序打印目标字符串之前的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PushbackTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-keyword">try</span> (<br><span class="hljs-comment">// 创建一个PushbackReader对象，指定推回缓冲区的长度为64</span><br><span class="hljs-type">var</span> <span class="hljs-variable">pr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PushbackReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<br><span class="hljs-string">&quot;PushbackTest.java&quot;</span>), <span class="hljs-number">64</span>))<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[<span class="hljs-number">32</span>];<br><span class="hljs-comment">// 用以保存上次读取的字符串内容</span><br><span class="hljs-type">var</span> <span class="hljs-variable">lastContent</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-type">var</span> <span class="hljs-variable">hasRead</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 循环读取文件内容</span><br><span class="hljs-keyword">while</span> ((hasRead = pr.read(buf)) &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 将读取的内容转换成字符串</span><br><span class="hljs-type">var</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, hasRead);<br><span class="hljs-type">var</span> <span class="hljs-variable">targetIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 将上次读取的字符串和本次读取的字符串拼起来，</span><br><span class="hljs-comment">// 查看是否包含目标字符串, 如果包含目标字符串</span><br><span class="hljs-keyword">if</span> ((targetIndex = (lastContent + content)<br>.indexOf(<span class="hljs-string">&quot;new PushbackReader&quot;</span>)) &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 将本次内容和上次内容一起推回缓冲区</span><br>pr.unread((lastContent + content).toCharArray());<br><span class="hljs-comment">// 重新定义一个长度为targetIndex的char数组</span><br><span class="hljs-keyword">if</span> (targetIndex &gt; <span class="hljs-number">32</span>)<br>&#123;<br>buf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[targetIndex];<br>&#125;<br><span class="hljs-comment">// 再次读取指定长度的内容（就是目标字符串之前的内容）</span><br>pr.read(buf, <span class="hljs-number">0</span>, targetIndex);<br><span class="hljs-comment">// 打印读取的内容</span><br>System.out.print(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buf, <span class="hljs-number">0</span>, targetIndex));<br>System.exit(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// 打印上次读取的内容</span><br>System.out.print(lastContent);<br><span class="hljs-comment">// 将本次内容设为上次读取的内容</span><br>lastContent = content;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ioe)<br>&#123;<br>ioe.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>输入输出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Set集合</title>
    <link href="/2022/05/11/Java/%E9%9B%86%E5%90%88/Set%E9%9B%86%E5%90%88/"/>
    <url>/2022/05/11/Java/%E9%9B%86%E5%90%88/Set%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Set集合不允许元素重复，如果向Set集合添加一个已经存在的元素，则会添加失败</p><h2 id="HashSet类"><a href="#HashSet类" class="headerlink" title="HashSet类"></a>HashSet类</h2><p>HashSet类是Set接口典型实现，大多时候使用Set时就是使用这个，HashSet按Hash算法来存储集合中的元素，因此存取和查找性能很好。</p><p>几个特点</p><ul><li>不保证元素的排列顺序，顺序可能与添加顺序不一致</li><li>HashSet不是同步的，如果有多个线程访问同一个HashSet，假设有两个或以上的线程同时修改了HashSet集合，必须通过代码保证同步</li><li><strong>集合元素值可以是null</strong></li></ul><p>当向HashSet集合添加元素时，HashSet会调用该对象的hashcode()方法得到hashcode值，然后依据这个值来决定存储位置，<strong>如果有两个元素通过equals方法比较返回true，但是hashcode()方法返回值不相等，HashSet会把它们存储在不同位置，依然可以添加成功。</strong></p><p>即HashSet集合判断元素是否相等的标准是equals方法返回相等，并且hashcode()方法返回值也相等。</p><p>那么如果要重写对象对应类的equals方法，也应该重写对应的hashcode()方法，规则是：<strong>如果两个对象通过equals方法返回true，那么hashcode()也应该返回值也应该相同。</strong></p><p>HashSet集合每一个能存储元素的位置通常称为“桶”，如果多个元素的hashcode值相等，但是equals方法返回false，那么就需要在一个“桶”里放多个元素，这会导致性能下降。</p><p>重写hashcode方法的基本原则</p><ul><li>程序运行时，同一个对象多次调用hashcode()方法应该返回相同的值</li><li>两个对象通过equals比较返回true时，hashcode值也应该相同</li><li><strong>对象中用作equals方法比较标准的实例变量，也应该用于计算hashcode值</strong></li></ul><p>重写hashcode方法的一般步骤</p><ol><li><p>把对象内每个有意义的实例变量计算出一个int类型的hashcode值</p></li><li><p>用第一步算出来的多个hashcode值组合成一个hashcode值返回</p><p> 为了避免直接相加产生偶然相等，可以使各实例变量的hashcode值乘以任意一个质数</p></li></ol><p><strong>当把可变对象添加到HashSet中之后，不要再去修改该集合元素参与运算hashcode()、equals方法的实例变量</strong>，否则会导致HashSet无法正确操作这些集合元素。</p><h3 id="LinkedHashSet类"><a href="#LinkedHashSet类" class="headerlink" title="LinkedHashSet类"></a>LinkedHashSet类</h3><p>它是HashSet类的子类，LinkedHashSet集合也使用hashcode值来决定存储位置，但它同时使用链表维护元素的次序，当遍历LinkedHashSet集合的元素时，LinkedHashSet会按元素的添加顺序来访问集合元素。</p><p>LinkedHashSet需要维护元素插入顺序，所以性能略低于HashSet性能</p><p><strong>注意：虽然使用链表来维护内部顺序，但是LinkedHashSet依然不允许元素重复。</strong></p><h2 id="TreeSet类"><a href="#TreeSet类" class="headerlink" title="TreeSet类"></a>TreeSet类</h2><p>TreeSet类是SortedSet接口的实现类，TreeSet可以保证集合元素处于排序状态，与HashSet相比，TreeSet还提供了几个额外方法</p><ul><li><p><strong>Comparator comparator()</strong>：如果TreeSet采用了定制排序，则该方法返回定制排序所使用的Comparator，如果TreeSet使用了自然排序，则返回null</p></li><li><p><strong>Object first()</strong>：返回集合第一个元素</p></li><li><p><strong>Object last()</strong>：返回集合最后一个元素</p></li><li><p><strong>Object lower(Object e)</strong>：返回集合中位于指定元素e之前的元素(即小于指定元素e的最大元素，e不一定是TreeSet里的元素)</p></li><li><p><strong>Object higher(Object e)</strong>：返回集合中位于指定元素e之后的元素(即大于指定元素e的最小元素，e不一定是TreeSet里的元素)</p></li><li><p><strong>SortedSet subSet(Object fromElement, Object toElement)</strong>：返回此Set的子集合，返回从formElement(包含)到toElement(不包含)</p></li><li><p><strong>SortedSet headSet(Object toElement)</strong>：返回此Set的子集合，由小于toElement的元素组成</p></li><li><p><strong>SortedSet tailSet(Object fromElement)</strong>：返回此Set的子集合，由大小或等于romElement的元素组成</p></li></ul><p>TreeSet支持两种排序方式：自然排序、定制排序</p><p>默认情况，TreeSet使用自然排序。</p><h3 id="自然排序"><a href="#自然排序" class="headerlink" title="自然排序"></a>自然排序</h3><p>TreeSet会调用元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排列，这种方式就是自然排序。</p><p>Java提供了一个Comparable接口，<strong>该接口定义了一个compareTo(Object obj)方法，该方法返回一个整数值，若该对象大于obj对象，返回正整数，小于obj对象返回负整数，等于返回0</strong></p><p>实现了该接口才可以比较大小，也才可以把对应类的对象放入TreeSet集合中</p><p>实现了Comparaable接口的常用类</p><ul><li>BigDecimal，BigInteger以及所有数组型对应的包装类</li><li>Character：按字符Unicode值进行比较</li><li>Boolean：true对应包装类实例大于false对应包装类实例</li><li>String：依次比较字符串每个字符的Unicode值</li><li>Date、Time：后面的时间大于前面的时间</li></ul><p><strong>注意：因为只有相同类的实例才会比较大小，所有向TreeSet中添加的元素应该是同一类的对象，否则会抛出ClassCastException异常。</strong></p><p><strong>对于TreeSet来说，判断两个对象相等的唯一方法就是调用对象的compareTo()方法，返回0，则相等，否则不相等</strong></p><p><strong>当判断相等时，TreeSet无法把元素添加到集合中。</strong></p><p>这里应该注意一个问题，当重写该对象对应类的equals方法时，应该保证该方法与compareTo(Object obj)方法有一致的结果，即<strong>如果两个对象通过equals方法返回相等时，这两个对象通过compareTo方法也应该返回0。</strong></p><p><strong>不要修改放入HashSet和TreeSet集合中元素的关键实例变量。</strong></p><h3 id="定制排序"><a href="#定制排序" class="headerlink" title="定制排序"></a>定制排序</h3><p>如果需要实现定制排序，则可以通过<strong>Comparator</strong>接口的帮助，该接口包含一个<strong>int compare(T o1, T o2)</strong>方法，如果o1大于o2，返回正整数，o1小于o2返回负整数，相等返回0</p><p>如果要实现定制排序，则在创建TreeSet集合对象时，需要提供一个Comparator对象与该集合关联，Comparator是一个函数式接口，可以用Lambda表达式来代替Comparator对象。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">M</span><br>&#123;<br><span class="hljs-type">int</span> age;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">M</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span><br>&#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;M [age:&quot;</span> + age + <span class="hljs-string">&quot;]&quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSetTest4</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-comment">// 此处Lambda表达式的目标类型是Comparator</span><br><span class="hljs-type">var</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>((o1, o2) -&gt;<br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> (M) o1;<br><span class="hljs-type">var</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> (M) o2;<br><span class="hljs-comment">// 根据M对象的age属性来决定大小，age越大，M对象反而越小</span><br><span class="hljs-keyword">return</span> m1.age &gt; m2.age ? -<span class="hljs-number">1</span><br>: m1.age &lt; m2.age ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;);<br>ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">M</span>(<span class="hljs-number">5</span>));<br>ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">M</span>(-<span class="hljs-number">3</span>));<br>ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">M</span>(<span class="hljs-number">9</span>));<br>System.out.println(ts);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：使用定制排序时，依然不能向TreeSet集合添加不同类的对象，否则会引发异常。</strong></p><h2 id="EnumSet类"><a href="#EnumSet类" class="headerlink" title="EnumSet类"></a>EnumSet类</h2><p>EnumSet是一个专为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式或者隐式的指定，EnumSet的集合元素也是有序的，EnumSet以枚举值在Enum类里定义顺序来决定集合元素的顺序。</p><p><strong>EnumSet集合不允许添加null元素</strong>。</p><p>EnumSet没有暴露任何构造器，程序应该用它提供的类方法来创建EnumSet对象</p><ul><li><strong>EnumSet allOf(Class elementType)</strong>：创建一个包含指定枚举类所有枚举值的EnumSet集合</li><li><strong>EnumSet complementOf(EnumSet s)</strong>：创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，该集合包含原EnumSet集合不存在的、枚举类剩下的枚举值(新EnumSet集合和旧EnumSet集合加起来就是枚举类所有的枚举值)</li><li><strong>EnumSet copyOf(Collection c)</strong>：使用一个普通集合来创建EnumSet集合,要求Collection所有元素必须是同一枚举类的枚举值</li><li><strong>EnumSet copyOf(EnumSet s)</strong>：创建一个与指定EnumSet具有相同类型相同集合元素的EnumSet集合</li><li><strong>EnumSet noneOf(Class elementType)</strong>：创建一个元素类型为指定枚举类型的空EnumSet</li><li><strong>EnumSet of(E first,E….rest)</strong>：创建一个包含一个或多个枚举值的EnumSet集合，传入的多个枚举值必须属于同一个枚举类</li><li><strong>EnumSet range(E from, E to)</strong>：创建一个从from枚举值到to枚举值范围内所有枚举值的EnumSet集合</li></ul><h2 id="各Set实现类的性能分析"><a href="#各Set实现类的性能分析" class="headerlink" title="各Set实现类的性能分析"></a>各Set实现类的性能分析</h2><p>HahsSet的性能总是比TreeSet好(特别是常用的添加查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护元素次序，只有需要一个保持排序的Set时，才需要TreeSet，否则都应该用HashSet</p><p>LinkedHashSet需要维护链表，所有也比HashSet性能差一点，但遍历集合会更快</p><p>Set的三个实现类都是线程不安全的，如果有多个线程访问该集合，并且超过一个线程修改了该Set集合，则必须手动保证该Set集合的同步性。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Queue集合</title>
    <link href="/2022/05/11/Java/%E9%9B%86%E5%90%88/Queue%E9%9B%86%E5%90%88/"/>
    <url>/2022/05/11/Java/%E9%9B%86%E5%90%88/Queue%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Queue用于模拟队列这种数据结构，Queue接口定义了几个方法</p><ul><li><strong>void add(Object e)</strong>：将指定元素加入到队列尾部</li><li><strong>boolean offer(Object e)</strong>：将指定元素添加到队列尾部，当使用容量有限的队列时，此方法比add更好一些</li><li><strong>Object element()</strong>：获取队列头部的元素，但是不删除该元素</li><li><strong>Object peek()</strong>：获取队列头部元素,但是不删除该元素，如果队列为空，返回null</li><li><strong>Object poll()</strong>：获取队列头部元素，并删除该元素，如果队列为空，返回null</li><li><strong>Object remove()</strong>：获取队列头部元素，并删除该元素</li></ul><p>Queue接口有一个PriorityQueue实现类。除此之外Queue还有一个Deque子接口，Deque代表一个双端队列，可以从两端增加、删除元素，因此Deque的实现类既可以当成队列使用，也可以当成栈来使用。Deque有ArrayDeque和LinkedList两个实现类。</p><h2 id="PriorityQueue实现类"><a href="#PriorityQueue实现类" class="headerlink" title="PriorityQueue实现类"></a>PriorityQueue实现类</h2><p>PriorityQueue是一个比较标准的队列实现类，之所以说是比较标准，而不是绝对标准，<strong>是因为PriorityQueue保存队列元素并不是按加入队列的顺序，而是按队列元素的大小重新排序。</strong>因此当使用peek或者poll取出队列元素时，并不是取出最先进入的元素，而是最小的元素。从这个意义上看，PriorityQueue已经违反了队列的最基本原则：先入先出</p><p><strong>PriorityQueue不允许插入null元素</strong></p><p>PriorityQueue有两种排序方式，自然排序和定制排序。和TreeSet一样，在这里不重复。</p><h2 id="Deque接口和ArrayDeque实现类"><a href="#Deque接口和ArrayDeque实现类" class="headerlink" title="Deque接口和ArrayDeque实现类"></a>Deque接口和ArrayDeque实现类</h2><p>Deque接口是Queue的子接口，它代表一个双端队列，有一些操作元素的方法</p><ul><li><strong>void addFirst(Object e)</strong>：将指定元素插入到双端队列的开头</li><li><strong>boolean offerFirst(Object e)</strong>：将指定元素插入到该队列的开头</li><li><strong>void addLast(Object e)</strong>：将指定元素插入到双端队列的末尾</li><li><strong>boolean offerLast(Object e)</strong>：将指定元素插入到该队列的末尾</li></ul><ul><li><strong>Iterator descendingIterator()</strong>：返回该双端队列对应的迭代器，它将以逆向顺序迭代队列</li></ul><ul><li><p><strong>Object getFirst()</strong>：获取但不删除队列第一个元素</p></li><li><p><strong>Object getLast()</strong>：获取但不删除队列的最后一个元素</p></li></ul><ul><li><p><strong>Object peekFirst()</strong>：获取但不删除该队列的第一个元素，如果队列为空，返回null</p></li><li><p><strong>Object peekLast()</strong>：获取但不删除该队列的最后一个元素，如果队列为空，返回null</p></li><li><p><strong>Object pollFirst()</strong>：获取并且删除该队列的第一个元素，如果队列为空，返回null</p></li><li><p><strong>Object pollLast()</strong>：获取并且删除该队列的最后一个元素，如果队列为空，返回null</p></li></ul><ul><li><p><strong>Object pop() (栈方法)</strong>：弹出该栈的栈顶元素，相等于removeFirst()</p></li><li><p><strong>Object push(Object e) (栈方法)</strong>：将元素e放入栈的栈顶，相等于addFirst()</p></li><li><p><strong>Object removeFirst()</strong>：获取并删除该双端队列第一个元素</p></li><li><p><strong>Object removeFirstOccurence(Object e)</strong>：删除该双端队列的第一次出现元素o</p></li><li><p><strong>Object removeLast()</strong>：获取并删除该双端队列最后一个元素</p></li><li><p><strong>Object removeLastOccurence(Object e)</strong>：删除该双端队列的最后一次出现元素o</p></li></ul><p>Deque接口提供了一个典型实现类：ArrayDeque，它是一个基于数组实现的双端队列，创建Deque时可以指定numElements参数，如果不指定，默认为16</p><p><strong>Tips：ArrayList和ArrayDeque两个集合类实现机制基本类似，底层都使用一个动态的、可重分配的Object[]数组来存储集合元素，当超出数组容量时，系统会在底层重新分配一个Object[]数组来存储集合元素。</strong></p><h2 id="LinkedList实现类"><a href="#LinkedList实现类" class="headerlink" title="LinkedList实现类"></a>LinkedList实现类</h2><p>LinkedList实现类是List接口的实现类,意味着它是一个List集合，可以根据索引随机访问集合中的元素，除此之外LinkedList还实现了Deque接口，可以被当成双端队列来使用。</p><p>LinkedList可以作为List集合、双端队列、栈来使用，说明LinkedList是一个功能很强大的集合类。</p><p>LinkedList内部以链表的方式保存元素，在随意访问集合元素时性能较差，但插入和删除时性能出色。</p><h2 id="各种线性表的性能分析"><a href="#各种线性表的性能分析" class="headerlink" title="各种线性表的性能分析"></a>各种线性表的性能分析</h2><p>数组使用连续内存区保存元素，因此在随即访问时性能最好，而内部以链表实现的集合在执行插入和删除时有较好性能。</p><p>但是总体来说，ArrayList比LinkedList性能更好，因此大部分时候都使用ArrayList</p><p>关于使用List集合有如下建议</p><ul><li>如果需要遍历List集合，对于ArrayList、Vector集合，应该使用随机访问(get)来遍历集合元素，这样性能更好，对于LinkedList集合，采用迭代器Iterator遍历更好</li><li>如果需要经常执行插入删除操作，可以考虑使用LinkedList集合</li><li>如果有多个线程需要同时访问List集合中的元素，可以考虑使用Collections将集合包装成线程安全的集合。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Map集合</title>
    <link href="/2022/05/11/Java/%E9%9B%86%E5%90%88/Map%E9%9B%86%E5%90%88/"/>
    <url>/2022/05/11/Java/%E9%9B%86%E5%90%88/Map%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Map集合用于保存具有映射关系的数据，因此Map集合保存两组值，一组是Map里的key，一组是Map里的value。两者都可以是任何引用类型的数据，<strong>key不允许重复，即同一个Map对象的任意两个key通过equals方法比较总是返回false。</strong></p><p>如果把Map里所有key放在一起，他们就组成了一个Set集合(没有顺序，不能重复)。</p><p>Map有时候有人被称为字典或者关联数组。</p><p>Map类提供了一个Entry内部类来封装key-value对。</p><p>Map定义了以下方法：</p><p><strong>void clear</strong>：删除所有key-value对</p><p><strong>boolean containsKey()</strong>：查询Map中是否包含指定key，包含返回true</p><p><strong>boolean containsValue()</strong>：查询Map中是否包含一个或多个value，包含返回true</p><p><strong>Set entrySet()</strong>：返回Map中包含的key-value对所组成的Set集合，每个集合元素是一个Map.Entry对象</p><p><strong>Set keySet()</strong>：返回该Map中所有key组成的Set集合</p><p><strong>Object get(Object key)</strong>：返回指定key对应的value，如果此Map中不包含该key，返回null</p><p><strong>boolean isEmpty()</strong>：查询该Map是否为空，如果为空返回true</p><p><strong>Object put(Object key, Object value)</strong>：添加一个key-value对，如果当前Map中有一个与该key相等的key-value对，则                                                                        新的会覆盖旧的</p><p><strong>void putAll(Map m)</strong>：将指定Map中所有的key-value对复制到本Map中</p><p><strong>Object remove(Object key)</strong>：删除指定key对应的key-value对，并返回，如果不存在返回null</p><p><strong>boolean remove(Object key, Object value)</strong>：删除指定key和value对应的key-value对，删除成功返回true</p><p><strong>int size()</strong>：返回该Map里的key-value对的个数</p><p><strong>Collection values()</strong>：返回该Map里所有value组成的Collection</p><hr><p>Java 8新增方法</p><p><strong>Object compute(Object key, BiFunction remappingFunction)</strong></p><p>该方法使用remappingFunction根据原来的key-value对计算出一个新的value。只要新value不为null，就使用新value覆盖旧value，返回新value；如果原value不为null，但新value为null，则删除原来key-value对，并返回null；如果原来(即不存在指定的key)、新的value都为null，就不改变任何key-value对，直接返回null。</p><hr><p><strong>Object computeIfAbsent(Object key, Function remappingFunction)</strong></p><p><strong>如果传给该方法的key对应value为null，即Map集合不存在此key</strong>，则根据key计算一个新的value，如果新value不为null，则替换旧value，并返回新value；如果新value为null，则删除原key-value对，直接返回null。(<strong>如果指定key对应value不为null，直接返回对应value</strong>)</p><hr><p><strong>Object computeIfPresent(Object key, BiFunction remappingFunction)</strong></p><p><strong>如果传给该方法key参数在Map对应value不为null，即Map集合存在该key</strong>，则该方法会用remappingFunction根据原key，value计算一个新value，如果计算结果不为null，则替换原来value，如果为null，则删除原来key-value对。(<strong>如果传给方法的key对应value为null，即Map集合不存在value则直接返回nul</strong>l)</p><hr><p><strong>void forEach(BiConsumer action)</strong></p><p>该方法可以更简洁遍历Map的key，value对。</p><hr><p><strong>Object getOrDefault(Object key, V defaultValue)</strong></p><p>获取指定key对应value，如果key不存在，返回defaultValue</p><hr><p><strong>Object merge(Object key, Object value, BiFunction remappingFunction)</strong></p><p>该方法会先根据key参数获取该Map中对应的value，如果获取的value为null，则直接用传入的value覆盖原来的value，即添加一组新的key-value对；   如果获取的value不为null，则使用remappingFunction根据原value和新value计算新的结果，并覆盖原来value。</p><hr><p><strong>Object putIfAbsent(Object key, Object value)</strong></p><p>该方法会自动检测指定key对应的value是否为null，如果为null，则会用新的value替换旧的value。并返回null，如果对应value不为空，则返回对应value。</p><hr><p><strong>Object replace(Object key, Object value)</strong></p><p>将Map中指定的key对应的value替换成新的value，并返回旧的value。与传统put方法不同，如果不存在指定的key，那么不会添加新key-value对，而是直接返回null</p><hr><p><strong>boolean replace(K key, V oldValue, V newValue)</strong></p><p>将Map中指定key-value对的原value替换成新value，如果找到指定key-value对，则执行替换并返回true，否则返回false</p><hr><p><strong>void replaceAll(BiFunction function)</strong></p><p>使用function对原来的每组key-value对执行计算，并将计算结果作为该key-value对的value值</p><hr><p>Entry是Map类的内部类，包含三个方法</p><ul><li><strong>Object getKey()</strong>：返回该Entry里包含的key值</li><li><strong>Object getValue()</strong>：返回该Entry里包含的value值</li><li><strong>Object setValue(V value)</strong>：设置该Entry里包含的value，并返回新设置的value值</li></ul><h2 id="HashMap和Hashtable实现类"><a href="#HashMap和Hashtable实现类" class="headerlink" title="HashMap和Hashtable实现类"></a>HashMap和Hashtable实现类</h2><p>HashMap和Hashtable都是Map接口的典型实现类，他们之间的关系类似于ArrayList和Vector。Hahstable是一个古老的Map实现类。尽量少使用Hahstable类。</p><p>HashMap和Hashtable有几个典型区别</p><ul><li>Hahstable是线程安全的，HashMap不是</li><li>Hashtable不允许使用null作为key或者value，但HahsMap允许。</li></ul><p>由于HashMap里的key不允许重复，所以HashMap最多有一个key-value对的key为null，但可以由无数多个key-value对的value为null。</p><p>HashMap和Hashtable不能保证其中key-value对的顺序。</p><p>HashMap和Hashtable判断两个key相等的标准是：两个key通过equals方法返回true，且hashcode值相同。</p><p>HashMap保存key的方式和HashSet保存集合元素的方式一样，所以都有同样的要求，即重写对应类的equals方法和hashcode时，应保持一致。</p><h2 id="LinkedHashMap实现类"><a href="#LinkedHashMap实现类" class="headerlink" title="LinkedHashMap实现类"></a>LinkedHashMap实现类</h2><p>LinkedHashMap实现类是HashMap的子类，LinkedHashMap实现类使用双向链表来维护key-value对的顺序，该链表负责维护Map的迭代顺序，这与插入顺序一致。</p><p>LinkedHashMap实现类因为使用链表来维护元素插入顺序，性能略低于HashMap，但在迭代访问所有元素时，有较好的性能。</p><h2 id="使用Properites类读写属性文件"><a href="#使用Properites类读写属性文件" class="headerlink" title="使用Properites类读写属性文件"></a>使用Properites类读写属性文件</h2><p>Properites类是Hashtable的子类，该对象在处理属性文件时很方便，Windows操作系统的ini文件就是一种属性文件。</p><p>Properites类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入属性文件，也可以把属性文件的”属性名=属性值“加载到Map对象中。由于属性文件的属性名和属性值都只能是字符串类型，所以Properites类的key和value都是字符串类型。</p><p>其实，Properites相当于一个key、value都是String的Map。</p><p>Properites类提供了几个方法</p><ul><li><strong>String getProperty(String key)</strong>：获取Properites中指定属性名的属性值，类似于Map的get(Object key)方法</li><li><strong>String getProperty(String key, String defaultValue)</strong>：该方法与前一个基本类似，多一个功能是如果Properites中不存在指定key，则返回defaultValue</li><li><strong>Object setProperty(String key, String value)</strong>：设置属性值</li><li><strong>void load(InputStream inStream)</strong>：从属性文件中加载key-value对，把加载到的key-value对追加到Properites中</li><li><strong>void store(OutputStream out, String comments)</strong>：将Properites中的key-value对输出到指定的属性文件中</li></ul><h2 id="SortedMap接口和TreeMap实现类"><a href="#SortedMap接口和TreeMap实现类" class="headerlink" title="SortedMap接口和TreeMap实现类"></a>SortedMap接口和TreeMap实现类</h2><p>SortedMap接口有一个TreeMap实现类,TreeMap就是一个红黑树数据结构，每个key-value对作为一个节点，根据key对节点进行排序。</p><p>TreeMap有两种排序方式。</p><ul><li>自然排序：TreeMap的所有key必须实现Comparable接口，该对象负责对TreeMap中所有的key进行排序，否则会抛出异常</li><li>定制排序：创建TreeMap时，传入一个Compatator对象，来负责对所有key进行排序，采用定制排序不要求Map的key实现Comparable接口</li></ul><p>如果使用自定义类作为TreeMap的key，则重写该类的equals方法和comnpareTo方法时，应保持一致的结果。</p><p>TreeMap提供了一系列根据key顺序访问key-value对的方法</p><ul><li><strong>Map.Entry firstEntry()：</strong>返回该Map中最小key对应的key-value对，如果Map为空，返回null</li><li><strong>Map.Entry lastEntry()：</strong>返回该Map中最大key对应的key-value对，如果Map为空，返回null</li><li><strong>Map.Entry higherEntry() ：</strong>返回该Map中位于key后一位的key-value对(即大于指定key的最小key对应的key-value对)，如果Map为空，返回null</li><li><strong>Map.Entry lowerEntry()：</strong>返回该Map中位于key前一位的key-value对(即小于指定key的最大key对应的key-value对)，如果Map为空，返回null</li><li><strong>Object firstKey()：</strong>返回该Map中最小的key值，如果该Map为空，返回null</li><li><strong>Object lastKey()：</strong>返回该Map中最大的key值，如果该Map为空，返回null</li><li><strong>Object higherKey()：</strong>返回该Map中位于key后一位的key值(即大于指定key的最小key值)，如果该Map为空，返回null</li><li><strong>Object lowerKey()：</strong>返回该Map中位于key前一位的key值(即小于指定key值的最大key值)，如果该Map为空，返回null</li><li><strong>NavigableMap subMap(Object fromKey, boolean fromInclusive, Object toKey, boolean toInclusive)</strong>：返回该Map的子Map，其key的范围是从fromKey到toKey,是否包含两个边界取决于每个参数后面的布尔参数</li><li><strong>SortedMap subMap(Object fromKey, Object toKey)：</strong>返回该Map的子Map，其key的范围是从fromKey(包括)到toKey(不包括)</li><li><strong>SortedMap tailMap(Object fromKey)：</strong>返回该Map的子Map，其key的范围是大于fromKey(包括)的所有key</li><li><strong>NavigableMap tailMap(Object fromKey, boolean fromInclusive)</strong>：返回该Map的子Map，其key的范围是大于fromKey(是否包含取决于第二个参数)的所有key</li><li><strong>SortedMap headMap(Object toKey)</strong>：返回该Map的子Map，其key的范围是小于toKey(不包括)的所有key</li><li><strong>NavigableMap headMap(Object toKey, boolean inclusive)</strong>：返回该Map的子Map，其key的范围是小于toKey(是否包含取决于第二个参数)的所有key</li></ul><h2 id="WeakHashMap实现类"><a href="#WeakHashMap实现类" class="headerlink" title="WeakHashMap实现类"></a>WeakHashMap实现类</h2><p>WeakHashMap实现类和HashMap的用法基本相似，与HashMap的区别在于，HashMap的key保留了对实际对象的强引用，这意味着只要该HashMap对象不被销毁，该HashMap的所有key所饮用的对象就不会被垃圾回收，HashMap也不会自动删除这些key对应的key-value对，但WeakHashMap的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除这些key对应的key-value对</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                <span class="hljs-type">Map</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>();<br><br>                a.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;语文&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;良好&quot;</span>));<br>                a.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;数学&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;及格&quot;</span>));<br>                a.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;英语&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;中等&quot;</span>));<br><br>                a.put(<span class="hljs-string">&quot;物理&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;超级棒的&quot;</span>));<br><br>                System.out.println(a);<br><br>                System.gc();<br><br>                System.runFinalization();<br><br>                System.out.println(a);<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="D:\各种文档\个人文档\学习总结\Java\集合\image\image-20200504180133511.png" alt="image-20200504180133511"></p><p>可以看出，当进行垃圾回收时，删除了WeakHashMap对象的前三个key-value对，因为添加前三个时，三个key都是匿名的字符串对象，WeakHashMap只保留了对他们的弱引用，这样垃圾回收时会自动删除。</p><p>WeakHashMap对象的第四个key-value对的key是一个字符串直接量，系统会使用缓冲池保留对该字符串对象的强引用，所以垃圾回收时不会回收它。</p><h2 id="IdentityHashMap实现类"><a href="#IdentityHashMap实现类" class="headerlink" title="IdentityHashMap实现类"></a>IdentityHashMap实现类</h2><p>这个Map实现类的机制和HashMap基本相似，但它在处理两个key相等时比较独特，在IdentityHashMap中，仅当两个key严格相等(key1 == key2)时，IdentityHashMap才会认为他们相等。</p><p>对于普通的HashMap，只要key1和key2通过equals方法返回true并且hashcode值相等即可。</p><h2 id="EnumMap实现类"><a href="#EnumMap实现类" class="headerlink" title="EnumMap实现类"></a>EnumMap实现类</h2><p>EnumMap是一个和枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值，创建EnumMap时必须显式或者隐式的指定它对应的枚举类，EnumMap具有如下特征</p><ul><li>EnumMap在内部以数组形式保存，这种实现形式紧凑高效</li><li>EnumMap根据key的自然顺序(即枚举值在枚举类的定义顺序)来维护key-value对的顺序</li><li>EnumMap不允许以null作为key，但允许使用null作为value，</li></ul><h2 id="各Map实现类的性能分析"><a href="#各Map实现类的性能分析" class="headerlink" title="各Map实现类的性能分析"></a>各Map实现类的性能分析</h2><p>对于Map常用实现类来说，HashMap和Hashtable实现机制几乎一样，但是由于Hashtable是一个古老的线程安全的集合，所以HashMap比Hashtable要快</p><p>TreeMap通常比HashMap和Hashtable要慢，因为TreeMap使用红黑树来维护key-value对的顺序。</p><p>对于一般的应用场景，程序应该多考虑使用HashMap。</p><p>LinkedHashMap比HashMap慢一点，因为它需要链表来维护顺序。</p><p>IdentityHashMap性能没有出色之处，只是它使用==而不是equals方法来判断元素相等</p><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="HashSet和HashMap的性能选项"><a href="#HashSet和HashMap的性能选项" class="headerlink" title="HashSet和HashMap的性能选项"></a>HashSet和HashMap的性能选项</h2><p>HashSet和HashMap都采用hash算法来绝对元素存储位置。</p><p>hash表中可以存储元素的位置称为”桶”，通常情况下，单个”桶”存储一个元素，此时性能是最好的。但是hash表的状态是open的，在发生hash冲突的情况下，单个桶会存储多个元素，这些元素以链表形式存储，必须按顺序存储。</p><p>HashSet和HashMap的hash表有一些属性</p><ul><li>容量(capacity)：hash表中桶的数量</li><li>初始化容量(initial capacity)：创建hash表时桶的数量，HashSet和HashMap都允许在构造器中指定初始化容量</li><li>尺寸(size)：当前hash表中记录的数量</li><li>负载因子(load factor)：等于<strong>$\frac{size}{capacity}$,</strong>负载因子为0，表示空的hash表。</li></ul><p>除此之外，hash表还有一个负载极限，它是一个0~1之间的数，决定了hash表的最大填满程度，当hash表的负载因子达到最顶负载极限时，hash表会自动成倍的增加容量，并将原有对象重新分配，这称为rehashing。</p><p>HashSet和HashMap的构造器都允许指定一个负载极限。HashSet、HashMap和Hashtable的默认负载极限时0.75。</p><p>较高的负载极限可以降低hash表占用的内存，但会增加查询数据的时间开销；较低的负载极限会提高查询数据的性能，但会增加内存消耗。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>List集合</title>
    <link href="/2022/05/11/Java/%E9%9B%86%E5%90%88/List%E9%9B%86%E5%90%88/"/>
    <url>/2022/05/11/Java/%E9%9B%86%E5%90%88/List%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>List集合代表一个元素有序可以重复的集合，每个元素有对应的顺序索引，从0开始。</p><p>List接口作为Collection的子接口，可以使用Collection的所有方法，除此之外，List集合还增加一个根据索引操作集合元素的方法</p><ul><li><strong>void add(int index, Object element)</strong>：将元素插入到List集合的index处(index从0开始，例如插入第一个元素，index为0)</li><li><strong>boolean addAll(int index, Collection c)</strong>：将集合c包含的所有元素都插入到List集合的index处</li><li><strong>Object get(int index)</strong>：返回集合index处的元素</li><li><strong>int indexOf(Object o)</strong>：返回对象o在List集合第一次出现的位置索引</li><li><strong>int lastIndexOf(Object o)</strong>：返回对象o在List集合中最后一次出现的位置索引</li><li><strong>Object remove(int index)</strong>：删除并返回index索引处的元素</li><li><strong>Object set(int index, Object element)</strong>：将List集合index位置处的元素替换成element对象，返回被替换的旧元素</li><li><strong>List subList(int fromIndex, int toIndex)</strong>：返回从索引fromIndex(包括)到toIndex(不包括)处所有集合元素组成的子集合</li></ul><p>所有的List实现类都可以调用这些方法</p><p>Java 8为List接口增加了两个新的默认方法</p><ul><li><strong>void replaceAll(UnaryOperator operator)</strong>：根据operator指定的计算规则重新设置List集合中的所有元素</li><li><strong>void sort(Comparator c)</strong>：根据Comparator参数对List集合元素排序</li></ul><p><strong>注意：使用indexOf、lastIndexOf和remove方法时，需要在集合中匹配和给定参数相同的元素，List集合判断相等的方式是只要equals方法返回true即可</strong>。</p><p>sort方法需要一个Comparator对象来控制元素排序，可以用Lambda表达式；replaceAll方法需要一个UnaryOperator接口实现类，它也是一个函数式接口，可以使用Lambda表达式。</p><p>使用sort和replaceAll方法的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListTest3</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-type">var</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><span class="hljs-comment">// 向books集合中添加4个元素</span><br>books.add(<span class="hljs-string">&quot;轻量级Java EE企业应用实战&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂Java讲义&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂Android讲义&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂iOS讲义&quot;</span>);<br><span class="hljs-comment">// 使用目标类型为Comparator的Lambda表达式对List集合排序</span><br>        <span class="hljs-comment">//字符串越长，字符串越大</span><br>books.sort((o1, o2) -&gt; ((String) o1).length() - ((String) o2).length());<br>System.out.println(books);<br><span class="hljs-comment">// 使用目标类型为UnaryOperator的Lambda表达式来替换集合中所有元素</span><br><span class="hljs-comment">// 该Lambda表达式控制使用每个字符串的长度作为新的集合元素</span><br>books.replaceAll(ele -&gt; ((String) ele).length());<br>System.out.println(books); <span class="hljs-comment">// 输出[7, 8, 11, 16]</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>List集合额外提供了一个listIterator方法，该方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供专门操作List的方法，ListIterator还增加了一个方法</p><ul><li><strong>boolean hasPrevious()</strong>：返回该迭代器关联的集合是否还有上一个元素</li><li><strong>Object previous()</strong>：返回该迭代器的上一个元素</li><li><strong>void add(Object o)</strong>：在指定位置插入一个元素</li></ul><h2 id="ArrayList和Vector实现类"><a href="#ArrayList和Vector实现类" class="headerlink" title="ArrayList和Vector实现类"></a>ArrayList和Vector实现类</h2><p>ArrayList和Vector作为List接口的实现类，完全支持List接口所有的功能</p><p>ArrayList和Vector实现类都是基于数组实现的List类，ArrayList和Vector封装了一个动态的、允许再分配的Object[]数组，</p><p>ArrayList和Vector对象使用initialCapacity参数来设置该对象的长度，当向ArrayList或Vector-添加元素超过了数组长度后，它们的initialCapacity会自动增加。</p><p>通常来说，我们无需关注initialCapacity，但是如果向ArrayList或Vector集合添加大量元素时，可以使用ensureCapacity方法一次性增加initialCapacity，可以减少重分配的次数，提高性能。</p><p>如果开始就知道要存储多少元素，可以在创建时指定initialCapacity参数，<strong>如果不指定，默认长度为10。</strong></p><p>ArrayList和Vector提供了两个方法来重分配Object[]数组</p><ul><li><strong>void ensureCapacity(int minCapacity)</strong>：将Object[]数组的大小增加，以确保它至少可以容纳由minCapacity参数指定的元素数。</li><li><strong>void trimToSize()</strong>：调整Object[]数组长度为当前元素的个数</li></ul><p>ArrayList和Vector在用法上几乎完全相同，但是Vector是一个比较古老的集合，有一些很长的方法名，也有很多缺点，尽量少用Vector。</p><p>除此之外，ArrayList和Vector的一个显著区别是ArrayList是线程不安全的，程序必须手动保证该集合的同步性，Vector是线程安全的。</p><p>Coolections工具类可以使ArrayList变成线程安全的。</p><p>Vector还提供了一个子类Stack，它模拟“栈”这种数据结构，提供了几个方法</p><ul><li>Object peek():返回栈的第一个元素，但并不将该元素出栈</li><li>Object pop()：返回栈的第一个元素，并将该元素出栈</li><li>void push(Object item)：将元素入栈</li></ul><h2 id="固定长度的List"><a href="#固定长度的List" class="headerlink" title="　固定长度的List"></a>　固定长度的List</h2><p>操作数组的工具类Arrays，该工具类提供了asList(Object … a)方法，该方法可以把一个数组或指定个数的对象转换为一个List集合，<strong>但是这个集合List即不是ArrayList实现类的实例，也不是Vector实现类的实例，而是Arrays的内部类ArrayList的实例。</strong></p><p>Arrays.ArrayList是一个固定长度的List集合，程序只能遍历该集合的元素，不可以增加和删除</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作集合的工具类：Collections</title>
    <link href="/2022/05/11/Java/%E9%9B%86%E5%90%88/%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/"/>
    <url>/2022/05/11/Java/%E9%9B%86%E5%90%88/%E6%93%8D%E4%BD%9C%E9%9B%86%E5%90%88%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB%EF%BC%9ACollections/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java提供了操作Set、List和Map等集合的工具类Collections,提供了大量的方法对集合元素排序、查询修改等操作，还可以将集合元素设置为不可变，对集合对象实现同步控制。</p><h2 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h2><p>常用类方法来排序</p><ul><li><strong>void reverse(List list)</strong>：反转指定集合元素的顺序</li><li><strong>void shuffle(List list)</strong>：对集合的元素进行随机排序</li><li><strong>void sort(List list)</strong>：根据元素自然顺序对指定list集合的元素按升序排序</li><li><strong>void sort(List list, Comparator c)</strong>：根据指定Comparator产生的顺序对List集合元素进行排序</li><li><strong>void swap(List list, int i, int j)</strong>：将指定List集合中的i处元素按升序进行排序</li><li><strong>void rotate(List list, int distance)</strong>：当distance为正数时，将list集合的后distance个元素整体移到前面；distance为负数时，将list集合的前distance个元素整体移到后面，该方法不会改变集合长度</li></ul><h2 id="查找替换操作"><a href="#查找替换操作" class="headerlink" title="查找替换操作"></a>查找替换操作</h2><p>Collections提供的类方法用于查询替换集合元素</p><ul><li><strong>int binarySearch(List list, Object key)</strong>：使用二分搜索法搜索指定的List集合，以获得指定对象在List集合中的索引，如果要使用此方法，则List集合元素必须已经处于有序状态</li><li><strong>Object max(Collection coll)</strong>：根据元素的自然顺序，返回给定集合的最大元素</li><li><strong>Object max(Collection coll, Comparator comp)</strong>：根据Comparator给定的顺序，返回给定集合中最大元素</li><li><strong>Object min(Collection coll)</strong>：根据元素的自然顺序，返回给定集合的最小元素</li><li><strong>Object min(Collection coll, Comparator comp)</strong>：根据Comparator给定的顺序，返回给定集合中最小元素</li><li><strong>void fill(List list, Object obj)</strong>：使用指定元素替换指定集合中所有元素</li><li><strong>int frequency(Collection c, Object o)</strong>：返回指定集合中指定元素出现的次数</li><li><strong>int indexOfSubList(List source, List target)</strong>：返回子List对象target在父List对象source第一次出现的位置索引</li><li><strong>int lastIndexOfSubList(List source, List target)</strong>：返回子List对象target在父List对象source最后一次出现的位置索引</li><li><strong>boolean replaceAll(List list, Object oldVal, Object newVal)</strong>：使用一个新值替换List对象的所有旧值</li></ul><h2 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h2><p>Collections提供了多个synchronizedXxx()方法，可以把指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p><p>Java常用的集合框架的实现类HashSet,TreeSet, ArrayList, ArrayDeque, LinkedList, HashMap和TreeMap都是线程不安全的。</p><p>可以使用<code>ArrayList a = Collections.synchronizedList(new ArrayList());</code>将新创建的集合对象传给Collections的synchronizedXxx方法，获取对应的线程安全版本。</p><h2 id="Java-9新增的不可变集合"><a href="#Java-9新增的不可变集合" class="headerlink" title="Java 9新增的不可变集合"></a>Java 9新增的不可变集合</h2><p>以前假如要创建一个包含6个元素的Set集合，程序需要先创建Set集合，然后调用6次add()方法，Java 9进行简化，程序直接调用Set、List、Map的of()方法即可创建一个包含N个元素的不可变集合。</p><p>不可变集合意味着不能向集合中添加元素也不能从集合中删除元素。</p><p>例子：创建一个Set、List的不可变集合</p><p><code>var a = Set.of(&quot;java&quot;, &quot;C&quot;, &quot;C++&quot;);</code>  <code>var b = List.of(&quot;13, 56, 62&quot;);</code></p><p>上述代码分别创建了三个元素的Set集合和List集合。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合概述及其遍历接口</title>
    <link href="/2022/05/11/Java/%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/05/11/Java/%E9%9B%86%E5%90%88/Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>集合主要负责保存其他数据，集合和数组不一样，数组元素可以是基本类型如int，float，但集合里只能保存对象(实际保存的是对象的引用变量)。</p><p>Java集合类由两个接口派生而出：Collection和Map，这两个接口又包含了一些子接口和实现类。</p><p>继承树</p><p><img src="https://crayon-1302863897.cos.ap-beijing.myqcloud.com/image/集合接口.png" alt="集合接口" style="zoom:100%;" /></p><p>大致分为四种集合：Set、List、Queue和Map</p><p>特点</p><ul><li>Set是无序集合，元素不能重复</li><li>List是有序集合，每个元素有对应索引，元素可以重复</li><li>Map保存的数据都是key-value对，即每项数据由两个值组成</li></ul><h2 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h2><p>Collection接口是List、Set和Queue接口的父接口，它包含了几个操作集合元素的方法。</p><ul><li><strong>boolean add(Object o) </strong>：向集合添加一个元素，添加成功返回true</li><li><strong>boolean addAll(Collection c)</strong>：把集合c的所有元素添加到指定集合中，如果添加成功返回true</li><li><strong>void clear()</strong>：清除集合所有元素</li><li><strong>boolean contains(Object o)</strong>：判断集合是否包含指定元素，包含返回true</li><li><strong>boolean containsAll(Collection c)</strong>：判断集合是否包含c中所有元素，是返回true</li><li><strong>boolean isEmpty()</strong>：判断集合是否为空，是返回true</li><li><strong>Iterator iterator()</strong>：返回一个Iterator对象，用于遍历集合元素</li><li><strong>boolean remove(Object o)</strong>：从集合中删除指定元素o，如果集合包含多个元素o时，只删除第一个符合条件的元素</li><li><strong>boolean removeAll(Collection c)</strong>：从集合删除集合c中不包含的元素(相等于该集合和c集合求交集)</li><li><strong>int size()</strong>：返回集合里元素个数</li><li><strong>Object[] toArray()</strong>：该方法把集合转换成一个数组，所有集合元素变成对应数组元素</li></ul><h2 id="使用Iterator遍历集合元素"><a href="#使用Iterator遍历集合元素" class="headerlink" title="使用Iterator遍历集合元素"></a>使用Iterator遍历集合元素</h2><p>Iterator接口是Collection的父接口，Iterator接口主要用来遍历Collection集合中的元素，Iterator对象也被称为迭代器。有四个方法</p><ul><li><strong>boolean hasNext()</strong>：如果被迭代的集合元素还没有被遍历完，返回true</li><li><strong>Object next()</strong>：返回集合下一个元素</li><li><strong>void remove()</strong>：删除集合中上一次next方法返回的元素</li><li><strong>void forEachRemaining(Consumer action)</strong>：使用Lambda表达式遍历集合元素</li></ul><p>Iterator仅仅用于遍历集合，如果需要创建Iterator对象，则必须有一个需要被迭代的集合。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-comment">// 创建集合、添加元素的代码与前一个程序相同</span><br><span class="hljs-type">var</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>books.add(<span class="hljs-string">&quot;轻量级Java EE企业应用实战&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂Java讲义&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂Android讲义&quot;</span>);<br><span class="hljs-comment">// 获取books集合对应的迭代器</span><br><span class="hljs-type">var</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> books.iterator();<br><span class="hljs-keyword">while</span> (it.hasNext())<br>&#123;<br><span class="hljs-comment">// it.next()方法返回的数据类型是Object类型，因此需要强制类型转换</span><br><span class="hljs-type">var</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (String) it.next();<br>System.out.println(book);<br><span class="hljs-keyword">if</span> (book.equals(<span class="hljs-string">&quot;疯狂Java讲义&quot;</span>))<br>&#123;<br><span class="hljs-comment">// 从集合中删除上一次next方法返回的元素</span><br>it.remove();<br>&#125;<br><span class="hljs-comment">// 对book变量赋值，不会改变集合元素本身</span><br>book = <span class="hljs-string">&quot;测试字符串&quot;</span>;   <span class="hljs-comment">// ①</span><br>&#125;<br>System.out.println(books);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当使用Iterator遍历集合时，Iterator并不是把集合元素本身传给迭代变量，而是把对应的值传给迭代变量，所以修改迭代变量的值对集合本身没有影响。</p><p>虽然remove方法可以删除集合元素，但尽量不要使用remove来删除集合元素。</p><h3 id="使用Iterator接口的新增方法来遍历集合"><a href="#使用Iterator接口的新增方法来遍历集合" class="headerlink" title="使用Iterator接口的新增方法来遍历集合"></a>使用Iterator接口的新增方法来遍历集合</h3><p>Iterator接口有一个默认方法forEach(Consumer action)，该方法参数是一个函数式接口，可以使用Lambda来遍历，因为Iterator接口是Collection的父接口，所有Collection可以直接调用该方法。</p><p>当调用该方法时，程序会依次将集合元素传给Consumer的accept(T t)方法。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                <span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>                c.add(<span class="hljs-string">&quot;你好&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;同学&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;再见&quot;</span>);<br>                <br>                c.forEach(obj-&gt;&#123;System.out.println(obj);&#125;);<br><br>                <br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Iterator接口同样有一个forEachRemaining(Consumer action)，该方法所需参数是函数式接口，当程序调用Iterator的该方法时，程序会把集合元素传给Consumer的accpet(T t)方法</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                <span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>                c.add(<span class="hljs-string">&quot;你好&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;同学&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;再见&quot;</span>);<br><br>                <span class="hljs-type">Iterator</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> c.iterator();<br><br>                a.forEachRemaining(obj-&gt;&#123;System.out.println(obj);&#125;);<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用foreach循环来遍历集合元素"><a href="#使用foreach循环来遍历集合元素" class="headerlink" title="使用foreach循环来遍历集合元素"></a>使用foreach循环来遍历集合元素</h2><p>可以直接使用for each循环来遍历集合，更加方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                <span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>                c.add(<span class="hljs-string">&quot;你好&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;同学&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;再见&quot;</span>);<br><br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> obj : c)<br>                &#123;<br>                        System.out.println(obj);<br>                &#125;<br><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用foreach循环遍历集合时也不能修改集合元素</p><h2 id="使用Predicate操作集合"><a href="#使用Predicate操作集合" class="headerlink" title="使用Predicate操作集合"></a>使用Predicate操作集合</h2><p>Collection集合有一个removeIf(Predicate filter)方法，该方法会批量删除符合filter条件的所有元素</p><p>该方法需要一个Predicate对象来作为参数，Predicate是函数式接口，可以用Lambda表达式</p><p>该接口中的唯一抽象方法test，如果符合filter条件，该方法返回true，否则false</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                <span class="hljs-type">var</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>                c.add(<span class="hljs-string">&quot;你好&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;同学&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;再见&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;9dorgja[we0uf&quot;</span>);<br>                c.add(<span class="hljs-string">&quot;sidufhsd&quot;</span>);<br><br>                c.removeIf(e-&gt;&#123;<span class="hljs-keyword">return</span> ((String)e).length() &gt; <span class="hljs-number">10</span>;&#125;);<br><br>                System.out.println(c);<br>                <br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码会把c集合里长度大于10的字符串删掉。</p><p>其中  <code>c.removeIf(e-&gt;&#123;return ((String)e).length() &gt; 10;&#125;)</code>的参数e可以用任意名称代替</p><h2 id="使用Stream操作集合"><a href="#使用Stream操作集合" class="headerlink" title="　使用Stream操作集合"></a>　使用Stream操作集合</h2><p>Stream是一个通用流接口，IntStream,LongStream,DoubleStream则代表元素类型为int、long、double的流。</p><p>Java为每个流提供对应的Builder，例如Stream.Builder等等，可以用这些Builder创建对应的流</p><p>独立使用Stream步骤为</p><ol><li>使用Stream或XxxStream的builder类方法创建对应Builder</li><li>重复调用Builder的add方法向该流添加元素</li><li>调用Builder的build方法获取对应Stream</li><li>调用Stream的聚集方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span>  <span class="hljs-title class_">Main</span>  &#123;<br><br>        <span class="hljs-keyword">public</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span>  <span class="hljs-title function_">main</span><span class="hljs-params">(String[]  args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>                IntStream.<span class="hljs-type">Builder</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> IntStream.builder();<br><br>                a.add(<span class="hljs-number">4</span>);<br>                a.add(<span class="hljs-number">85</span>);<br>                a.add(<span class="hljs-number">14</span>);<br>                a.add(-<span class="hljs-number">15</span>);<br>                a.add(-<span class="hljs-number">45</span>);<br>                a.add(<span class="hljs-number">26</span>);<br><br>                <span class="hljs-type">IntStream</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.build();<br><br>                <span class="hljs-comment">// 下面调用聚集方法的代码每次只能执行一个</span><br><br>System.out.println(<span class="hljs-string">&quot;is所有元素的最大值：&quot;</span> + b.max().getAsInt());<br><span class="hljs-comment">//System.out.println(&quot;is所有元素的最小值：&quot; + b.min().getAsInt());</span><br><span class="hljs-comment">//System.out.println(&quot;is所有元素的总和：&quot; + b.sum());</span><br><span class="hljs-comment">//System.out.println(&quot;is所有元素的总数：&quot; + b.count());</span><br><span class="hljs-comment">//System.out.println(&quot;is所有元素的平均值：&quot; + b.average());</span><br><br>System.out.println(<span class="hljs-string">&quot;is所有元素的平方是否都大于20:&quot;</span><br>+ b.allMatch(ele -&gt; ele * ele &gt; <span class="hljs-number">20</span>));<br><br>System.out.println(<span class="hljs-string">&quot;is是否包含任何元素的平方大于20:&quot;</span><br>+ b.anyMatch(ele -&gt; ele * ele &gt; <span class="hljs-number">20</span>));<br><br>                <span class="hljs-comment">// 将is映射成一个新Stream，新Stream的每个元素是原Stream元素的2倍+1</span><br><br>                <span class="hljs-type">var</span> <span class="hljs-variable">newIs</span> <span class="hljs-operator">=</span> b.map(ele -&gt; ele * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>);<br><br>                <span class="hljs-comment">// 使用方法引用的方式来遍历集合元素</span><br>                newIs.forEach(System.out::println); <span class="hljs-comment">// 输出41 27 -3 37</span><br>                <br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面聚集方法只能执行一行，需要把其他聚集操作注释掉。</p><p>Stream提供了很多方法来进行操作，分为“中间方法”和“末端方法”</p><ul><li>中间方法：中间操作允许流保持打开状态，并允许直接调用后续的方法，中间方法的返回值是另外一个流</li><li>末端方法：末端方法是对流的最终操作，<strong>当对某个Stream执行末端方法后，该流会被“消耗”且不能再使用</strong></li></ul><p>除此之外关于流的方法有两个特征</p><ul><li>有状态的方法：这种方法会给流增加一些新的属性，比如元素唯一性、元素的最大数量等等，有状态的方法往往需要更大的性能开销</li><li>短路方法：短路方法可以尽早结束对流的操作，不必检查所有元素</li></ul><p>Stream常用中间方法(全部返回一个新的流)</p><ul><li><strong>filter(Predicate predicate)</strong>：过滤所有不符合predicate的元素</li><li><strong>mapToXxx(ToXxxFunction mapper)</strong>：使用ToXxxFunction对流元素执行一对一转换，返回的新流包含转换生成的所有元素</li><li><strong>peek(Consumer action)</strong>：依次对每个元素执行一些操作，返回的流与原有流包含元素相同，主要用于调试</li><li><strong>distinct()</strong>：用于排序流中所有重复的流</li><li><strong>sorted()</strong>：用于保证流中所有元素在后序访问中处于有序状态</li></ul><p>Stream常用末端方法</p><ul><li><strong>forEach(Consumer action)</strong>：遍历流中所有元素，对每个元素执行action</li><li><strong>toArray()</strong>：将流中所有元素转换为一个数组</li><li><strong>reduce()</strong>：有三个重载版本，都是通过某种操作合并流中元素</li><li><strong>min()</strong>：返回流中最小值</li><li><strong>max()</strong>：返回流中最大值</li><li><strong>count()</strong>：返回所有元素数量</li><li><strong>anyMatch(Predicate predicate)</strong>：判断流中是否至少有一个元素符合Predicate条件</li><li><strong>allMatch(Predicate predicate)</strong>：判断流中是否所有元素符合Predicate条件</li><li><strong>noneMatch(Predicate predicate)</strong>：判断流中是否所有元素都不符合Predicate条件</li><li><strong>fndFirst()</strong>：返回流中第一个元素</li><li><strong>findAny</strong>：返回流中任意一个元素</li></ul><p>Java允许使用这些流来操作集合，Collection提供了一个stream默认方法，该方法返回该集合对应流，然后可以使用流的方法来操作集合元素</p><p>例子：对集合元素进行批量操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectionStream</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-comment">// 创建books集合、为books集合添加元素的代码与8.2.5小节的程序相同。</span><br><span class="hljs-type">var</span> <span class="hljs-variable">books</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>        <br>books.add(<span class="hljs-string">&quot;轻量级Java EE企业应用实战&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂Java讲义&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂iOS讲义&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂Ajax讲义&quot;</span>);<br>books.add(<span class="hljs-string">&quot;疯狂Android讲义&quot;</span>);<br>        <br><span class="hljs-comment">// 统计书名包含“疯狂”子串的图书数量</span><br>        <br>System.out.println(books.stream()<br>.filter(ele-&gt;((String) ele).contains(<span class="hljs-string">&quot;疯狂&quot;</span>))<br>.count()); <span class="hljs-comment">// 输出4</span><br>        <br><span class="hljs-comment">// 统计书名包含“Java”子串的图书数量</span><br>System.out.println(books.stream()<br>.filter(ele-&gt;((String) ele).contains(<span class="hljs-string">&quot;Java&quot;</span>) )<br>.count()); <span class="hljs-comment">// 输出2</span><br>        <br><span class="hljs-comment">// 统计书名字符串长度大于10的图书数量</span><br>System.out.println(books.stream()<br>.filter(ele-&gt;((String) ele).length() &gt; <span class="hljs-number">10</span>)<br>.count()); <span class="hljs-comment">// 输出2</span><br>        <br><span class="hljs-comment">// 先调用Collection对象的stream()方法将集合转换为Stream,</span><br><span class="hljs-comment">// 再调用Stream的mapToInt()方法获取原有的Stream对应的IntStream</span><br>books.stream().mapToInt(ele -&gt; ((String) ele).length())<br><span class="hljs-comment">// 调用forEach()方法遍历IntStream中每个元素</span><br>.forEach(System.out::println);<span class="hljs-comment">// 输出8 11 16 7 8</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象(下)</title>
    <link href="/2022/05/11/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/"/>
    <url>/2022/05/11/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8B)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="包装类"><a href="#包装类" class="headerlink" title="　包装类"></a>　包装类</h2><p>基本数据类型的数据不具备“对象”的特性，例如所有引用变量类型都继承了Object类，但基本数据类型却没有。</p><p>因此为了解决基本数据类型的变量不能当做Object类型变量使用的问题，Java提供了包装类</p><p>byte—-&gt;Byte, short—-&gt;Short, int—-&gt;Integer, long—-&gt;Long, char—-&gt;Character, float—-&gt;Float, double—-&gt;Double, </p><p>boolean—-&gt;Boolean</p><p>Java还提供了自动装箱和自动拆箱，自动装箱是把基本类型变量直接赋给对应包装类变量，不需要强制转换。</p><p>拆箱就是反过来。</p><p>除此之外，包装类提供了基本类型变量和字符串之间的转换，把字符串值转换成基本类型的值有两种方式</p><ul><li>利用包装类提供的<strong>parseXxx(String s)</strong>静态方法</li><li>利用包装类提供的<strong>valueOf(String s)</strong>静态方法</li></ul><p>String类也提供了多个重载valueOf()方法，把基本类型变量转换成字符串。</p><p><strong>提示：如果把基本类型变量转换成字符串，有一种更简单方法，就是将基本类型变量与””相连接</strong></p><p><strong>注意：包装类的实现，例如Integer包装类，系统会创建一个cache的数组，把-128~127的整数放在数组中，缓存起来，当把一个在这个范围内的数自动装箱成一个实例时，实际指向的是数组对应的元素。</strong></p><h2 id="处理对象"><a href="#处理对象" class="headerlink" title="处理对象"></a>处理对象</h2><p>Java对象都是Object类的实例，都可以直接调用该类的方法。</p><p>toString()是Object类的一个实例方法，它总是返回”类名@hashcode“值，当使用System.out.println(p)打印p对象时，打印的实际上是p对象toString的返回值。</p><p>这个返回值不能满足输出对象内容的功能，因此用户需要自定义类能实现这个功能，就要重写这个方法。</p><hr><p>Java测试变量相等有两种方法，一个是用==运算符，一个是用equals方法。</p><p>当时用==来判断两个变量是否相等时，如果都是基本类型变量且都是数值类型，则只要两个变量值相等，返回true</p><p>但是如果是两个引用类型变量，则只有他们指向同一个对象时，即他们存放的地址值相等时，才会返回true。</p><p>使用equals判断，与使用==判断没有区别，仍然要求引用变量指向同一个对象才回返回true，因此如果要采用自定义的相等标准，需要重写equals方法。</p><p><strong>注意：String类已经重写了euqals方法，可以直接判断两个字符串包含的字符序列是否相等。</strong></p><p>重写equals方法需要满足几个条件</p><ul><li>自反性：对任意x，x.equals(x)一定返回true</li><li>对称性：对任意x和y，如果x.equals(y)返回true，则y.equals(x)也必须返回true</li><li>传递性：对任意x,y,z，如果x.equals(y)返回true，y.equals(z)返回true，则x.equals(z)也必须返回true</li><li>一致性：对任意x和y，如果对象中判断相等的信息没有改变，则无论调用多少次equals方法，返回的结果应该保持一致</li><li>对任意不是null的x，x.equals(null)一定返回false</li></ul><h3 id="关于常量池"><a href="#关于常量池" class="headerlink" title="关于常量池"></a>关于常量池</h3><p>JVM有一个常量池来管理在编译时被确定并被保存在已编译的.class文件中，它包括了类、方法、接口中的常量和字符串常量。</p><p>常量池分为两种：静态常量池和运行时常量池</p><p>静态常量池就是上述所说的，被保存在了class文件，当运行时，class文件被加载到内存中，就是运行时常量池。</p><p>当时用<code>String p1 = &quot;hello&quot;</code>和使用<code>String p2 = new String(&quot;hello&quot;)</code>时，前者会将字符串”hello”放在常量池中，让p1去引用，后者会先使用常量池管理”hello”直接量，然后调用String构造器创建一个新的String对象，它被保存在堆内存中。</p><p>需要注意的是，如果在上面两句代码后再加<code>String p3 = &quot;he&quot; + &quot;llo&quot;</code>，则<code>p3 == p1</code>返回true,因为系统在编译期间执行了+号，将字符串拼接起来，并自动进行优化，所以还是引用常量池的字符串。</p><p>上面所说的包装类的实现也是一种常量池应用</p><hr><h2 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h2><p>用static修饰的成员就是类成员，类变量属于整个类，当系统第一次准备使用该类时，系统会为该类变量分配内存，类变量生效，直到该类被卸载。</p><p>类变量可以通过类来访问，也可以通过类的对象来访问。但是当类的对象访问类变量时，<strong>其实系统会在底层转换成该类来访问类变量。当创建类的对象时，系统也不会再为类变量分配内存。</strong>即对象根本不拥有对应类的类变量。</p><p>当一个类的对象为null时，如<code>Person p;</code>创建了一个Person类对应的对象，但是p还没有指向任何内存，即p = null，<strong>p依然可以直接访问类的类成员。</strong></p><h2 id="final修饰符"><a href="#final修饰符" class="headerlink" title="final修饰符"></a>final修饰符</h2><p>final用于修饰类、变量和方法。表明是不可变的。</p><p>final修饰变量时，表示该变量一旦获得初始值就不能再改变了，final可以修饰成员变量，也可以修饰局部变量和形参。</p><ul><li>当final修饰成员变量时，虽然系统会默认初始化，但必须由程序员另外显式指定初始值</li><li>final修饰局部变量时，系统不会默认初始化，也必须要显式指定初始值</li></ul><p><strong>final修饰引用类型变量时，引用类型变量本身不能改变，即它必须一直引用这个对象，但它所引用的对象是可以改变的。</strong></p><hr><p>对一个final变量来说，不管是类变量、成员变量还是局部变量，只要满足三个条件，这个final变量就不是一个变量，而是一个直接量或者常量。</p><ul><li>使用final修饰</li><li>在定义该final变量时指定了初始值</li><li>该初始值可以在编译时被确定下来</li></ul><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        System.put.println(a);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个程序来说，a变量不存在，当执行System.put.println(a)时，实际转换为执行System.put.println(5)。</p><p>即变成了一个宏变量。编译器会把所有用到该变量的地方都替换成对应的值。</p><hr><p><strong>final方法</strong></p><p>final修饰的方法不可以被重写，但可以被重载。</p><hr><p><strong>final类</strong></p><p>final修饰的类不能有子类，</p><hr><p><strong>不可变类</strong></p><p>不可变类是指创建该类的实例后，该实例的实例变量是不可改变的。</p><p>如果要创建自定义的不可变类，要遵守几条规则</p><ul><li>使用private和final修饰符来修饰该类的成员变量</li><li>提供带参数的构造器，用于根据传入参数来初始化类的成员变量</li><li>仅为该类提供getter方法，不要为该类成员变量提供setter方法</li><li>如果有必要，重写equals和hashcode方法</li></ul><p><strong>注意：如果定义一个不可变类，但这个不可变类有引用类型变量，final修饰引用类型变量，则变量引用的对象不能改变，但对象本身可以改变，因此一定要采用必要措施来保护引用类型对象不会被改变，这样才能创建真正的不可变类。</strong></p><hr><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象方法和抽象类使用abstract修饰符来修饰，有抽象方法的类只能被定义成抽象类，抽象类里可以没有抽象方法。</p><p>抽象类只能用public修饰符或者省略修饰符来修饰</p><p>几条规则</p><ul><li>抽象类和抽象方法必须使用abstract修饰，抽象方法不能有方法体</li><li>抽象类不能被实例化，也无法使用new关键字来调用抽象类的构造器，即使抽象类不包含抽象方法</li><li>抽象类里可以包含成员变量，方法(普通方法和抽象方法)，构造器，初始化块，内部类(接口和枚举)五种成分，抽象类的构造器不能用于创建实例，主要用于被子类调用</li><li>含有抽象方法的类(<strong>包括直接定义了一个抽象方法，或继承了一个抽象父类，但没有完全实现父类包含的抽象方法；或者实现了一个接口，但没有完全实现接口包含的抽象方法三种情况</strong>)只能被定义为抽象类</li></ul><p>抽象类不能用于创建实例，只能当做父类被子类继承。</p><p><strong>注意：如果抽象类里有抽象方法和普通方法，则它的子类必须实现抽象方法，普通方法可实现可不实现。</strong></p><p><strong>注意：abstract和static不能同时使用，但不是绝对的，它俩可以同时用来修饰内部类；abstract和final也不能同时使用；private和abstract也不能同时使用，因为abstract修饰的方法必须被子类重写才有意义。</strong></p><hr><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>将抽象类进行的更彻底，可以提炼出一种更加特殊的“抽象类”——接口，接口可以定义默认方法、类方法和私有方法，都可以提供方法实现。</p><p>接口可以继承多个接口，但是不能继承类。</p><p>接口只能用public或者省略访问控制符来修饰。</p><p>接口不能包含构造器和初始化块定义，可以包含成员变量(<strong>只能是静态变量</strong>)、方法(<strong>只能是抽象实例方法、默认方法、类方法和私有方法</strong>)、内部类(内部接口、枚举)。</p><hr><div class="table-container"><table><thead><tr><th></th><th>有无方法体</th><th>是否需要被实现类重写</th><th>默认修饰符</th></tr></thead><tbody><tr><td>普通方法(抽象实例方法)</td><td>无</td><td>必须被实现类重写</td><td>public abstract</td></tr><tr><td>默认方法(带方法体实例方法)</td><td>有</td><td>可以被实现类重写</td><td>public default</td></tr><tr><td>类方法</td><td>有</td><td>不可以</td><td>public static</td></tr><tr><td>私有方法</td><td>有</td><td>不可以</td><td>private</td></tr></tbody></table></div><p><strong>注意</strong></p><ul><li>系统会自自动为普通方法加上abstract修饰符</li><li>默认方法必须使用的default修饰，不能使用static修饰</li><li>私有方法主要作为工具方法，不能使用default修饰，可以是类方法或者实例方法</li></ul><hr><p>接口中定义的静态变量，不管是否使用public static final修饰符，系统都会为变量自动加上。<br>        <strong>且可以在接口修饰的访问范围内，使用静态变量，直接用“接口名.变量名”来进行调用。</strong></p><p>接口中定义的内部类。内部接口和内部枚举都会自动采用public static 修饰符。</p><hr><p>一个接口如果继承了另一个接口，将会获得该接口的所有抽象方法和静态变量。</p><p>一个类如果实现了一个接口，必须实现该接口所有抽象方法，可以实现该接口默认方法，同时获得该接口的静态变量。</p><hr><h3 id="使用接口"><a href="#使用接口" class="headerlink" title="使用接口"></a>使用接口</h3><p>接口不能用于创建实例，但可以声明引用类型变量，并且变量所引用的对象对应的类实现了该接口。</p><p>接口主要的用途就是被实现类实现。归纳来说，接口的用途有：</p><ul><li>定义变量，也可以用于强制类型转换</li><li>调用接口中定义的常量</li><li>被其他类实现</li></ul><p>一个类可以实现多个接口，使用implements关键字，一旦实现接口，可以获得该接口的静态变量，普通方法和默认方法。</p><p>而且因为子类重写父类方法时，访问权限只能更大或者相等，<strong>所以实现类实现接口的方法只能使用public修饰。</strong></p><hr><h2 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h2><p>接口和抽象类的相同点</p><ul><li>都不可以被实例化</li><li>都位于继承树顶端，用于被其他类实现或继承</li><li>都可以包含抽象方法，实现接口或继承抽象类的类都必须实现这些抽象方法</li></ul><p>接口和抽象类的不同点</p><ol><li><ul><li>接口体现的是一种规范，对于接口实现者来说，接口规定了实现者必须向外提供什么服务，对于接口调用者来说接口规定调用者可以使用哪些服务，某种程度上来说，接口类似整个系统的“总纲”，接口不应该经常被改变<ul><li>抽象类则体现了一种模块化设计，抽象类作为多个子类的抽象父类，可以当成系统实现的中间产品，这个中间产品已经实现了部分功能，但不能被当成最终产品，必须有进一步完善</li></ul></li></ul></li><li><ul><li>接口只能包含抽象方法、类方法、默认方法和私有方法，不能为普通的方法提供实现<ul><li>抽象类可以包含普通方法</li></ul></li></ul></li><li><ul><li>接口只能定义静态常量，不能定义普通成员变量<ul><li>抽象类既可以定义普通成员变量，也可以定义静态常量</li></ul></li></ul></li><li><ul><li>接口中不包含初始化块和构造器<ul><li>抽象类可以包含初始化块和构造器，构造器不是为了创建对象，而是让子类调用</li></ul></li></ul></li><li><ul><li>一个类可以实现多个接口<ul><li>一个类最多只有一个直接父类，包括抽象类</li></ul></li></ul></li></ol><hr><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>定义在其他类内部的类就是内部类，包含内部类的类是外部类。</p><p>内部类有几个作用</p><ul><li>内部类提供更好的封装，把内部类隐藏在外部类之内，同一个包的其他类无法访问</li><li>内部类成员可以访问外部类的私有数据，因为内部类被当成外部类成员，同一个类的成员之间可以相互访问</li><li>匿名内部类适用于创建只需要使用一次的类</li></ul><p>同时，内部类可以比外部类多使用三个修饰符：private、protected、static，外部类不能使用这三个修饰符。</p><p>内部类主要分四类</p><ul><li>成员内部类：即在类里定义的，没有用static修饰的类</li><li>静态内部类：在类里定义的，但使用static修饰的类</li><li>局部内部类：定义在一个方法或者一个作用域里面的类</li><li>匿名内部类：通过已有的接口或者类来创建，没有名字</li></ul><hr><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是最普通的内部类，被定义在外部类的内部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br>     <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span> &#123;     <span class="hljs-comment">//内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSahpe</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;drawshape&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例如Draw就是一个成员内部类</p><p>特点：</p><ul><li><strong>成员内部类可以无条件访问外部类的所有成员变量和方法</strong></li><li><strong>成员内部类是依附于外部类的，因此如果要创建一个成员内部类对象，首先要创建一个外部类对象</strong></li><li><strong>成员内部类不能定义静态变量或者方法</strong></li></ul><p><strong>注意：</strong></p><ul><li><strong>外部类不能直接访问成员内部类的成员变量和方法，必须要创建一个内部类对象，通过这个对象才能进行访问。</strong></li><li><strong>如果成员内部类里定义了和外部类重名的变量，会发生隐藏现象，即默认访问的是成员内部类定义的变量，如果要访问外部类的同名成员，需要用“外部类名.this.成员变量/方法”来使用</strong></li></ul><hr><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>     <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br>     <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span> &#123;     <span class="hljs-comment">//静态内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSahpe</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;drawshape&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用static修饰的成员内部类就是静态内部类，可以把外部类当成静态内部类的包</p><p>特点</p><ul><li><strong>静态内部类不需要依附于外部类的对象，可以直接用“外部类名.内部类名”的方式来创建静态内部类</strong></li><li><strong>静态内部类可以包含静态成员和非静态成员</strong></li><li><strong>静态内部类只能访问外部类的静态成员，不能访问非静态成员</strong></li></ul><p>除此之外，接口里也可以定义内部类，默认使用public static修饰符，也就是说，接口内部类只能是静态内部类</p><hr><h2 id="关于成员内部类和静态内部类访问问题"><a href="#关于成员内部类和静态内部类访问问题" class="headerlink" title="关于成员内部类和静态内部类访问问题"></a>关于成员内部类和静态内部类访问问题</h2><p>成员内部类可以访问外部类的静态成员和非静态成员，也可以访问它的外部类定义的其他静态内部类里的静态成员</p><p>外部类不能直接访问成员内部类的成员，只能通过创建成员内部类的对象来访问。</p><p>静态内部类只能访问外部类的静态成员，不能访问外部类的非静态成员</p><p>外部类可以访问静态内部类的静态成员，不能访问静态内部类的非静态成员</p><p><strong>简单的来说，非静态的“东西”可以访问静态的和非静态的，但是静态的“东西”只能访问静态的</strong></p><hr><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类非常简单，把一个类放在方法中或者一个作用域中定义，它就是局部内部类，在这个方法或者作用域之外，这个类不存在，也不能被访问，因此局部内部类不能使用访问控制符或者static修饰符修饰</p><p>实际开发很少使用局部内部类，因为它的作用域太小</p><hr><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="　匿名内部类"></a>　匿名内部类</h2><p>匿名内部类适合只需要使用一次的类，创建匿名内部类时会立即创建一个该类的实例，匿名内部类不能重复使用</p><p>定义匿名内部类的格式为</p><p><code>new 实现接口() | 父类构造器(实参列表) &#123;匿名内部类的类体部分&#125;</code></p><p>可以看出，匿名内部类必须继承一个父类或实现一个接口，但最多只能继承一个父类，或实现一个接口</p><p>还有两条规则</p><ul><li>匿名内部类不能是抽象类，因为系统创建匿名类时，会立即创建匿名内部类的对象</li><li>匿名内部类不能定义构造器，因为匿名内部类没有类名，但可以有初始化块</li></ul><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Product</span>&#123;<br><span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span>;<br>String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(Product p)</span>&#123;<br>        System.out.println(p.getName + p.getPrice());<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-type">Main</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>        a.test(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Product</span>()&#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPrice</span><span class="hljs-params">()</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">567.8</span>;<br>            &#125;<br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;AGP&quot;</span>;<br>            &#125;<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>即在Main里定义了test方法，需要Product参数，但Product无法直接创建实例，需要考虑传入Product接口实现类的对象，则可创建一个匿名内部类。</p><p>匿名内部类必须实现它的抽象父类或者接口包含的所有抽象方法。</p><p>被匿名内部类访问的局部变量必须使用final修饰。</p><hr><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式就是用来创建只有一个抽象方法的接口的实例。</p><p>只有一个抽象方法的接口叫做函数式接口，但可以包含多个默认方法和类方法。</p><p>Lambda表达式的主要作用就是就是代替匿名内部类的繁琐语法，它由三部分组成</p><ul><li>形参列表：<strong>如果形参列表只有一个参数，甚至连形参列表的圆括号也可以省略</strong></li><li>箭头：-&gt;</li><li>代码块：如果代码块只包含一条语句，可以省略代码块的花括号</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ProcessArray</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessArray</span>();<br>pa.process(array, (<span class="hljs-type">int</span> elemenmt)-&gt;&#123;<br>    System.out.println(<span class="hljs-string">&quot;数组元素的平方是:&quot;</span> + element * element);<br>&#125;);<br></code></pre></td></tr></table></figure><p>上述代码中，pa的第二个参数是一个函数式接口的实现类，就可以使用Lambda表达式直接创建一个实现类。</p><p>Lambda表达式有两个限制</p><ul><li>Lambda表达式的目标类型只能是明确的的函数式接口</li><li>Lambda表达式只能为函数式接口创建对象，Lambda表达式只能实现一个方法</li></ul><h3 id="方法引用和构造器引用"><a href="#方法引用和构造器引用" class="headerlink" title="方法引用和构造器引用"></a>方法引用和构造器引用</h3><p>如果Lambda表达式的代码块只有一条代码，程序可以省略Lambda表达式的花括号，不仅如此，如果Lambda表达代码块只有一条代码，还可以在代码块中使用方法引用和构造器引用</p><div class="table-container"><table><thead><tr><th>种类</th><th>示例</th><th>说明</th><th>对应的表达式</th></tr></thead><tbody><tr><td>引用类方法</td><td>类名::类方法</td><td>函数式接口被实现方法<br />全部参数传给该类方法</td><td>(a, b..)-&gt;类名::类方法(a, b, …)</td></tr><tr><td>引用特定对象实例方法</td><td>特定对象::实例方法</td><td>函数式接口被实现方法<br />全部参数传给该方法</td><td>(a, b..)-&gt;特定对象.实例方法(a, b..)</td></tr><tr><td>引用某类对象实例方法</td><td>类名::实例方法</td><td>接口第一个参数作为调用者<br />后面参数全部传给该方法</td><td>(a. b…)-&gt;a.实例方法(a,b…)</td></tr><tr><td>引用构造器</td><td>类名::new</td><td>接口全部参数传给该构造器</td><td>(a, b…)-&gt;new 类名(a, b…)</td></tr></tbody></table></div><hr><p>定义一个函数式接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Converter</span>&#123;<br>    Integer <span class="hljs-title function_">convert</span><span class="hljs-params">(String from)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>引用类方法</p><p> <code>Converter converter1 = from-&gt; Integer.valueOf(from);</code></p><p> 可以写成：</p><p> <code>Converter converter1 = Integer::valueOf;</code></p></li><li><p>引用特定对象实例方法</p><p> <code>Converter converter2 = from -&gt;&quot;kit.org&quot;.indexOf(from);</code></p><p> 可以写成：</p><p> <code>Converter converter2 = &quot;fkit.org::indexOf;&quot;</code></p></li><li><p>引用某类对象的实例方法</p><p> 定义如下函数式接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mytest</span>&#123;<br>    String <span class="hljs-title function_">test</span><span class="hljs-params">(String a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 使用Lambda表达式创建对象</p><p> <code>Mytest mt = (a, b, c)-&gt; a.substring(a, b);</code></p><p> 可以写成：</p><p> <code>Mytest mt = String::substring;</code></p></li><li><p>引用构造器</p><p> 定义如下函数式接口</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Mytest</span>&#123;<br>    JFrame <span class="hljs-title function_">win</span><span class="hljs-params">(String title)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 使用Lambda表达式创建一个对象</p><p> <code>Mytest mt = a -&gt; new JFrame(a);</code></p><p> 可以写成：</p><p> <code>Mytest mt = JFrame::new;</code></p></li></ol><h3 id="匿名内部类和Lambda表达式的区别和联系"><a href="#匿名内部类和Lambda表达式的区别和联系" class="headerlink" title="匿名内部类和Lambda表达式的区别和联系"></a>匿名内部类和Lambda表达式的区别和联系</h3><p>相似点：</p><ul><li>都可以直接访问“effectively final”的局部变量，以及外部类的成员变量</li><li>它们创建的对象都可以直接调用从接口继承的默认方法</li></ul><p>不同点：</p><ul><li>匿名内部类可以为任意接口创建实例，不管有多少抽象方法，但Lambda表达式只能为函数式接口创建实例</li><li>匿名内部类可以为抽象类甚至普通类创建实例，但Lambda表达式不是</li><li>匿名内部类实现的抽象方法的方法体允许调用接口定义的默认方法，但Lambda表达式不允许</li></ul><hr><h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>实例有限且固定的类称为枚举类</p><p>使用enum定义枚举类，他也可以有自己的成员变量、构造器和方法，可以实现接口</p><p>但枚举类和普通类有区别</p><ul><li>枚举类可以实现接口，使用enum定义的枚举类默认继承了java.lang.Enum类，<strong>不是默认继承Object类，因此枚举类不能显式继承其他的父类</strong></li><li>使用enum定义的非抽象的枚举类<strong>默认使用final修饰</strong></li><li><strong>枚举类构造器只能使用private修饰，如果省略了访问控制符，系统会默认加上</strong></li><li><strong>枚举类所有实例必须在枚举类第一行显式列出</strong>，否则这个枚举类永远不能产生实例，这些实例系统会自动添加<strong>public static final修饰</strong>，无需显式添加</li></ul><p>枚举类提供一个values方法，可以遍历所有枚举值</p><p>例子</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> SeasonEnum&#123;<br>SPRING, SUMMER, FALL, WINTER;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EnumTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">judge</span><span class="hljs-params">(SeasonEnum s)</span><br>&#123;<br><span class="hljs-comment">// switch语句里的表达式可以是枚举值</span><br><span class="hljs-keyword">switch</span> (s)<br>&#123;<br><span class="hljs-keyword">case</span> SPRING:<br>System.out.println(<span class="hljs-string">&quot;春暖花开，正好踏青&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SUMMER:<br>System.out.println(<span class="hljs-string">&quot;夏日炎炎，适合游泳&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> FALL:<br>System.out.println(<span class="hljs-string">&quot;秋高气爽，进补及时&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WINTER:<br>System.out.println(<span class="hljs-string">&quot;冬日雪飘，围炉赏雪&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-comment">// 枚举类默认有一个values方法，返回该枚举类的所有实例</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> s : SeasonEnum.values())<br>&#123;<br>System.out.println(s);<br>&#125;<br><span class="hljs-comment">// 使用枚举实例时，可通过EnumClass.variable形式来访问</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumTest</span>().judge(SeasonEnum.SPRING);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>switch括号的表达式可以是任何枚举类型，且后面case无需添加枚举类作为限定。</p><p>枚举类提供几种常用方法</p><ul><li><strong>int compareTo(E o)</strong>:用于与指定枚举对象比较顺序，如果该枚举对象在指定枚举对象之后，返回正整数，之前负整数，否则返回0</li><li><strong>String name()</strong>：返回此枚举实例的名称</li><li><strong>String toString()</strong>:也是返回枚举实例名称，优先使用这个</li><li><strong>int ordinal()</strong>:返回枚举值在类中的索引值，就是声明索引中的位置，从零开始</li><li><strong>public static <T extends Enum<T>&gt; T valueOf(Class<T>, String name)</strong>:静态方法，返回指定枚举类中制定名称的枚举值，名称必须与在该枚举类中声明时一致</li></ul><h3 id="枚举类成员变量、方法和构造器"><a href="#枚举类成员变量、方法和构造器" class="headerlink" title="枚举类成员变量、方法和构造器."></a>枚举类成员变量、方法和构造器.</h3><p>Java应该把所有类设计成良好封装的类，所以不应该允许直接访问枚举类的成员变量，应该把成员变量全部设为private final修饰。</p><p>例如一个枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span>&#123;<br>    MALE, FEMALE;<br>    <span class="hljs-keyword">public</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><p>不应该允许直接访问Gender的name成员变量，如果出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Gender</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> Enum.valueOf(Gender.class, <span class="hljs-string">&quot;FEMALE&quot;</span>);<br>g.name = <span class="hljs-string">&quot;男&quot;</span>;<br></code></pre></td></tr></table></figure><p>就会出现混乱。</p><p>如果每个成员用final修饰，就应该在构造器为成员变量指定初始值，例子如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span>&#123;<br>    MALE(<span class="hljs-string">&quot;男&quot;</span>), FEMALE(<span class="hljs-string">&quot;女&quot;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br> <span class="hljs-keyword">private</span> <span class="hljs-title function_">Gender</span><span class="hljs-params">(String name)</span>&#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure><p>在列出枚举值时直接调用构造器创建枚举类对象，这里无需使用new关键字</p><h3 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="　实现接口的枚举类"></a>　实现接口的枚举类</h3><p>枚举类可以实现一个或多个接口</p><p>例如定义一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GenderDesc</span><br>&#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后可以使枚举类实现这个接口，但是如果直接实现info()方法时，<strong>那么每个枚举值在调用这个方法时都有相同行为方法，如果要让每个枚举值在调用这个方法时呈现不同的行为，可以让每个枚举值实现该方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Gender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GenderDesc</span>&#123;<br>MALE(<span class="hljs-string">&quot;男&quot;</span>)<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;代表男性&quot;</span>);<br>&#125;<br>&#125;,<br>FEMALE(<span class="hljs-string">&quot;女&quot;</span>)<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">()</span>&#123;<br>System.out.println(<span class="hljs-string">&quot;代表女性&quot;</span>);<br>&#125;<br>&#125;;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样相当于定义了两个Gender的匿名子类实例，所有实际并没有创建Gender枚举类的实例。</p><p>这相等于这个枚举类是一个抽象类因为它并没有实现它实现的接口的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Operation</span><br>&#123;<br>PLUS<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span><br>&#123;<br><span class="hljs-keyword">return</span> x + y;<br>&#125;<br>&#125;,<br>MINUS<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span><br>&#123;<br><span class="hljs-keyword">return</span> x - y;<br>&#125;<br>&#125;,<br>TIMES<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span><br>&#123;<br><span class="hljs-keyword">return</span> x * y;<br>&#125;<br>&#125;,<br>DIVIDE<br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span><br>&#123;<br><span class="hljs-keyword">return</span> x / y;<br>&#125;<br>&#125;;<br><span class="hljs-comment">// 为枚举类定义一个抽象方法</span><br><span class="hljs-comment">// 这个抽象方法由不同的枚举值提供不同的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">eval</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br>System.out.println(Operation.PLUS.eval(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>));<br>System.out.println(Operation.MINUS.eval(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>));<br>System.out.println(Operation.TIMES.eval(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>));<br>System.out.println(Operation.DIVIDE.eval(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子四个枚举值PLUS,MINUS,TIMES,DIVIDE代表四种运算，该枚举类定义一个eval()方法进行运算。</p><p>我们可以让Operation枚举类定义一个eval()抽象方法，然后让四个枚举值去实现它，编译上面程序会产生五个class文件，四个匿名内部子类分别对应一个class文件，Operatin类对应一个class文件。</p><p>枚举类定义抽象方法时，不需要加上abstract，系统会自动加上，当定义每个枚举值时，必须实现这个抽象方法，否则会出现编译错误。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象(上)</title>
    <link href="/2022/05/11/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8A)/"/>
    <url>/2022/05/11/Java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%8A)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h2><p>面向对象有两个基本概念：类和对象，对象也被称为实例，类是某一批对象的抽象，对象是具体存在的实体。</p><p>类最常见的三种成员</p><ul><li>构造器</li><li>成员变量</li><li>方法</li></ul><p>定义顺序没有任何影响，成员之间可以相互调用</p><p><strong>注意：</strong> <strong>static修饰的成员不能访问没有static修饰的成员。</strong>很好理解，static修饰的成员属于这个类的成员，如果还没有创建对象，但是调用了含有访问没有static修饰的成员的类方法，就会出现错误。</p><p>构造器是一个类创建对象的根本途径，如果一个类没有构造器，这个类无法创建实例。因此Java提供了一个功能：<strong>如果没有为一个类编写构造器，Java会默认为该类提供一个无参数的构造器。但是如果编写了一个有参数的构造器，则不会再有默认的无参数构造器。</strong></p><h3 id="static修饰字"><a href="#static修饰字" class="headerlink" title="static修饰字"></a>static修饰字</h3><p>static修饰字是一个特殊的关键字，可以用来修饰方法变量等，它修饰的成员表明这个成员属于这个类本身，不属于任何对象，因此把static修饰的成员变量和方法叫做类变量和类方法，把没有用static修饰的成员变量和方法叫做实例变量和方法。</p><h3 id="对象的this调用"><a href="#对象的this调用" class="headerlink" title="对象的this调用"></a>对象的this调用</h3><p>Java提供了一个this关键词，this关键词总是指向调用该方法的对象，根据出现位置不同，this作为对象默认调用有两种情况</p><ul><li>构造器中引用该构造器正在初始化的对象</li><li>在方法中调用该方法的对象</li></ul><p>this可以代表任何对象，当this出现在某个方法体中时，它代表的对象是不确定的，但可以确定的是，它所代表的只能是当前类的实例，只有当这个方法被真正调用的时候，才能确定this代表的是哪个对象，谁在调用这个对象，this就代表谁。</p><p>但注意，static修饰的方法不能用this引用。由前面可知，静态成员不能访问非静态成员，所以静态方法不能访问普通成员，如果必须访问的话，则只能在静态方法中定义一个对象，通过这个对象来进行访问。</p><p>大部分时候访问类成员时可以不用this关键词，但如果出现方法中一个局部变量与成员变量同名，又需要访问这个成员变量，则需要加上this。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>Java允许某个类的实例来调用类方法，但这是不应该的，类方法属于这个类，而不属于任何对象，所以不要用对象去调用类方法，而应该直接用类名来调用类方法。</p><h3 id="方法详解"><a href="#方法详解" class="headerlink" title="方法详解"></a>方法详解</h3><p>方法必须定义在类里，所有方法在逻辑上，要么属于这个类本身，要么属于对象。</p><p>​    Java语言是静态的，一个类定义完成后，只要不重新编译这个类文件，该类和该类对象所拥有的方法是固定的，不会改变。</p><p>执行方法时，必须使用类或者对象作为调用者，即所有的方法都必须使用“类.方法”或者“对象.方法”的形式进行调用。</p><p>需要指出：同一类的方法调用另一个方法时，如果被调方法是普通方法，默认使用this作为调用者，如果是类方法，默认使用类作为调用者。</p><h4 id="方法参数传递机制"><a href="#方法参数传递机制" class="headerlink" title="方法参数传递机制"></a>方法参数传递机制</h4><p>Java里方法传递参数方式只有一种，值传递。即如果是基本类型变量，则会将实际参数复制一份传递给方法形参，原来变量不会出现任何改动，如果是引用变量，则变量保存的是实际数据的内存地址，将会把地址传递给方法形参，实际就是C语言中的指针。</p><p>Java允许定义形参变量可变的参数，如果在定义方法时，在最后一个形参类型后增加三点，则表明该形参可以接受多个参数值。</p><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Varargs</span><br>&#123;<br><span class="hljs-comment">// 定义了形参个数可变的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">int</span> a, String... books)</span><br>&#123;<br><span class="hljs-comment">// books被当成数组处理</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> tmp : books)<br>&#123;<br>System.out.println(tmp);<br>&#125;<br><span class="hljs-comment">// 输出整数变量a的值</span><br>System.out.println(a);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-comment">// 调用test方法</span><br>test(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;疯狂Java讲义&quot;</span>, <span class="hljs-string">&quot;轻量级Java EE企业应用实战&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><p>Java允许同一个类定义多个同名方法，只要形参列表不同就行，这被称为方法重载。</p><p><strong>注意：方法重载只要求方法名相同，形参列表不同，至于其他部分，没有要求。</strong></p><p><strong>不推荐在重载形参个数可变的方法。</strong></p><h3 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h3><p>成员变量是在类里定义的变量，局部变量是在方法里定义的变量，其中static修饰的变量是类变量。</p><p>类变量的生存域与类的生存范围相同，实例变量则从该类实例创建起存在，直到系统销毁这个实例。类变量和实例变量统称为成员变量。</p><p>成员变量不需要显式初始化，系统在创建这个变量时会进行默认初始化，int，double，float等数值类型默认初始化为0，布尔类型默认初始化为false。</p><p>局部变量则根据定义形式不同，分为三种</p><ul><li>形参：在定义方法时定义的变量，在整个方法内有效</li><li>方法局部变量：在方法体内定义的变量，作用域是从创建的地方开始，到该方法结束</li><li>代码块局部变量：在代码块中定义的局部变量，作用域从定义地方开始到代码块结束</li></ul><p>局部变量除了形参之外，都需要显式初始化，否则不能访问。</p><h2 id="隐藏和封装"><a href="#隐藏和封装" class="headerlink" title="隐藏和封装"></a>隐藏和封装</h2><p>封装是指不允许外部程序直接访问对象内部信息，而应该通过该类提供的方法间接访问。</p><p>为了实现良好封装，考虑以下两个方面</p><ul><li>将对象的成员变量和实现细节隐藏起来，不允许外部直接访问</li><li>把方法暴露出来，让方法来控制这下成员变量进行安全访问和操作</li></ul><p>使用访问控制符来实现控制访问</p><p>Java提供了3个控制符:public, private, protected</p><p>Java的访问控制级别由小到大依次为</p><p>private——-&gt;default——&gt;protected——&gt;public</p><p>default表示没有访问符修饰</p><p>访问控制级别表</p><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>权限</td><td>private</td><td>default</td><td>protected</td><td>public</td></tr><tr><td>同一个类</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td></tr><tr><td>同一个包</td><td></td><td>可以</td><td>可以</td><td>可以</td></tr><tr><td>子类中</td><td></td><td></td><td>可以</td><td>可以</td></tr><tr><td>全局范围</td><td></td><td></td><td></td><td>可以</td></tr></tbody></table></div><p>但对于一个外部类(相对于内类而言的类，没有子类)而言，只能有public和默认来修饰，其他修饰符没有意义。</p><p>关于控制访问符的使用，几条基本原则</p><ul><li>类里的绝大部分变量应该用private修饰，有一些方法辅助实现该类的其他方法，被称为工具方法，也应该用private修饰。</li><li>如果某个类做其他类的父类，该类里包含的大部分方法仅希望被子类重写，不希望被外界直接调用，用protected修饰</li><li>希望暴露出来给其他类自由调用的方法应该用public修饰。</li></ul><h2 id="深入构造器"><a href="#深入构造器" class="headerlink" title="深入构造器"></a>深入构造器</h2><p>构造器是创建Java对象的重要途径，但这个对象不是完全由构造器负责创建，事实上，当程序调用构造器时，系统会先为该对象分配内存空间，并未这个对象默认初始化，这个对象产生了，这些操作是在构造器执行前完成的。<br>        也就是说，当系统执行构造器之前，构造器已经创建了一个对象，只是这个对象还不能被外界程序访问，只能在构造器中通过this来引用，当构造器执行结束后，这个对象被作为构造器的返回值返回，赋给一个引用类型的变量。</p><h3 id="构造器重载"><a href="#构造器重载" class="headerlink" title="　构造器重载"></a>　构造器重载</h3><p>同一个类里有多个构造器，但形参列表不同，被称为构造器重载。</p><p>如果系统包含了多个构造器，其中一个构造器Ｂ的执行体完全包含另一个构造器Ａ的执行体，那么可以在Ｂ中调用Ａ，使用ｔｈｉｓ关键词来调用相应构造器。</p><h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p>继承通过extends来实现。</p><p>子类可以获得父类的<strong>所有成员变量，方法和内部类</strong>，但不能获得父类的构造器。</p><p><strong>如果父类的成员变量是private修饰的，则子类虽然继承得到了这些变量，但不能直接访问，需通过父类提供的方法来间接访问。</strong></p><h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>子类与父类同名方法的现象被称为方法重写，或者方法覆盖。</p><p>重写要遵循“两同两小一大”原则：“两同”即方法名相同，形参列表形同，“两小”指子类方法返回值比父类方法返回值更小或者相等，子类方法声明抛出的异常比父类方法生命抛出的异常更小或者相等，“一大”指子类方法访问权限比父类方法访问权限更大或者相等。</p><p>需要指出：覆盖方法和被覆盖的方法要么都是类方法，要么都是实例方法。</p><h3 id="super限定"><a href="#super限定" class="headerlink" title="super限定"></a>super限定</h3><p>如果需要在子类方法中调用父类中被覆盖的实例方法，可以使用super限定来调用父类被覆盖的实例。<br>例如父类中有方法fly(),子类可以使用super.fly()来调用父类fly方法。</p><p>super用于限定该对象调用它从父类继承得到的实例变量或方法，super也不能出现在static修饰的方法里。</p><p>当然如果子类没有与父类同名的成员变量可以直接使用名字访问子类从父类继承得到的成员变量，如果同名则应该使用super.a来访问从父类继承得到的a变量。</p><p>如果在构造器中使用super,即直接用<code>super()</code>即可调用父类构造器，super限定该构造器初始化的是该对象从父类继承得到的实例变量，而不是该类自己定义的实例变量。</p><p>使用父类构造器必须出现在子类构造器的第一行，不管是否通过super调用父类构造器，子类构造器总会调用父类构造器一次，即如果子类构造器执行体没有super和this调用，系统会在执行子类构造器之前，隐式调用父类无参数的构造器。</p><p>当执行父类构造器时，系统会再上溯执行父类的父类的构造器，依次类推，创建任何Java对象，最先执行的总是Object类的构造器。</p><h2 id="多态"><a href="#多态" class="headerlink" title="　多态"></a>　多态</h2><p>Java引用变量有两个类型：编译时类型和运行时类型。</p><p>编译时类型由声明该变量时使用的类型决定，运行时类型由实际赋给的变量对象决定。如果两个类型不一致，就有可能出现多态。</p><p>Java允许把一个子类对象赋给父类引用变量，无需任何类型转换，这个称为向上转型，由系统自动完成。</p><p>当运行时，调用父类的引用变量方法时，方法行为体现出子类方法的行为特征，一个父类可能有多个子类，这就有可能出现同一个类型的变量调用同一个方法时，呈现出不同的行为特征，即多态。</p><p>但与方法不同，对象的实例变量不具有多态性，如果子类和父类中有相同名称的成员变量，当使用父类引用变量输出该变量时，输出的就是父类的成员变量。</p><p><strong>注意：引用变量在编译阶段只能调用编译时类型的方法，但运行时执行运行时类型具有的方法，因此写代码时，引用变量只能调用声明该变量时所用类里的方法，例如<code>Object p = new Person();</code>，这个p只能调用Object类里的方法，不能调用Person类里的方法。</strong></p><h3 id="引用变量的强制类型转换"><a href="#引用变量的强制类型转换" class="headerlink" title="　引用变量的强制类型转换"></a>　引用变量的强制类型转换</h3><p>如果需要让引用变量调用运行时类型的方法，则必须把它强制类型转换为运行时类型，使用类型转换运算符，(type)variable。</p><p>需要注意：</p><ul><li>基本类型之间转换只能在数值类型之间进行，数值类型和布尔类型不能相互转换</li><li>引用类型之间转换只能在具有继承关系的两个类型之间进行，没有任何继承关系的类型，无法进行强制转换。</li></ul><p>在强制类型转换之前，使用instanceof运算符进行判断是否可以成功转换，可以使程序更加健壮。</p><p>instanceof运算符的前一个操作数是引用类型变量，后一个通常是一个类(也可以是接口)，它用于判断前面的对象是否属于后面的类，或者其子类、实现类的实例，是返回true，否则false</p><p>使用时注意：前面操作数编译时类型要么与后面类相同，要么与后面的类具有继承关系，否则会编译错误</p><h2 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h2><p>继承是实现类复用的重要手段，但继承最大的坏处是破坏了封装。而采用组合实现类复用可以提供更好的封装性。</p><p>使用继承需要注意的几点</p><ul><li>尽量隐藏父类的内部数据，把所有成员变量设为private类型，不要让子类直接访问父类的成员变量</li><li>不要让子类随意访问修改父类的方法，父类中的工具方法应该使用private控制符修饰，如果父类方法需要被外部类调用，但又不希望子类重写，可以使用final修饰符修饰</li><li>尽量不要在父类构造器中调用将被子类重写的方法。</li></ul><p>如果不想让某个类被继承，可以使用final修饰这个类，也可以使用private修饰这个类的所有构造器，从而使子类无法调用该类构造器，也就无法继承该类。</p><p>利用组合来实现类复用实际就是在新类中创建一个需要复用的类的引用变量，这样就可以使用旧类的成员变量和方法。</p>]]></content>
    
    
    <categories>
      
      <category>编程学习</category>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java基础</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo使用</title>
    <link href="/2022/05/09/hexo%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/05/09/hexo%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="发布文章"><a href="#发布文章" class="headerlink" title="发布文章"></a>发布文章</h2><p>在source的_post文件夹中创建markdown文件，并在文章最上方写明文章基本属性。</p><p>基本属性使用yaml格式，冒号和后面文字必须空一格。使用—-可以创建yaml，即三个杠。</p><p>或使用命令<code>hexo n &quot;文件名称&quot;</code></p><p>写完文章后，依次执行以下命令：</p><p><code>hexo clean</code>：清理静态文件</p><p><code>hexo generate / hexo g</code>：重新生成文件</p><p><code>hexo deploy / hexo d</code>：部署</p><p>即可完成文章发布。</p><p>修改文章也类似。</p>]]></content>
    
    
    <categories>
      
      <category>工具使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
